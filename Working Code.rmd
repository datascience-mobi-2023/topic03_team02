---
title: "Topic 3: Proteome-wide Screen for RNA-dependent Proteins; Subtopic 3: HeLa synchronized in Mitosis"
author: "Jimena, Alexandra, Verena"
date: "2023-05-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Topic 3.3: HeLa Cells Synchronized in Mitosis

### Proteome-wide Screen for RNA-dependent Proteins

Load the dataset from the Dropbox

```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")
head(RDeeP_HeLa_Mitosis)
```

## 1. Preparing data for analysis (Data Cleanup)

#### 1.1 Data description

```{r}
dim(RDeeP_HeLa_Mitosis)
head(rownames(RDeeP_HeLa_Mitosis))
head(colnames(RDeeP_HeLa_Mitosis))
```

#### 1.2 Finding rows with missing values

Finding which rows are all 0 (and are most likely experimental errors). And removing this rows.

```{r}
which(rowSums(RDeeP_HeLa_Mitosis)==0)

print(RDeeP_HeLa_Mitosis["KLD10_HUMAN",])

RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),] #Habe hier das letzte Komma hinzugefügt und das = in ein <- geändert.

#Tabelle ohne die Nullzeile wieder in der Variable gespeichert

dim(RDeeP_HeLa_Mitosis)
```

#### 1.3 Handeling other wierd rows

When looking at the dataset we noticed that already the first 7 rows have accumulation of protein in every fraction. We are not sure if we can work with them as they maybe have no clear peak, therefore we first identify them and then maybe delete them later.

```{r}
# Find rows without any zeros
nonzero_rows <- RDeeP_HeLa_Mitosis[rowSums(RDeeP_HeLa_Mitosis == 0) == 0, ]

#The condition rowSums(RDeep_Hela_Mitosis == 0) == 0 checks which rows have a sum of zeros equal to zero, indicating that those rows do *not* contain any zeros.Then we selects these rows without any zeros from our table and store it in a new table.

# Print the rows without any zeros
print(nonzero_rows)
nrow(nonzero_rows) #320 rows do not have zeros


#Possibly deleting these nonzero rows and storing it in the original matrix:
#RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[rowSums(RDeeP_HeLa_Mitosis == 0) > 0, ]

```

#### 1.4 Check data format

Here we try to determine data type of our dataset, whether it is numerical, categorical, etc
```{r}

nrow(RDeeP_HeLa_Mitosis)
ncol(RDeeP_HeLa_Mitosis)
sum(apply(RDeeP_HeLa_Mitosis, 1, is.na)) # Summe aller Spalten, die NA Werte haben
sum(apply(RDeeP_HeLa_Mitosis, 2, is.na)) # Summe aller Zeilen, die NA Werte haben
sum(apply(RDeeP_HeLa_Mitosis, 1, is.numeric))
sum(apply(RDeeP_HeLa_Mitosis, 2, is.numeric))

sum(apply(RDeeP_HeLa_Mitosis, 1, is.numeric)) == nrow(RDeeP_HeLa_Mitosis)

```

This means we have numeric data, aka the data from the mass spectrometry.

```{r}
#Complete DataSet
View(RDeeP_HeLa_Mitosis)
```

#### 1.5 Checking reproducibility with student t-test

The first step would be to perform a student t-test on the first three values in our table, so for example protein 1, Control Fraction 1 the rep1, rep2, rep3

```{r}
# Extract the first three values from the table
protein1_Ctrl_frac1 <- RDeeP_HeLa_Mitosis[1, 1:3] #Zeile 1, Spalten eins bis drei

# Perform the t-test
print(t.test(protein1_Ctrl_frac1))

#beide schritte kann man theoretisch auch noch in einem vereinigen.
```
Here our p-value is over 5%, thus we can determine the reproducibility of the experiment is not given and we would have to delete the entire protein. How much sense this makes we will see later. 

Now the same for protein 8

```{r}
# Extract the first three values from the table
protein8_Ctrl_frac1 <- RDeeP_HeLa_Mitosis[8, 1:3]

# Perform the t-test
print(t.test(protein8_Ctrl_frac1))
```
Here all three repetitions were 0, thus making our p-value not determinable. This is normal and we would have to repeat this for all fractions and then check if there are any p-values in the entire protein above 5%. If not, we can confidently confirm the reproducibility.

Here an attempt to generalize the code for all fractions for one Protein (Control and RNAse separate)

```{r}
#easiest way is to separately define the columns we want to put into the new data frame

RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])

#For RNase it is easier, because we now can just take all the row which were not taken in the first table. 
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]

head(RDeeP_HeLa_Mitosis_RNase)
```

Now in the next step we try to apply a student t-test on every three values, and then finding the maxima of all these p-values.

```{r}
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Extract the values for the current row (protein)
  row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
  
  # Create an empty vector to store the p-values for the current row (protein)
  p_values_row <- c()
  
  # Iterate over every three columns in the current row (protein)
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Extract the values for the current set of three columns
    column_values <- row_values[j:(j + 2)]
    
    # Calculate the p-value for the set of three columns using t-test
    t_result <- t.test(column_values)
    p_value <- t_result$p.value
    
    # Append the p-value to the vector for the current row (protein)
    p_values_row <- c(p_values_row, p_value)
  }
  
  # Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
  p_values_Ctrl[i, ] <- p_values_row
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))

# Print the new dataframe
print(p_values_Ctrl)
```

Almost everything seems to work out fine, the code just takes VERY LONG. Here is a more efficient/faster solution, trying to use the power of vectorization in R.

```{r}
# Identify the numeric columns in the table
numeric_cols <- sapply(RDeeP_HeLa_Mitosis_Ctrl, is.numeric)

# Subset the table to include only numeric columns
numeric_table <- RDeeP_HeLa_Mitosis_Ctrl[, numeric_cols]

# Calculate the number of sets in the numeric table
num_sets <- ncol(numeric_table) %/% 3

# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = num_sets, nrow = nrow(numeric_table)))

# Iterate over every set of three columns
for (i in seq(1, ncol(numeric_table), by = 3)) {
  # Extract the values for the current set of three columns
  column_values <- numeric_table[, i:(i + 2)]
  
  # Calculate the p-values for the set of three columns using t-tests
  p_values <- apply(column_values, 1, function(x) {
    if (length(unique(x)) > 1) {
      t_result <- t.test(x)
      t_result$p.value
    } else {
      NA  # Assign NA if the data is constant
    }
  })
  
  # Assign the p-values to the corresponding column in the new dataframe
  p_values_Ctrl[, (i %/% 3 + 1)] <- p_values
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:num_sets)
rownames(p_values_Ctrl) <- rownames(RDeeP_HeLa_Mitosis_Ctrl)

# Print the new dataframe
print(p_values_Ctrl)
```


Finding the maximum value for each row, then deciding if it is smaller than our significance level (either 5% or 10%, has to be decided beforehand)

```{r}
# Create a new dataframe to store the maximum values
max_values <- data.frame(MaxValue = apply(p_values_Ctrl[, -1], 1, max))

# Adding the protein names to the new dataframe:
rownames(max_values) <- rownames(p_values_Ctrl)

# Print the new dataframe
print(max_values)
```
WARNING! This still leaves us with the problem on how to handle the many *NA values* (caused if zeros appear in the experiment, which then causes student t-test to have issues, even though those are important data). I am not sure how to fix this.


#### 1.6 Checking reproducibility with correlation?

Testing the correlation for the first three entries in our Control dataset.A possible idea is to apply this all on the entire dataset again, and then for example sort out all proteins in which the correlation between the fractions is less than 95%. This will then guarantee that all remaining fractions have a high correlation and thus a high reproducibility. But there is still a lot to do!

```{r}
# Calculate the pairwise correlations between the first three columns
cor_matrix_frac1 <- cor(RDeeP_HeLa_Mitosis_Ctrl[, 1:3], method = "pearson")

# Visualize the correlation matrix using a heatmap
heatmap(cor_matrix_frac1,
        col = colorRampPalette(c("blue", "white", "red"))(100),
        main = "Correlation Heatmap")

# we maybe still have to adjust the color Palette. 

print(as.table(cor_matrix_frac1))
```

#### 1.7 Data scaling

After we have removed all rows with low reproducibility (this still has to be done!!), we can then move on to scale all remaining data to 100. This makes the most sense if we first take the mean value of all replicates and then scale them.

```{r}
#First we take our RDeep_Hela_Mitosis_Ctrl table again. 
```



#### 1.8 Min Max scaling

This would be an alternative to the mean value data scaling method. Here we would take the max und min value of each row (control and RNase separate) and scale all data in between these margins. Not sure yet how to implement this. 



