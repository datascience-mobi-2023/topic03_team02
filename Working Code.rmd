---
title: "Topic 3: Proteome-wide Screen for RNA-dependent Proteins; Subtopic 3: HeLa synchronized in Mitosis"
author: "Jimena, Alexandra, Verena"
date: "2023-05-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Topic 3.3: HeLa Cells Synchronized in Mitosis

### Proteome-wide Screen for RNA-dependent Proteins

Load the dataset from the Dropbox

```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")
head(RDeeP_HeLa_Mitosis)
```

## 1. Preparing data for analysis (Data Cleanup)

#### 1.1 Data description

```{r}
dim(RDeeP_HeLa_Mitosis)
head(rownames(RDeeP_HeLa_Mitosis))
head(colnames(RDeeP_HeLa_Mitosis))
```

#### 1.2 Finding rows with missing values

Finding which rows are all 0 (and are most likely experimental errors). And removing this rows.

```{r}
which(rowSums(RDeeP_HeLa_Mitosis)==0)

print(RDeeP_HeLa_Mitosis["KLD10_HUMAN",])

RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),] #Habe hier das letzte Komma hinzugefügt und das = in ein <- geändert.
#Tabelle ohne die Nullzeile wieder in der Variable gespeichert

#We might have to repeat this later, for when we have separated Control and RNase, as the same argumentation applies if already only one of them only has zeros.
#which(rowSums(RDeeP_HeLa_Mitosis_Ctrl)==0)
#which(rowSums(RDeeP_HeLa_Mitosis_RNase)==0) #Careful, that we have to delete the the zero rows of RNase also in the Control Dataframe


dim(RDeeP_HeLa_Mitosis)
```

#### 1.3 Handeling other wierd rows

When looking at the dataset we noticed that already the first 7 rows have accumulation of protein in every fraction. We are not sure if we can work with them as they maybe have no clear peak, therefore we first identify them and then maybe delete them later.

```{r}
# Find rows without any zeros
nonzero_rows <- RDeeP_HeLa_Mitosis[rowSums(RDeeP_HeLa_Mitosis == 0) == 0, ]

#The condition rowSums(RDeep_Hela_Mitosis == 0) == 0 checks which rows have a sum of zeros equal to zero, indicating that those rows do *not* contain any zeros.Then we selects these rows without any zeros from our table and store it in a new table.

# Print the rows without any zeros: print(nonzero_rows)
nrow(nonzero_rows) #320 rows do not have zeros


#Possibly deleting these nonzero rows and storing it in the original matrix:
#RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[rowSums(RDeeP_HeLa_Mitosis == 0) > 0, ]

```

#### 1.4 Check data format

Here we try to determine data type of our dataset, whether it is numerical, categorical, etc

```{r}

nrow(RDeeP_HeLa_Mitosis)
ncol(RDeeP_HeLa_Mitosis)
sum(apply(RDeeP_HeLa_Mitosis, 1, is.na)) # Summe aller Spalten, die NA Werte haben
sum(apply(RDeeP_HeLa_Mitosis, 2, is.na)) # Summe aller Zeilen, die NA Werte haben
sum(apply(RDeeP_HeLa_Mitosis, 1, is.numeric))
sum(apply(RDeeP_HeLa_Mitosis, 2, is.numeric))

sum(apply(RDeeP_HeLa_Mitosis, 1, is.numeric)) == nrow(RDeeP_HeLa_Mitosis)

```

This means we have numeric data, aka the data from the mass spectrometry.

```{r}
#Complete DataSet
#View(RDeeP_HeLa_Mitosis)
```

#### 1.5 Checking reproducibility with student t-test

The first step would be to perform a student t-test on the first three values in our table, so for example protein 1, Control Fraction 1 the rep1, rep2, rep3

```{r}
# Extract the first three values from the table
protein1_Ctrl_frac1 <- RDeeP_HeLa_Mitosis[1, 1:3] #Zeile 1, Spalten eins bis drei

# Perform the t-test
print(t.test(protein1_Ctrl_frac1))

#beide schritte kann man theoretisch auch noch in einem vereinigen.
```

Here our p-value is over 5%, thus we can determine the reproducibility of the experiment is not given and we would have to delete the entire protein. How much sense this makes we will see later.

Now the same for protein 8

```{r}
# Extract the first three values from the table
protein8_Ctrl_frac1 <- RDeeP_HeLa_Mitosis[8, 1:3]

# Perform the t-test
print(t.test(protein8_Ctrl_frac1)) 
```

Here all three repetitions were 0, thus making our p-value not determinable. This is normal and we would have to repeat this for all fractions and then check if there are any p-values in the entire protein above 5%. If not, we can confidently confirm the reproducibility.

Here an attempt to generalize the code for all fractions for one Protein (Control and RNAse separate)

```{r}
#easiest way is to separately define the columns we want to put into the new data frame

RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])

#For RNase it is easier, because we now can just take all the row which were not taken in the first table. 
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]

head(RDeeP_HeLa_Mitosis_RNase)
```

Now in the next step we try to apply a student t-test on every three values, and then finding the maxima of all these p-values. Here is efficient solution, using the power of vectorization in R.

```{r}
# Calculate the number of sets in the Control Dataset
num_sets <- ncol(RDeeP_HeLa_Mitosis_Ctrl) %/% 3
print(num_sets) #25 - number of fractions

# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))
print(p_values_Ctrl)

# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
  # Extract the values for the current set of three columns
  column_values <- RDeeP_HeLa_Mitosis_Ctrl[, i:(i + 2)]
  
  # Calculate the p-values for the set of three columns using t-tests
  p_values <- apply(column_values, 1, function(x) {
    if (length(unique(x)) > 1) {
      t_result <- t.test(x)
      t_result$p.value
    } else {
      0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
    }
  })
  
  # Assign the p-values to the corresponding column in the new dataframe
  p_values_Ctrl[, (i %/% 3 + 1)] <- p_values
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_Ctrl) <- rownames(RDeeP_HeLa_Mitosis_Ctrl)

# Print the new dataframe
print(p_values_Ctrl)
```

Finding the maximum value for each row, then deciding if it is smaller than our significance level (either 5% or 10%, has to be decided beforehand)

```{r}
# Replace NA values with zero in p_values_Ctrl dataframe
# p_values_Ctrl[is.na(p_values_Ctrl)] <- 0

# Create a new dataframe to store the maximum values
max_values_Ctrl <- data.frame(MaxValue = apply(p_values_Ctrl[, -1], 1, max))

# Adding the protein names to the new dataframe:
rownames(max_values_Ctrl) <- rownames(p_values_Ctrl)

# Print the new dataframe
print(max_values_Ctrl)
```

We still have to determine which p-values are over 10% and use that information on the dataframe. But now first all the same for the RNase:

```{r}
# Calculate the number of sets in the RNase dataset
num_sets <- ncol(RDeeP_HeLa_Mitosis_RNase) %/% 3

# Create an empty dataframe to store the p-values
p_values_RNase <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_RNase)))

# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_RNase), by = 3)) {
  # Extract the values for the current set of three columns
  column_values <- RDeeP_HeLa_Mitosis_RNase[, i:(i + 2)]
  
  # Calculate the p-values for the set of three columns using t-tests
  p_values <- apply(column_values, 1, function(x) {
    if (length(unique(x)) > 1) {
      t_result <- t.test(x)
      t_result$p.value
    } else {
      0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
    }
  })
  
  # Assign the p-values to the corresponding column in the new dataframe
  p_values_RNase[, (i %/% 3 + 1)] <- p_values
}

# Optional: Rename the columns
colnames(p_values_RNase) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_RNase) <- rownames(RDeeP_HeLa_Mitosis_RNase)

# Print the new dataframe
print(p_values_RNase)
```

```{r}
# Finding the maximum
# Create a new dataframe to store the maximum values
max_values_RNase <- data.frame(MaxValue = apply(p_values_RNase[, -1], 1, max))

# Adding the protein names to the new dataframe:
rownames(max_values_RNase) <- rownames(p_values_RNase)

# Print the new dataframe
print(max_values_RNase)

#Testing how many RNase values we have above 5%/10%:
sum(max_values_RNase > 0.05)
sum(max_values_RNase > 0.1)
#For control
sum(max_values_Ctrl > 0.05)
sum(max_values_Ctrl > 0.1)
# --> RNase has a lot more fluctiation in comparison to Control!

#Alternative ways to calculate the above
#length(which(max_values_RNase > 0.1))
#length(max_values_RNase[max_values_RNase$MaxValue > 0.1, ])
```

Whoops, that is A LOT! Sometimes that is more than half (or more than a quarter) of our data...

Now adding the columns to the main dataframe and doing the same, identify the rows in which the p-value exceeds 10%:

```{r}
RDeeP_HeLa_Mitosis_p <- data.frame(RDeeP_HeLa_Mitosis, max_values_Ctrl, max_values_RNase) 

# Identify all rows where the value in _one_ of the last two columns exceeds 5% or 10%

bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 | RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
bad_proteins10 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.1 | RDeeP_HeLa_Mitosis_p[, 152] > 0.1)

#When using the logical OR (|) operator, if either condition is true, the result will be true. 


#Rows in which both Control and RNase p-values exceed 5%:
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 & RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
#length(bad_proteins5)

#Alternative 5%/10% BUT THIS RESULTS IN ANTOHER VALUE, WHY? I DO NOT KNOW.
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.05)
bad_proteins10wierd <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.1)

length(bad_proteins5)
length(bad_proteins10)
length(bad_proteins10wierd)
```

Anywayyyy, let's work with the 10 % margin and delete all corresponding rows.

```{r}
RDeeP_HeLa_Mitosis_clean <- RDeeP_HeLa_Mitosis_p[!(RDeeP_HeLa_Mitosis_p[, 151] > 0.1 | RDeeP_HeLa_Mitosis_p[, 152] > 0.1), ] #the ! Operator negate the condition.It excludes rows where the condition is TRUE, thus effectively filtering out rows that exceed 10%.

# Remove the last two columns
RDeeP_HeLa_Mitosis_clean <- RDeeP_HeLa_Mitosis_clean[, 1:(ncol(RDeeP_HeLa_Mitosis_clean) - 2)]

#Print the new dataframe
print(RDeeP_HeLa_Mitosis_clean)
```

```{r}
#Now we have to again separate our clean dataframe into Control and RNase

Mitosis_Ctrl_clean = cbind(RDeeP_HeLa_Mitosis_clean[,1:3],RDeeP_HeLa_Mitosis_clean[,7:9],RDeeP_HeLa_Mitosis_clean[,13:15],RDeeP_HeLa_Mitosis_clean[,19:21],RDeeP_HeLa_Mitosis_clean[,25:27],RDeeP_HeLa_Mitosis_clean[,31:33],RDeeP_HeLa_Mitosis_clean[,37:39],RDeeP_HeLa_Mitosis_clean[,43:45],RDeeP_HeLa_Mitosis_clean[,49:51],RDeeP_HeLa_Mitosis_clean[,55:57],RDeeP_HeLa_Mitosis_clean[,61:63],RDeeP_HeLa_Mitosis_clean[,67:69],RDeeP_HeLa_Mitosis_clean[,73:75],RDeeP_HeLa_Mitosis_clean[,79:81],RDeeP_HeLa_Mitosis_clean[,85:87],RDeeP_HeLa_Mitosis_clean[,91:93],RDeeP_HeLa_Mitosis_clean[,97:99],RDeeP_HeLa_Mitosis_clean[,103:105],RDeeP_HeLa_Mitosis_clean[,109:111],RDeeP_HeLa_Mitosis_clean[,115:117],RDeeP_HeLa_Mitosis_clean[,121:123],RDeeP_HeLa_Mitosis_clean[,127:129],RDeeP_HeLa_Mitosis_clean[,133:135],RDeeP_HeLa_Mitosis_clean[,139:141],RDeeP_HeLa_Mitosis_clean[,145:147])

#For RNase
Mitosis_RNase_clean=RDeeP_HeLa_Mitosis_clean[,-which(names(RDeeP_HeLa_Mitosis_clean) %in% colnames(Mitosis_Ctrl_clean))]


#additional cleanup: deleting all rows in RNase and Ctrl which are zero, removing these rows from the entire clean dataframe
which(rowSums(Mitosis_Ctrl_clean)==0)
which(rowSums(Mitosis_RNase_clean)==0) 
# Removing BT2A3_HUMAN SEPP1_HUMAN from each dataframe and saving in in the same variable again:
Mitosis_Ctrl_clean <- Mitosis_Ctrl_clean[!(rownames(Mitosis_Ctrl_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
Mitosis_RNase_clean <- Mitosis_RNase_clean[!(rownames(Mitosis_RNase_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
```

## 2. Data scaling

#### 2.1 Finding mean

After we have removed all rows with low reproducibility, we can then move on to scale all remaining data to 100. This makes the most sense if we first take the mean value of all replicates and then scale them.

```{r Finding mean}
#First finding the mean of all three replicates for every fraction separately in our Mitosis_Ctrl_clean data:
Mitosis_Ctrl_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
    apply(Mitosis_Ctrl_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    #inner loop which calculates the mean for the three replicates, for each row anew. and CAUTION: if we delete some rows, we might have to adjust the name of the dataframe.
    
    }))

#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")

head(Mitosis_Ctrl_mean)
```

#### 2.2 Data scaling to 100

Now trying data scaling to 100:

```{r scaling Ctrl to 100}
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))

head(Mitosis_Ctrl_100)

```

Seems to work? Now all the same for RNase:

```{r}
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(Mitosis_RNase_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    }))

colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")

#Now scaling 
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))

head(Mitosis_RNase_100)
```

#### 2.3 Min Max scaling

This would be an alternative to the data scaling to 100 method. We rescale the values to a fixed range, typically between 0 and 1. The scaling process involves subtracting the minimum value from each value in the variable and then dividing by the range (maximum value minus the minimum value). This transformation ensures that all values are proportionally scaled within the specified range.

```{r Min Max scaling}
# Min-max scaling function
min_max_scaling <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column). 

#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling)) 

# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
```

We can later decide which method to chose.

```{r Clean environment}
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values,protein1_Ctrl_frac1,protein8_Ctrl_frac1,bad_proteins5)
```

## 3. Visualization

#### 3.1 Visualization using row index

This code helps us visualize one specific protein

```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein

# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

#### 3.2 Visualization using protein name

View a protein and its peak using the protein name

```{r}
# Step 1: Select a specific row by name
row_name <- "2A5E_HUMAN" #'ABT1_HUMAN' (right shifter) #'ABCF1_HUMAN' (left shifter)

# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

## 4. Different shift finders

#### 4.1 Peak finder (only absolute maxima)

Overview to know in which fraction the max was found. The vector should then help for further analysis.
Overview for Ctrl Dataframe.
```{r Peak finder Ctrl}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)

# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)

#Results as vector
#as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max) 

```

Now the same for RNase

```{r Peak finder RNase}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_RNase_100)

# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind
#Bei mir passt alles? Ist das noch aktuell? Wenn nein kommentare gern löschen - Verena

# Print the results
# Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)

#Results as vector
#as.vector(RNase_fraction_max) #just numbers (aka fractions where max) 
```

We subtract the value in Ctrl_fraction_max (Ctrl fraction where max) with the value in RNase_fraction_max (RNase fraction where max) . If the result:
'=' 0: no shift
'>' 0: (positive number) left shift (normal, bedeutet max fraction bei Control ist größer als max fraction bei RNase)
'<' 0: (negative number) right shift (meist eher ungewöhnlich, bedeutet RNase Fraktion ist größer als Control fraktion, Protein ist irgendwie schwerer geowrden)

```{r Peak assigner}
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max

#Code which would only assign a shift of 0 to no shift
#shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))

# Code which would assign a shift of 1 or less to "no shift": *HERE THE NUMBER CAN BE CHANGED!*
shift_result <- ifelse((shift_result >= -1) & (shift_result <= 1), "no shift", ifelse(shift_result > 1, "left shift", "right shift"))


# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"

# Print the new dataframe
print(shift_dataframe)

shift_dataframe["RBM3_HUMAN",] #RBM3 is a sure shifter, siehe graph etc. (aber auch komplex)
```

```{r}
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")

sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
```

#### 4.2 Local maxima

Next step would to further analyse our left shift and right shift proteins.

For our shift proteins, we now want to compare all the location of the absolute and local maxima in Control and RNase with each other. Here, we save the column indices of Mitosis_RNase_100, with all maxima, no matter local or absolute, in a new dataframe (RNase_maxima) and repeat this process with Mitosis_Ctrl_100. 

Then we compare if all peaks found in RNA are identical to all peaks found in Control (by comparing the column indices of the peaks). If they are identical, the condition results in TRUE, otherwise FALSE.

TRUE: no shift, because all local maxima are identical
FALSE: shifter -> change of amount or location of maxima
```{r}
# Create an empty vector to store the results
results <- vector("logical", nrow(Mitosis_Ctrl_100))

# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
  # Get the row data for Ctrl and RNase
  row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
  row_data_RNase <- Mitosis_RNase_100[i, ]
  
  # Find the peaks in the row data for Ctrl
  peaks_Ctrl <- c()
  for (j in 2:(length(row_data_Ctrl) - 1)) {
    if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
      peaks_Ctrl <- c(peaks_Ctrl, j)
    }
  }
  
  # Find the peaks in the row data for RNase
  peaks_RNase <- c()
  for (j in 2:(length(row_data_RNase) - 1)) {
    if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
      peaks_RNase <- c(peaks_RNase, j)
    }
  }
  
  # Compare the peaks between Ctrl and RNase
  if (identical(peaks_Ctrl, peaks_RNase)) {
    results[i] <- TRUE
  } else {
    results[i] <- FALSE
  }
}

# Create a data frame with the results
identical_fractions <- data.frame(no_shift = results, row.names = row.names(Mitosis_Ctrl_100))

# Print the identical_fractions dataframe
print(identical_fractions)

identical_fractions["SQOR_HUMAN",] #-> FALSE, thus this protein is rightly identified as a shifter
sum(identical_fractions$no_shift == FALSE) #-> 1570 proteins are identified as shifters
```

We get true results for all no shift proteins, meaning they have identical local and absolute maxima. To define clusters, we could convert TRUE to 0 and FALSE to 1 maybe, but how useful this is we are not sure yet. I checked a few shifting proteins, and they mostly get the right "FALSE" result.

#### 4.2.1 LOCAL MAX CODE DER ANZAHL DES LOCAL SHIFTS IDENTIFIZIERT

--> Hier wird jedoch nicht ein shift in den local maxima betrachtet, sondern nur ob mehr entstehen oder welche verschwinden zwischen Control und RNase. Dadurch werden ziemlich viele Proteine vernachlässigt, genauer gesagt 1570-900, also 670 Proteine werden dadurch nicht aufgeführt... Evt. später anpassen.

```{r}
# Create an empty vector to store the results
results <- vector("integer", nrow(Mitosis_Ctrl_100))

# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
  # Get the row data for Ctrl and RNase
  row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
  row_data_RNase <- Mitosis_RNase_100[i, ]
  
  # Find the peaks in the row data for Ctrl
  peaks_Ctrl <- c()
  for (j in 2:(length(row_data_Ctrl) - 1)) {
    if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
      peaks_Ctrl <- c(peaks_Ctrl, j)
    }
  }
  
  # Find the peaks in the row data for RNase
  peaks_RNase <- c()
  for (j in 2:(length(row_data_RNase) - 1)) {
    if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
      peaks_RNase <- c(peaks_RNase, j)
    }
  }
  
  # Calculate the difference in peak counts
  diff_peaks <- length(peaks_RNase) - length(peaks_Ctrl)
  
  # Store the difference in the results vector
  results[i] <- diff_peaks
}

# Create a data frame with the results
identical_fractions2 <- data.frame(local_shift = results, row.names = row.names(Mitosis_Ctrl_100))

# Print the identical_fractions dataframe
print(identical_fractions2)

# Count the number of entries not equal to zero in the no_shift column
sum(identical_fractions2$local_shift != 0)
```

#### 4.3 Comparing local with absolute maxima

All rows with "left shift" or "right shift" in the shift_dataframe dataframe are compared with all "FALSE" results in the identical_fractions dataframe (aka shifters). If the rows fullfill both criteria in the respective dataframe, I want to create a new dataframe named dodgy_proteins, in which these rows have the result "TRUE". 
(this code only works if you run the working code beforehand)

```{r}
# Create an empty dataframe to store the results
dodgy_proteins <- data.frame(Result = logical(nrow(shift_dataframe)), row.names = row.names(shift_dataframe))

# Iterate over the rows of shift_dataframe
for (row_name in row.names(shift_dataframe)) {
  # Check if the row meets the criteria in shift_dataframe
  if ((shift_dataframe[row_name, ] %in% c("right shift", "left shift")) & !identical_fractions[row_name, ]) {
    # Assign TRUE to the corresponding row in dodgy_proteins
    dodgy_proteins[row_name, ] <- TRUE #These proteins give different results in each method!!!
  } else {
    # Assign FALSE to the corresponding row in dodgy_proteins
    dodgy_proteins[row_name, ] <- FALSE
  }
}

# Print the dodgy_proteins dataframe
print(dodgy_proteins)

sum(dodgy_proteins$Result)

sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
```
Nice! Both methods seem to give the EXACT SAME PROTEINS. (Only comparing the number would not guarantee that the proteins are identical, but I try to avoid this using this code.) Explanation: we have 581 TRUE results in our dataframe, meaning in 581 rows (proteins) both criteria are fulfilled. Now we count how many proteins are in total identified as shifters in the maximum peak method: also 581
```{r}
#Count how many have been identified using the local fraction comparison method:
sum(!identical_fractions) #Checks all FALSE (aka shifters) results in the dataframe
```
This is A LOT more! Aka the maximum peak shifter only identifies about half of the proteins which the local fraction comparison identifies as shifters.

#### 4.3 Curve quotients comparison

```{r}
# Calculate the curve quotients using vectorized operations
curve_quotients <- (Mitosis_Ctrl_100+1) / (Mitosis_RNase_100+1)

# Set the row names of curve_quotients
row.names(curve_quotients) <- row.names(Mitosis_Ctrl_100)

# Print the curve_quotients dataframe
print(curve_quotients)
```

Hier bedeutet ein Wert von 1 eine komplette Übereinstimmung. Je mehr richtung null, desto größer ist der RNase Wert im Vergleich zum Control wert (aka RNase peak), je näher richtung 2, 3, 4 etc, desto größer ist der Ctrl Wert (aka Ctrl peak).

Eine Möglichkeit jetzt wäre zu sagen, wir gucken welche proteine im Quotienten einen Wert tiefer als 0,8 haben, also eine abweichung um 25% (z.B. : Ctrl=4, und RNase=4 * 1,25, also 25% größer, und 4/(4 * 1,25) =0,8). Oder eben einen Wert größer als 1,25. Dann würden wir diese Proteine als shifter definieren.
--> Hier sind paar zu viele shifter identifiziert worden
Alternativ: Werte weichen um 60% ab, dann Werte kleiner als 0,625 und Werte größer als 1,6. 
--> Hier ist fast nichts mehr ein shifter.

```{r}
# Create the shifting_quotients dataframe
shifting_quotients <- data.frame("Curve_shifters" = apply(curve_quotients, 1, function(row) {
  if (any(row < (4/(4*1.3)) | row > 1.3)) { #Code so angepasst das direkt die Prozentzahlen eingetragen werden können. Alternatives Vorgehen: mit "signifikanter Abweichung" arbeiten. Aber wie definiert?)
    "shifter"
  } else {
    "not shifter"
  }
}))

# Print the shifting_quotients dataframe
print(shifting_quotients)

shifting_quotients["RBM3_HUMAN",] #RBM3 is a sure shifter, but a bit complex
```
This seems like an interesting alternative way to anaylse the proteins! For example 41_HUMAN is now identified as RBP, which was not the case in previous methods, and accoriding to RDeep it is really an RBP! So lets see what we do with this information.

Additional shifter count:
```{r}
sum(shifting_quotients$"Curve_shifters" == "shifter")
```
This is A LOT OF SHIFTERS, even more than in the local shifter! Maybe we still have to adjust the threshold.

Alternative method to determine shifters via z-test (t test doesnt work bc in some rows the values do not vary enough). The z-test is a statistical test that compares a sample mean to a population mean, assuming a known standard deviation. It identifies values that significantly deviate from the expected value based on the given confidence interval.
```{r}
# Create a function to perform z-test for each value
perform_z_test <- function(value) {
  z_score <- (value - 1) / sd_value  # Calculate the z-score
  
  if (abs(z_score) > #1.96) {  # Assuming 95% confidence interval. If the absolute value of the z-score is greater than 1.96, it indicates that the value significantly differs from the expectation value.
                    1.645) {  # Assuming 90% confidence interval. The bigger the confidence interval, the more proteins are identified as shifters.
    return("shifter")
  } else {
    return("no shifter")
  }
}

# Calculate the standard deviation across the entire dataframe
sd_value <- sd(as.matrix(curve_quotients)) #shifter abhängig auch von der sd, hier über den gesamten Datensatz eine sd von 0.361562, je kleiner, desto näher nimmt man an sind die Werte aneinander, je größer, desto weiter entfernt.

# Apply the z-test function to each value in the dataframe
quotients_using_z <- apply(curve_quotients, 1, function(row) {
  result <- sapply(row, perform_z_test)
  if ("shifter" %in% result) {
    return("shifter")
  } else {
    return("no shifter")
  }
})

quotients_using_z <- data.frame(quotients_using_z)
colnames(quotients_using_z) <- "Result"
```

```{r}
# Print the count of "shifter" values
table(quotients_using_z$Result)["shifter"]
```
Interesting. Wierdly some different shifting proteins (and a lot less) were identified (need for further anaylsis or comparison with known RBPs). For example 5NT3A_HUMAN	is identified as a shifter here, but not in the first two methods. RDeep says it is a shifter though. not that bad so maybe?

Für Alexandra/k-means analyse: jedes Protein mit maximalen und minimalen Wert? Vllt bringt es was, nicht sicher wie die Daten aussehen müssen damit du k-means anwenden kannst.
```{r}
# Calculate the minimum and maximum values for each row in curve_quotients
quotients_minmax <- data.frame("Min" = apply(curve_quotients, 1, min), "Max" = apply(curve_quotients, 1, max), row.names = row.names(curve_quotients))

# Print the quotients_minmax dataframe
print(quotients_minmax)
```
Interesting observation: Here we can see some proteins have 1 as the min and the max value, meaning that after normalization, the graphs are identical and the proteins most definitly not shifters.


#### 4.4 y-shift

Verkürzter y-shift code (Update: wurde jetzt korrigiert, sollte funktionieren)
```{r}

# Function to calculate difference in y-values between global maxima
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
  # Select the specific row from both dataframes
  row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
  row_data_RNase <- Mitosis_RNase_mean[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_diff <- row_global_max_Ctrl - row_global_max_RNase

  # Return the difference in y-values
  return(y_diff)
}

# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)

# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDiff = results)

# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference 

#as.vector(results_yshift) #results as vector - maybe better to work with afterwards, if needed
```

## 5. Statistical analysis
### 5.1 kmeans
##### 5.1.1 For maxima

Trying to create three cluster: left-shift, right-shift (possibly RBP); no shift (no RBP). Here only goes for data generate from difference between the max-shifts

```{r}
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")


#find the optimal amount of cluster before k-means
library(cluster)
library(ggplot2)
library(factoextra)

#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6 


#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)

#visualizing the result of kmeans
fviz_cluster(km, data = maximum_fraction)

# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)

# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data1, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
  geom_point() +
  labs(title = "K-means Clustering for maxima",
       x = "Ctrl_fraction_max",
       y = "RNase_fraction_max",
       color = "Cluster")

plot(dotplot1)
```

The same kmeans clustering again for the 3 cluster that we expected to see. We hope for a cluster of no-shift, left-shift and right-shift -> not successful

```{r}
#kmeans with same data but 3 cluster
km3 <- kmeans(maximum_fraction, centers = 3, nstart = 25)
#fviz_cluster(km3, data = maximum_fraction)

# Create a data frame with clustered data and cluster labels
clustered_data2 <- data.frame(maximum_fraction, cluster = as.factor(km3$cluster))
show(clustered_data2)

# Create a scatter plot using ggplot
dotplot2 <- ggplot(clustered_data2, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
  geom_point() +
  labs(title = "K-means Clustering for maxima",
       x = "Ctrl_fraction_max",
       y = "RNase_fraction_max",
       color = "Cluster")

plot(dotplot2)
```

##### 5.1.2 For quotients

Since we are unsure how well kmeans worked for the maxima-clustering we now do the same clustering for quotients_minmax

```{r}
#here we don´t need to generate a new dataframe since we already have one we can work with
show(quotients_minmax)

#Calculate optimal number of cluster
fviz_nbclust(quotients_minmax, kmeans, method='silhouette') #optimal number of cluster = 2

#then a k-means clustering with the optimal amount of cluster and interpretation
km_q <- kmeans(quotients_minmax, centers = 2, nstart = 25, algorithm = "MacQueen")

#visualizing the result of kmeans
km_q
#fviz_cluster(km_q, data = quotients_minmax)

# Create a data frame with clustered data and cluster labels
clustered_data3 <- data.frame(quotients_minmax, cluster = as.factor(km_q$cluster))
show(clustered_data3)

# Create a scatter plot using ggplot
dotplot3 <- ggplot(clustered_data3, aes(x = Min, y = Max, color = cluster)) +
  geom_point() +
  labs(title = "K-means Clustering for quotients",
       x = "Min",
       y = "Max",
       color = "Cluster")

plot(dotplot3)
```
Das sieht auf jeden Fall schonmal anders aus. Aber besser?! -> vielleicht

Again for 3 clusters that we hoped for:
```{r}
km3_q <- kmeans(quotients_minmax, centers = 3, nstart = 25)
#fviz_cluster(km3_q, data = quotients_minmax)

# Create a data frame with clustered data and cluster labels
clustered_data4 <- data.frame(quotients_minmax, cluster = as.factor(km3_q$cluster))
show(clustered_data4)

# Create a scatter plot using ggplot
dotplot4 <- ggplot(clustered_data4, aes(x = Min, y = Max, color = cluster)) +
  geom_point() +
  labs(title = "K-means Clustering for quotients",
       x = "Min",
       y = "Max",
       color = "Cluster")

plot(dotplot4)
```
Finde ich besser als die kmeans plots für die Maxima. Aber wir sollten uns überlegen was aus "biologischer" Sicht hier logischer ist und das andere kmeans dann rausschmeissen.

#### 5.1.3. For y-shift
```{r}
#need to generate new dataframe
results_yshift2 <- data.frame(row_global_max_Ctrl, row_global_max_RNase)
show(results_yshift2) 

fviz_nbclust(results_yshift, kmeans, method='silhouette') #optimal number of cluster = 2

#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km_y <- kmeans(results_yshift, centers = 2, nstart = 25)
#fviz_cluster(km_y, data = results_yshift)

# Create a data frame with clustered data and cluster labels
clustered_data5 <- data.frame(results_yshift, cluster = as.factor(km_y$cluster))
show(clustered_data5)

# Create a scatter plot using ggplot
dotplot5 <- ggplot(clustered_data5, aes(x = row_global_max_Ctrl, y = row_global_max_RNase, color = cluster)) +
  geom_point() +
  labs(title = "K-means Clustering for y-shift",
       x = "row_data_Ctrl",
       y = "row_data_RNase",
       color = "Cluster")

plot(dotplot5)
```
For 3 cluster
```{r}
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km3_y <- kmeans(df_results_yshift, centers = 3, nstart = 25)
#fviz_cluster(km_y, data = df_results_yshift)

# Create a data frame with clustered data and cluster labels
clustered_data6 <- data.frame(df_results_yshift, cluster = as.factor(km3_y$cluster))
show(clustered_data6)

# Create a scatter plot using ggplot
dotplot6 <- ggplot(clustered_data6, aes(x = GlobalMax_Ctrl, y = GlobalMax_RNase, color = cluster)) +
  geom_point() +
  labs(title = "K-means Clustering for y-shift",
       x = "GlobalMax_Ctrl",
       y = "GlobalMax_RNase",
       color = "Cluster")

plot(dotplot6)
```
###### 5.1.3.1 Description of cluster 2

Lets take a closter look at cluster 3, as those proteins seem to be "extrem y-shifters"
```{r}
# Extract the cluster assignments from the kmeans_result object
cluster_assignments <- km3_y$cluster

# Filter the dataframe based on the cluster assignment
cluster2_values <- df_results_yshift[cluster_assignments == 2, ]

# Print the values in Cluster 2
print(cluster2_values)

# Count the number of values in Cluster 2
num_cluster2_values <- nrow(cluster2_values)

# Print the count
print(num_cluster2_values)
```
So we have 73 "extrem y-shifters". Lets take a look at them

```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 4269     # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein

# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,40), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```



## 6. Linear Regression
Idee: columns nach jeder unserer Methoden (4?) und wir finden so sozusagen die beiden Methoden die in größer Übereinstimmung RBPs bestimmt haben und wenden dann auf die LR an
Ich denke das wäre bei uns ziemlich cool, eben weil wir diese verschiedenen Methoden haben

#### 6.1 generate Dataframe

##### 6.1.1 prepare data
In order to generate one big dataframe that sums up the values that we gained in our 4(?) methodes of RBP identification this data has to be brought into the right format

1. Größe des x-shift: max_shift <- Ctrl_fraction_max - RNase_fraction_max
2. Unterschied in Anzahl local maxima: identical_fractions2$local_shift (ggf problematisch da hier eine verschiebung der local maxima ignoriert wird)
3. Ausmaß des y-shift: results_yshift$YDiff

ggf. 4. column: maximaler/minimaler Kurven quotient?? Vereinfachend den max wert genommen, da dieser in erster Linie größer und somit ggf aussagekräftiger ist.


```{r}
max_shift <- Ctrl_fraction_max - RNase_fraction_max

# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
                               local_shift = identical_fractions2$local_shift,
                               YDiff = results_yshift$YDiff,
                               curve_shift = quotients_minmax$Max,
                               row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"

# Print the shift_comparison dataframe
print(shift_comparison)

```

#### 6.2 identify two columns with a linear relationship

```{r}
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""

# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
  for (j in (i + 1):ncol(shift_comparison)) {
    # Extract the two columns
    col1 <- shift_comparison[, i]
    col2 <- shift_comparison[, j]
    
    # Calculate the Pearson correlation coefficient
    correlation <- cor(col1, col2, use = "pairwise.complete.obs")
    
    # Check if the correlation is stronger than the previous best
    if (abs(correlation) > abs(best_correlation)) {
      best_correlation <- correlation
      best_col1_name <- names(shift_comparison)[i]
      best_col2_name <- names(shift_comparison)[j]
    }
  }
}

# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
```

Egal ob man den Maximalen Wert des Kurven Quotienten Codes nimmt oder den minimalen, in beiden Fällen wird die höchste Korrelation zwischen dem curve_shift daten und den max_shift daten gefunden!

#### 6.3 perform a linear regression

```{r}
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])


# Print the regression summary
summary(model)

summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234

library(ggplot2)

# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])

# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
```

Mhm. Sieht noch ziemlich sketchy aus, aber es ist ein erstes Ergebnis. 

