---
title: "Topic 3: Proteome-wide Screen for RNA-dependent Proteins; Subtopic 3: HeLa synchronized in Mitosis"
author: "Jimena, Alexandra, Verena"
date: "2023-05-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Topic 3.3: HeLa Cells Synchronized in Mitosis

### Proteome-wide Screen for RNA-dependent Proteins

Load the dataset from the Dropbox

```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")
head(RDeeP_HeLa_Mitosis)
```

## 1. Preparing data for analysis (Data Cleanup)

#### 1.1 Data description

```{r}
dim(RDeeP_HeLa_Mitosis)
head(rownames(RDeeP_HeLa_Mitosis))
head(colnames(RDeeP_HeLa_Mitosis))
```

#### 1.2 Finding rows with missing values

Finding which rows are all 0 (and are most likely experimental errors). And removing this rows.

```{r}
which(rowSums(RDeeP_HeLa_Mitosis)==0)

print(RDeeP_HeLa_Mitosis["KLD10_HUMAN",])

RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),] #Habe hier das letzte Komma hinzugefügt und das = in ein <- geändert.
#Tabelle ohne die Nullzeile wieder in der Variable gespeichert

#We might have to repeat this later, for when we have separated Control and RNase, as the same argumentation applies if already only one of them only has zeros.
#which(rowSums(RDeeP_HeLa_Mitosis_Ctrl)==0)
#which(rowSums(RDeeP_HeLa_Mitosis_RNase)==0) #Careful, that we have to delete the the zero rows of RNase also in the Control Dataframe


dim(RDeeP_HeLa_Mitosis)
```

#### 1.3 Handeling other wierd rows

When looking at the dataset we noticed that already the first 7 rows have accumulation of protein in every fraction. We are not sure if we can work with them as they maybe have no clear peak, therefore we first identify them and then maybe delete them later.

```{r}
# Find rows without any zeros
nonzero_rows <- RDeeP_HeLa_Mitosis[rowSums(RDeeP_HeLa_Mitosis == 0) == 0, ]

#The condition rowSums(RDeep_Hela_Mitosis == 0) == 0 checks which rows have a sum of zeros equal to zero, indicating that those rows do *not* contain any zeros.Then we selects these rows without any zeros from our table and store it in a new table.

# Print the rows without any zeros: print(nonzero_rows)
nrow(nonzero_rows) #320 rows do not have zeros


#Possibly deleting these nonzero rows and storing it in the original matrix:
#RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[rowSums(RDeeP_HeLa_Mitosis == 0) > 0, ]

```

#### 1.4 Check data format

Here we try to determine data type of our dataset, whether it is numerical, categorical, etc

```{r}

nrow(RDeeP_HeLa_Mitosis)
ncol(RDeeP_HeLa_Mitosis)
sum(apply(RDeeP_HeLa_Mitosis, 1, is.na)) # Summe aller Spalten, die NA Werte haben
sum(apply(RDeeP_HeLa_Mitosis, 2, is.na)) # Summe aller Zeilen, die NA Werte haben
sum(apply(RDeeP_HeLa_Mitosis, 1, is.numeric))
sum(apply(RDeeP_HeLa_Mitosis, 2, is.numeric))

sum(apply(RDeeP_HeLa_Mitosis, 1, is.numeric)) == nrow(RDeeP_HeLa_Mitosis)

```

This means we have numeric data, aka the data from the mass spectrometry.

```{r}
#Complete DataSet
#View(RDeeP_HeLa_Mitosis)
```

#### 1.5 Checking reproducibility with student t-test

The first step would be to perform a student t-test on the first three values in our table, so for example protein 1, Control Fraction 1 the rep1, rep2, rep3

```{r}
# Extract the first three values from the table
protein1_Ctrl_frac1 <- RDeeP_HeLa_Mitosis[1, 1:3] #Zeile 1, Spalten eins bis drei

# Perform the t-test
print(t.test(protein1_Ctrl_frac1))

#beide schritte kann man theoretisch auch noch in einem vereinigen.
```

Here our p-value is over 5%, thus we can determine the reproducibility of the experiment is not given and we would have to delete the entire protein. How much sense this makes we will see later.

Now the same for protein 8

```{r}
# Extract the first three values from the table
protein8_Ctrl_frac1 <- RDeeP_HeLa_Mitosis[8, 1:3]

# Perform the t-test
print(t.test(protein8_Ctrl_frac1))
```

Here all three repetitions were 0, thus making our p-value not determinable. This is normal and we would have to repeat this for all fractions and then check if there are any p-values in the entire protein above 5%. If not, we can confidently confirm the reproducibility.

Here an attempt to generalize the code for all fractions for one Protein (Control and RNAse separate)

```{r}
#easiest way is to separately define the columns we want to put into the new data frame

RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])

#For RNase it is easier, because we now can just take all the row which were not taken in the first table. 
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]

head(RDeeP_HeLa_Mitosis_RNase)
```

Now in the next step we try to apply a student t-test on every three values, and then finding the maxima of all these p-values. Here is efficient solution, using the power of vectorization in R.

```{r}
# Calculate the number of sets in the Control Dataset
num_sets <- ncol(RDeeP_HeLa_Mitosis_Ctrl) %/% 3
print(num_sets) #25 - number of fractions

# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))
print(p_values_Ctrl)

# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
  # Extract the values for the current set of three columns
  column_values <- RDeeP_HeLa_Mitosis_Ctrl[, i:(i + 2)]
  
  # Calculate the p-values for the set of three columns using t-tests
  p_values <- apply(column_values, 1, function(x) {
    if (length(unique(x)) > 1) {
      t_result <- t.test(x)
      t_result$p.value
    } else {
      0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
    }
  })
  
  # Assign the p-values to the corresponding column in the new dataframe
  p_values_Ctrl[, (i %/% 3 + 1)] <- p_values
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_Ctrl) <- rownames(RDeeP_HeLa_Mitosis_Ctrl)

# Print the new dataframe
print(p_values_Ctrl)
```

Finding the maximum value for each row, then deciding if it is smaller than our significance level (either 5% or 10%, has to be decided beforehand)

```{r}
# Replace NA values with zero in p_values_Ctrl dataframe
# p_values_Ctrl[is.na(p_values_Ctrl)] <- 0

# Create a new dataframe to store the maximum values
max_values_Ctrl <- data.frame(MaxValue = apply(p_values_Ctrl[, -1], 1, max))

# Adding the protein names to the new dataframe:
rownames(max_values_Ctrl) <- rownames(p_values_Ctrl)

# Print the new dataframe
print(max_values_Ctrl)
```

We still have to determine which p-values are over 10% and use that information on the dataframe. But now first all the same for the RNase:

```{r}
# Calculate the number of sets in the RNase dataset
num_sets <- ncol(RDeeP_HeLa_Mitosis_RNase) %/% 3

# Create an empty dataframe to store the p-values
p_values_RNase <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_RNase)))

# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_RNase), by = 3)) {
  # Extract the values for the current set of three columns
  column_values <- RDeeP_HeLa_Mitosis_RNase[, i:(i + 2)]
  
  # Calculate the p-values for the set of three columns using t-tests
  p_values <- apply(column_values, 1, function(x) {
    if (length(unique(x)) > 1) {
      t_result <- t.test(x)
      t_result$p.value
    } else {
      0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
    }
  })
  
  # Assign the p-values to the corresponding column in the new dataframe
  p_values_RNase[, (i %/% 3 + 1)] <- p_values
}

# Optional: Rename the columns
colnames(p_values_RNase) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_RNase) <- rownames(RDeeP_HeLa_Mitosis_RNase)

# Print the new dataframe
print(p_values_RNase)
```

```{r}
# Finding the maximum
# Create a new dataframe to store the maximum values
max_values_RNase <- data.frame(MaxValue = apply(p_values_RNase[, -1], 1, max))

# Adding the protein names to the new dataframe:
rownames(max_values_RNase) <- rownames(p_values_RNase)

# Print the new dataframe
print(max_values_RNase)

#Testing how many RNase values we have above 5%/10%:
sum(max_values_RNase > 0.05)
sum(max_values_RNase > 0.1)
#For control
sum(max_values_Ctrl > 0.05)
sum(max_values_Ctrl > 0.1)
# --> RNase has a lot more fluctiation in comparison to Control!

#Alternative ways to calculate the above
#length(which(max_values_RNase > 0.1))
#length(max_values_RNase[max_values_RNase$MaxValue > 0.1, ])
```

Whoops, that is A LOT! Sometimes that is more than half (or more than a quarter) of our data...

Now adding the columns to the main dataframe and doing the same, identify the rows in which the p-value exceeds 10%:

```{r}
RDeeP_HeLa_Mitosis_p <- data.frame(RDeeP_HeLa_Mitosis, max_values_Ctrl, max_values_RNase) 

# Identify all rows where the value in _one_ of the last two columns exceeds 5% or 10%

bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 | RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
bad_proteins10 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.1 | RDeeP_HeLa_Mitosis_p[, 152] > 0.1)

#When using the logical OR (|) operator, if either condition is true, the result will be true. 


#Rows in which both Control and RNase p-values exceed 5%:
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 & RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
#length(bad_proteins5)

#Alternative 5%/10% BUT THIS RESULTS IN ANTOHER VALUE, WHY? I DO NOT KNOW.
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.05)
bad_proteins10wierd <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.1)

length(bad_proteins5)
length(bad_proteins10)
length(bad_proteins10wierd)
```

Anywayyyy, let's work with the 10 % margin and delete all corresponding rows.

```{r}
RDeeP_HeLa_Mitosis_clean <- RDeeP_HeLa_Mitosis_p[!(RDeeP_HeLa_Mitosis_p[, 151] > 0.1 | RDeeP_HeLa_Mitosis_p[, 152] > 0.1), ] #the ! Operator negate the condition.It excludes rows where the condition is TRUE, thus effectively filtering out rows that exceed 10%.

# Remove the last two columns
RDeeP_HeLa_Mitosis_clean <- RDeeP_HeLa_Mitosis_clean[, 1:(ncol(RDeeP_HeLa_Mitosis_clean) - 2)]

#Print the new dataframe
print(RDeeP_HeLa_Mitosis_clean)
```

```{r}
#Now we have to again separate our clean dataframe into Control and RNase

Mitosis_Ctrl_clean = cbind(RDeeP_HeLa_Mitosis_clean[,1:3],RDeeP_HeLa_Mitosis_clean[,7:9],RDeeP_HeLa_Mitosis_clean[,13:15],RDeeP_HeLa_Mitosis_clean[,19:21],RDeeP_HeLa_Mitosis_clean[,25:27],RDeeP_HeLa_Mitosis_clean[,31:33],RDeeP_HeLa_Mitosis_clean[,37:39],RDeeP_HeLa_Mitosis_clean[,43:45],RDeeP_HeLa_Mitosis_clean[,49:51],RDeeP_HeLa_Mitosis_clean[,55:57],RDeeP_HeLa_Mitosis_clean[,61:63],RDeeP_HeLa_Mitosis_clean[,67:69],RDeeP_HeLa_Mitosis_clean[,73:75],RDeeP_HeLa_Mitosis_clean[,79:81],RDeeP_HeLa_Mitosis_clean[,85:87],RDeeP_HeLa_Mitosis_clean[,91:93],RDeeP_HeLa_Mitosis_clean[,97:99],RDeeP_HeLa_Mitosis_clean[,103:105],RDeeP_HeLa_Mitosis_clean[,109:111],RDeeP_HeLa_Mitosis_clean[,115:117],RDeeP_HeLa_Mitosis_clean[,121:123],RDeeP_HeLa_Mitosis_clean[,127:129],RDeeP_HeLa_Mitosis_clean[,133:135],RDeeP_HeLa_Mitosis_clean[,139:141],RDeeP_HeLa_Mitosis_clean[,145:147])

#For RNase
Mitosis_RNase_clean=RDeeP_HeLa_Mitosis_clean[,-which(names(RDeeP_HeLa_Mitosis_clean) %in% colnames(Mitosis_Ctrl_clean))]

#additional cleanup: deleting all rows in RNase and Ctrl which are zero, removing these rows from the entire clean dataframe
which(rowSums(Mitosis_Ctrl_clean)==0)
which(rowSums(Mitosis_RNase_clean)==0) 
# Removing BT2A3_HUMAN SEPP1_HUMAN from each dataframe and saving in in the same variable again:
Mitosis_Ctrl_clean <- Mitosis_Ctrl_clean[!(rownames(Mitosis_Ctrl_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
Mitosis_RNase_clean <- Mitosis_RNase_clean[!(rownames(Mitosis_RNase_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
```

#### 1.6 Checking reproducibility with correlation?

-\> NOT RELEVANT IF T-TEST WORKS... was aber noch in den Sternen steht.

Testing the correlation for the first three entries in our Control dataset. A possible idea is to apply this all on the entire dataset again, and then for example sort out all proteins in which the correlation between the fractions is less than 95%. This will then guarantee that all remaining fractions have a high correlation and thus a high reproducibility. But there is still a lot to do!

```{r}
# Calculate the pairwise correlations between the first three columns
cor_matrix_frac1 <- cor(RDeeP_HeLa_Mitosis_Ctrl[, 1:3], method = "pearson")

# Visualize the correlation matrix using a heatmap
heatmap(cor_matrix_frac1,
        col = colorRampPalette(c("blue", "white", "red"))(100),
        main = "Correlation Heatmap")

#Printing the correlation matrix as data frame
print(as.data.frame(cor_matrix_frac1))
```

## 2. Data scaling

#### 2.1 Finding mean

After we have removed all rows with low reproducibility, we can then move on to scale all remaining data to 100. This makes the most sense if we first take the mean value of all replicates and then scale them.

```{r Finding mean}
#First finding the mean of all three replicates for every fraction separately in our Mitosis_Ctrl_clean data:
Mitosis_Ctrl_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
    apply(Mitosis_Ctrl_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    #inner loop which calculates the mean for the three replicates, for each row anew. and CAUTION: if we delete some rows, we might have to adjust the name of the dataframe.
    
    }))

#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")

head(Mitosis_Ctrl_mean)
```

#### 2.2 Data scaling to 100

Now trying data scaling to 100:

```{r scaling Ctrl to 100}
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))

head(Mitosis_Ctrl_100)

```

Seems to work? Now all the same for RNase:

```{r}
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(Mitosis_RNase_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    }))

colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")

#Now scaling 
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))

head(Mitosis_RNase_100)
```

#### 2.3 Min Max scaling

This would be an alternative to the data scaling to 100 method. We rescale the values to a fixed range, typically between 0 and 1. The scaling process involves subtracting the minimum value from each value in the variable and then dividing by the range (maximum value minus the minimum value). This transformation ensures that all values are proportionally scaled within the specified range.

```{r Min Max scaling}
# Min-max scaling function
min_max_scaling <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column). 

#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling)) 

# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
```

We can later decide which method to chose.

```{r Clean environment}
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values,protein1_Ctrl_frac1,protein8_Ctrl_frac1,bad_proteins5)
```

## 3. Finding global/local maxima

<<<<<<< Updated upstream
## 3.1 Specific visualization of proteins
=======
#### Attempt no.1

This code allows us to identify all rows with multiple peaks

```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks) #this is already a vector
rows_with_multiple_peaks


#rows_with_multiple_peaks_df <- data.frame(Row_Name = rownames(Mitosis_Ctrl_100), value = rows_with_multiple_peaks) 

#rows_with_multiple_peaks_df
#rownames(Mitosis_Ctrl_100 %in% rows_with_multiple_peaks)
```

Rows with just one peak still does not want to cooperate :l

```{r}
# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  # Extract the row
  row <- Mitosis_Ctrl_100[row_index, ]
  
  # Find the global maximum in the row
  global_max <- max(row)
  
  # Check if the row has only one peak
  has_one_peak <- sum(row == global_max) == 1 && all(diff(row) < 0)
  
  # Print the result for the current row
  print(paste("Row", row_index, "has one peak:", has_one_peak))
}



```

still does not cooperte

```{r}
# Create an empty list to store results
maxima_results <- list()

# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  row <- Mitosis_Ctrl_100[row_index, ]
  
  # Find the maximum value in the row
  max_value <- max(row)
  
  # Find the indices of maxima in the row
  max_indices <- which(row == max_value)
  
  # Check if each maximum is a global or local maximum
  max_types <- c()
  for (i in max_indices) {
    if (i > 1 && i < length(row)) {
      if (row[i] > row[i-1] && row[i] > row[i+1]) {
        max_types <- append(max_types, "Local")
      } else {
        max_types <- append(max_types, "Global")
      }
    } else {
      max_types <- append(max_types, "Global")
    }
  }
  
  # Store the results in the list
  maxima_results[[row_index]] <- data.frame(MaximaValue = row[max_indices], MaximaIndex = max_indices, MaximaType = max_types)
}

# Print the results
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  print(paste("Row", row_index, "Maxima:"))
  print(maxima_results[[row_index]])
}


```

## 3.2 Specific visualization of proteins

>>>>>>> Stashed changes
This code helps us visualize one specific protein

```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein

# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

<<<<<<< Updated upstream
View a protein and its peak using the protein name
=======
Nooww, a similar code, but plots the graph using the name of the protein and not just its index in the dataframe -\> Does basically the same as the previous code, but its cool to plot just using the protein name hehe

>>>>>>> Stashed changes
```{r}
# Step 1: Select a specific row by name
row_name <- "2A5E_HUMAN"

# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

## 4. Shift one peak proteins
