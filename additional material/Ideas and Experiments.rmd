---
title: "Ideas and Experiments"
author: "Orrego Chong, Kantelhardt, Kornelius"
date: "2023-05-23"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")

head(RDeeP_HeLa_Mitosis)
```
```{r}
#Deleting the complete zero rows:
RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),]
```


### Student t-test 

```{r}
# Extract the first three values from the column
subset_values <- RDeeP_HeLa_Mitosis[1, 1:3]

# Perform the t-test
t_test_result <- t.test(subset_values)

# Print the t-test result
print(t_test_result)
```
### Reorder dataset

```{r}
RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])

#For RNase it is easier, because we now can just take all the row which were not taken in the first table. 
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]

head(RDeeP_HeLa_Mitosis_RNase)
```


## 2. Scale and Reduce Dataset

#### 2.1 Normalization (scaling, or z-transformation?)

Old complicated version for finding mean:

1. Create an empty dataframe to store the mean values
mean_values <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

2.Outer loop: Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Inner loop: Iterate over every three columns at a time
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Select the three columns for the current iteration
    selected_columns <- RDeeP_HeLa_Mitosis_Ctrl[i, j:(j + 2)]
    # Calculate the mean of the selected columns
    mean_value <- mean(selected_columns, na.rm = TRUE)
    # Assign the mean value to the corresponding cell in the mean_values dataframe
    mean_values[i, (j + 2) %/% 3] <- mean_value
  }
}

NEW VERSION:

```{r}
#First finding the mean of all three replicates for every fraction separately:
Mitosis_Ctrl_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
    apply(RDeeP_HeLa_Mitosis_Ctrl[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    #inner loop which calculates the mean for the three replicates, for each row anew. 
    
    }))

#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")

print(Mitosis_Ctrl_mean)
```

Now trying data scaling to 100:
```{r}
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))

head(Mitosis_Ctrl_100)

```
Seems to work? Now all the same for RNase:

```{r}
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(RDeeP_HeLa_Mitosis_RNase[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    }))

colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")


#Now scaling 
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))

head(Mitosis_RNase_100)

```


```{r}
#Then maybe applying the z transformation on each row was a whole, Control and RNase separate? Still needs a lot of refining...
#Mitosis_Ctrl_norm <- apply(t(Mitosis_Ctrl_mean),1, function(x)(x - mean(x)) / sd(x))

#transpose is necessary as "apply" is always iterates the command or each column 

head(Mitosis_Ctrl_mean)
```


Min Max scaling?
We rescale the values to a fixed range, typically between 0 and 1. The scaling process involves subtracting the minimum value from each value in the variable and then dividing by the range (maximum value minus the minimum value). This transformation ensures that all values are proportionally scaled within the specified range.


```{r}
# Min-max scaling function
min_max_scaling <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column). 

# Print the scaled data
View(Mitosis_Ctrl_MM)
```

We can later decide which method to chose. 


### Plot visulization ideas


##### Without Normalization
```{r}
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="SIN3B_HUMAN", ylim=c(0,180000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

```{r}
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("CASP7_HUMAN")),],type="l",lwd=2,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN pre normalization",ylim=c(0,1400000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("CASP7_HUMAN")),], type="l",lwd=2,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

##### With Normailzation (scaling to 100)

Also added ylim
```{r}
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="SIN3B_HUMAN Normalized", ylim=c(0,80))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

```{r}
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("CASP7_HUMAN")),],type="l",lwd=2,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="CASP7_HUMAN 100 normalized", ylim=c(0,40))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("CASP7_HUMAN")),], type="l",lwd=2,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```
With this last plot we already see a potential problem, as Control and RNase seem to be identical after scaling? Confusion

##### With Normalization (min max scaling) 

```{r}
plot(1:25, Mitosis_Ctrl_MM[which(rownames(Mitosis_Ctrl_MM)==c("CASP7_HUMAN")),],type="l",lwd=2,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN MinMax normalized",ylim=c(0,1))
lines(1:25, Mitosis_RNase_MM[which(rownames(Mitosis_RNase_MM)==c("CASP7_HUMAN")),], type="l",lwd=2,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```


#### PEAK ANALYSIS OLD

```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_mean)) {
  row_data <- Mitosis_Ctrl_mean[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks)
```

PROTEINS WITH A LOT OF PEAKS? AKA MORE THAN SEVEN
```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_mean)) {
  row_data <- Mitosis_Ctrl_mean[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {  #More than 1 peak, can be adjusted to different thresholds!
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks)
#rows_with_multiple_peaks
```


This code allows us to identify all rows with ONE peak each
```{r}
# Step 1: Create an empty vector to store the row indices with one peak
rows_with_one_peak <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {   #why here with MitosisCtrl100 and above with MitosisCtrlMean?? Should it not be the same for comparison?
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has only one peak
  if (length(peaks) == 1) {
    rows_with_one_peak <- c(rows_with_one_peak, row_index)
  }
}

# Step 5: Print the row indices with only one peak
length(rows_with_one_peak)  # Number of rows with one peak
#rows_with_one_peak  # Row indices with one peak
#head(rows_with_one_peak)

# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) == nrow(Mitosis_Ctrl_100) #FALSE, not all proteins have one peak or mulitple peaks
length(rows_with_multiple_peaks) + length(rows_with_one_peak)
nrow(Mitosis_Ctrl_100) #some proteins have not yet been identified

```
Mhmm, it is FALSE, so maybe:
This code allows us to indentify all rows without a peak:
```{r}
# Step 1: Create an empty vector to store the row indices with no peak
rows_with_no_peak <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) { #Ich habe das gleiche auch mit dem nicht "clean" dataframe durchgeführt, da waren es 100 Proteine, hier sind es jetzt 82. Also 18 davon hatten wir schon im Data cleanup gelöscht. 
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) { 
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has no peak
  if (length(peaks) == 0) {
    rows_with_no_peak <- c(rows_with_no_peak, row_index)
  }
}

# Step 5: Print the row indices with no peak
length(rows_with_no_peak)  # Number of rows with no peak #84
#what are rows with no peaks? Theoretically we already cleaned up the dataframe, should it not be free of 0 rows? #what does it mean (for our data) that the protein accumulates in the first/last fraction

# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) + length(rows_with_no_peak) == nrow(Mitosis_Ctrl_100)

```
YAY! Now it works!

Testing if all no peak proteins have their highest value in the first fraction:

```{r}
# Test maximum value is in the last fraction (column), this means the protein accumulated at the bottom
has_max_in_last_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
  max_index <- which.max(row)
  max_index == ncol(Mitosis_Ctrl_100)
})

# Test if maximum value is in the first fraction, protein accumulated and the top
has_max_in_first_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
  max_index <- which.max(row)
  max_index == 1
})

# Check if has_max_in_last_col and has_max_in_first_col are complementary
are_complementary <- all(has_max_in_last_col != has_max_in_first_col)
are_complementary #TRUE means the protein has accumulated in the last column
```

TRUE, this means all proteins without a peak have either accumulated in first or last fraction.
-> does it mean error? or normalization side effect? No.

## 2. y- shifts

Detection of y-shifts aka difference between global max in Ctrl und global max in RNase.
We observe the changes of peaks in the Ctrl Dataframe (here Mitosis_mean) after the addition of RNase and thats why we calculate the shifts as: Ctrl - RNase
If the result is:
'=' 0: no shift 
'>' 0: (positive number) Ctrl peak is higher than RNase peak -> Down shift as Ctrl goes 'down' to RNase
'<' 0: (negative number) Ctrl peak is lower than RNase peak -> Up shift as Ctrl goes 'up' to RNase
New: addition of range of RBP detection, if y_max_RNase deviates 20% up or down from y_max_Ctrl → no RBP
deviation more than 20% up or down → RBP
```{r}
#Mitosis_Ctrl_clean
#Mitosis_Ctrl_mean 

# Row name for the desired row in both dataframes
row_name <- "2A5E_HUMAN"  # Replace with the desired row name aka protein

# Select the specific row from both dataframes
row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
row_data_RNase <- Mitosis_RNase_mean[row_name, ]

# Find the global maximum from the selected row in Ctrl
row_global_max_Ctrl <- max(row_data_Ctrl)

# Find the global maximum from the selected row in RNase
row_global_max_RNase <- max(row_data_RNase)

# Calculate the difference in y-values between the global maxima
y_diff <- row_global_max_Ctrl - row_global_max_RNase

#Threshold part probably needs proof-reading:
?#Calculate RBP threshold (20% deviation from Ctrl Max)
lower_bound <- row_global_max_Ctrl*0.8
upper_bound <- row_global_max_Ctrl*1.2

range <- c(lower_bound, upper_bound) 

# Identify RBP if RNase max lays in 20% range from Ctrl max  
if (row_global_max_RNase >= lower_bound && row_global_max_RNase <= upper_bound) {
  print("Non RBP")
} else {
  print("RBP")
}

# Print non RBP range
print(range) #range of RBP: 20% less - 20% more than Ctrl max

# Print the global maximums and the difference in y-values
print(row_global_max_Ctrl) #max y Wert von Ctrl
print(row_global_max_RNase) #max y Wert von RNase
print(y_diff) # Ctrl - RNase

if(y_diff > 0) {print("Down shift")}
if(y_diff < 0) {print("Up shift")}
if(y_diff == 0) {print("No shift")}
```


Overview of RBP and non RBPs using 20% threshold in the y-shift recognition method
Dataframe tells us if certain protein is RBP or not
Es wurden 2172 RBPs mit den 20% threshold in y-shifters bestimmt
```{r}
# Function to calculate difference in y-values between global maxima

calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
  row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
  row_data_RNase <- Mitosis_RNase_mean[row_name, ]

  row_global_max_Ctrl <- max(row_data_Ctrl)
  row_global_max_RNase <- max(row_data_RNase)

  lower_bound <- row_global_max_Ctrl * 0.8
  upper_bound <- row_global_max_Ctrl * 1.2
  
  y_rbp <- if (row_global_max_RNase >= lower_bound && row_global_max_RNase <= upper_bound) {
    "Non RBP"
  } else {
    "RBP"
  }

  return(y_rbp)
}

row_names <- rownames(Mitosis_Ctrl_mean)
results <- sapply(row_names, calculate_maxima_diff)
results_yrbp <- data.frame(ProteinType = results)

# Print the final dataframe
results_yrbp #results as Dataframe - columns showing protein name and the difference 
sum(results_yrbp$ProteinType == 'RBP') #2172 RBPs

```

Not really necessary for us currently I think:

Overview of RBP and non RBPs using 20% threshold in the y-shift recognition method
But now: Dataframe shows us a value → how much the max in Ctrl and mac in RNase deviate (as far as I've compared it with the dataframe above, it should be right → values higher than 20 mean max deviate and are RBPs)

```{r}
# Function to calculate difference in y-values between global maxima #wo kommt die funktion her?
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
  # Select the specific row from both dataframes #which one?
  row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
  row_data_RNase <- Mitosis_RNase_mean[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_deviation <- abs((row_global_max_RNase - row_global_max_Ctrl) / row_global_max_Ctrl) * 100

  # Return the difference in y-values
  return(y_deviation)
}

# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)

# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDeviation = results)

# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference
```


Copied the 'protein web- search' to directly compare and see what our results of y-shifts mean
```{r}
# Step 1: Select a specific row by name
row_name <- "3BP5_HUMAN"

# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,70),xlim = c(0,7), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)

max(Mitosis_Ctrl_mean[row_name, ])
max(Mitosis_RNase_mean[row_name, ])

```


Reeeeaaally big overview for all proteins: their  global max in Ctrl aka in RNase and the difference of this max.
```{r}
# Function to calculate global maxima and difference in y-values
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {        
  
  # Select the specific row from both dataframes
  row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
  row_data_RNase <- Mitosis_RNase_100[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_diff <- row_global_max_Ctrl - row_global_max_RNase

  # Return row name, global maxima, and difference in y-values
  return(c( GlobalMax_Ctrl = row_global_max_Ctrl, GlobalMax_RNase = row_global_max_RNase, YDiff = y_diff))
}

# Get the row names of Mitosis Ctrl Dataframe
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name and combine the results into a dataframe
results <- mapply(calculate_maxima_diff, row_names, MoreArgs = list(Mitosis_Ctrl_100, Mitosis_RNase_100), SIMPLIFY = FALSE)
                    #list(df1 = df1, df2 = df2), SIMPLIFY = FALSE)

# Convert the results into a dataframe
results_yshift <- do.call(rbind, results)

# Print the results
head(results_yshift)

##Here we go from vector to matrix to dataframe
# Convert the vector to a matrix with desired number of columns
num_cols <- 3  # Number of columns in the matrix
my_matrix <- matrix(results_yshift, ncol = num_cols)

# Extract two columns from the matrix
column1 <- my_matrix[, 1]
column2 <- my_matrix[, 2]

#Convert the first two columns of the matrix into a dataframe that we can use in kmeans
df_results_yshift <- data.frame(GlobalMax_Ctrl  = column1, GlobalMax_RNase  = column2)
show(df_results_yshift)
```

Calculates y-shifts and shows (only) the difference between Ctrl peaks and RNase peaks
```{r}

# Function to calculate difference in y-values between global maxima
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
  # Select the specific row from both dataframes
  row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
  row_data_RNase <- Mitosis_RNase_mean[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_diff <- row_global_max_Ctrl - row_global_max_RNase

  # Return the difference in y-values
  return(y_diff)
}

# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)

# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDiff = results)

# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference 

as.vector(results_yshift) #results as vector - maybe better to work with afterwards, if needed

```


#### 2.1 Verenas anpassung

kleine optimizierungs-versuch (verena versucht ueberblick zu bekommen/sachen zu verstehen)

```{r}
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
  row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
  row_data_RNase <- Mitosis_RNase_100[row_name, ]

  row_global_max_Ctrl <- max(row_data_Ctrl)
  row_global_max_RNase <- max(row_data_RNase)

  lower_bound <- row_global_max_Ctrl * 0.8
  upper_bound <- row_global_max_Ctrl * 1.2
  
  y_rbp <- if (row_global_max_RNase >= lower_bound && row_global_max_RNase <= upper_bound) {
    "Non RBP"
  } else {
    "RBP"
  }

  return(y_rbp)
}

row_names <- rownames(Mitosis_Ctrl_100)
results <- sapply(row_names, calculate_maxima_diff, Mitosis_Ctrl_100, Mitosis_RNase_100)
results_yrbp <- data.frame(ProteinType = results)

# Print the final dataframe
results_yrbp
```


## 3. Update LOCAL MAXIMA!

#### 3.1 Visualizer

```{r}
# Step 1: Select a specific row by name
row_name <- "PELO_HUMAN" # "ABCA1_HUMAN" (precipitated protein, but still shifter) 'ABT1_HUMAN' (right shifter) #'ABCF1_HUMAN' (left shifter) #UTP11_HUMAN (percipitated non shifting protein?) #ehemals problematisch: SQOR_HUMAN #RBM3_HUMAN complicated but cool, # PHLB2_HUMAN SOSSC_HUMAN CURVE SHIFTER
#3HIDH_HUMAN und ABCB7_HUMAN Y SHIFTER

#WICHTIG: ABCA1_HUMAN... von welchem verfahren wird dies (wahrscheinlich korrekterweise) als shifter erkannt? Ist aber noch in keiner Datenbank drinnen...

# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,50), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
#main= paste(row_name, "no y shift", collapse = "")

lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)

# Step 5: Count the number of peaks
num_peaks_Ctrl <- length(peaks_Ctrl)
num_peaks_RNase <- length(peaks_RNase)

# Print the number of peaks
#cat("Number of peaks in Control:", num_peaks_Ctrl, "\n")
#cat("Number of peaks in RNase:", num_peaks_RNase, "\n")
```

#### 3.2 Alter code: SQOR_HUMAN Problem

TRUE: no shifter
FALSE: shifter

```{r}
# Step 1: Find column indices of local maxima in Mitosis_RNase_100
RNase_maxima <- apply(Mitosis_RNase_100, 1, function(row) {
  local_maxima <- which(row == max(row))
  return(local_maxima)
})

# Step 2: Create RNase_maxima dataframe with row names
RNase_maxima <- data.frame(Maxima = I(RNase_maxima), row.names = row.names(Mitosis_RNase_100))

# Step 3: Repeat the same process for Mitosis_Ctrl_100
Ctrl_maxima <- apply(Mitosis_Ctrl_100, 1, function(row) {
  local_maxima <- which(row == max(row))
  return(local_maxima)
})
Ctrl_maxima <- data.frame(Maxima = I(Ctrl_maxima), row.names = row.names(Mitosis_Ctrl_100))

# Step 4: Compare number of maxima and column indices between RNase_maxima and Ctrl_maxima
identical_fractions <- data.frame(no_shift = row.names(Mitosis_RNase_100), row.names = row.names(Mitosis_RNase_100), stringsAsFactors = FALSE)
identical_fractions$no_shift <- RNase_maxima$Maxima == Ctrl_maxima$Maxima & 
                             lengths(RNase_maxima$Maxima) == lengths(Ctrl_maxima$Maxima)

# Count the total number of maxima in RNase_maxima dataframe
rnase_maxima_count <- sum(lengths(RNase_maxima$Maxima))

# Count the total number of maxima in Ctrl_maxima dataframe
ctrl_maxima_count <- sum(lengths(Ctrl_maxima$Maxima))

# Check if the total number of maxima and column indices are identical
identical_fractions$no_shift <- identical_fractions$no_shift & rnase_maxima_count == ctrl_maxima_count
#DAS & IST HIER DER ENTSCHEIDENDE!

# Step 5: Print the identical_fractions dataframe
print(identical_fractions)

identical_fractions["SQOR_HUMAN",]
sum(identical_fractions$no_shift == FALSE)
```
#### 3.3 NEUER LOCAL MAX CODE -> schon rüberkopiert

Alles fertig ready für working code
```{r}
# Create an empty vector to store the results
results <- vector("logical", nrow(Mitosis_Ctrl_100))

# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
  # Get the row data for Ctrl and RNase
  row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
  row_data_RNase <- Mitosis_RNase_100[i, ]
  
  # Find the peaks in the row data for Ctrl
  peaks_Ctrl <- c()
  for (j in 2:(length(row_data_Ctrl) - 1)) {
    if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
      peaks_Ctrl <- c(peaks_Ctrl, j)
    }
  }
  
  # Find the peaks in the row data for RNase
  peaks_RNase <- c()
  for (j in 2:(length(row_data_RNase) - 1)) {
    if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
      peaks_RNase <- c(peaks_RNase, j)
    }
  }
  
  # Compare the peaks between Ctrl and RNase
  if (identical(peaks_Ctrl, peaks_RNase)) {
    results[i] <- TRUE
  } else {
    results[i] <- FALSE
  }
}

# Create a data frame with the results
result_df <- data.frame(identical_fractions = results, row.names = row.names(Mitosis_Ctrl_100))

# Print the result_df
print(result_df)

result_df["SQOR_HUMAN",] 
sum(result_df$identical_fractions == FALSE)
```

#### 3.4 LOCAL MAX CODE DER ANZAHL DES LOCAL SHIFTS IDENTIFIZIERT -> schon rüberkopiert

--> Hier wird jedoch nicht ein shift in den local maxima betrachtet, sondern nur ob mehr entstehen oder welche verschwinden zwischen Control und RNase. Dadurch werden ziemlich viele Proteine vernachlässigt, genauer gesagt 1570-900, also 670 Proteine werden dadurch nicht aufgeführt... Evt. später anpassen.

```{r}
# Create an empty vector to store the results
results <- vector("integer", nrow(Mitosis_Ctrl_100))

# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
  # Get the row data for Ctrl and RNase
  row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
  row_data_RNase <- Mitosis_RNase_100[i, ]
  
  # Find the peaks in the row data for Ctrl
  peaks_Ctrl <- c()
  for (j in 2:(length(row_data_Ctrl) - 1)) {
    if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
      peaks_Ctrl <- c(peaks_Ctrl, j)
    }
  }
  
  # Find the peaks in the row data for RNase
  peaks_RNase <- c()
  for (j in 2:(length(row_data_RNase) - 1)) {
    if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
      peaks_RNase <- c(peaks_RNase, j)
    }
  }
  
  # Calculate the difference in peak counts
  diff_peaks <- length(peaks_RNase) - length(peaks_Ctrl)
  
  # Store the difference in the results vector
  results[i] <- diff_peaks
}

# Create a data frame with the results
identical_fractions2 <- data.frame(local_shift = results, row.names = row.names(Mitosis_Ctrl_100))

# Print the identical_fractions dataframe
print(identical_fractions2)

# Count the number of entries not equal to zero in the no_shift column
sum(identical_fractions2$local_shift != 0)
```


## 4. VERGLEICH MIT RBP2GO

Übersicht:
-> absolute maxima shifts
shift_dataframe #right shift, left shift, no shift -> not usable
Sondern mit (wie Alexandra schon gemacht):
data.frame(Ctrl_fraction_max, RNase_fraction_max)

-> local maxima amount and location comparison
identical_fractions #TRUE: no shifter, FALSE: Shifter -> not really usable I think, directly already calculated into two categories

-> protein content quotiens 
quotients_minmax #Werte umdie 1, je mehr sie abweichen, desto eher sind es shifter -> usable? GGF hier einfach NUR DEN WERT NEHMEN, DER AM MEISTEN ABWEICHT!

->y-shifts
results_yshift #relativ große und relativ unterschiedliche Werte

#### 4.1 RBP2GO Datensatz ins Rmd Laden:

```{r}
# Load a text file into R
#comparison_RBP = read.csv("https://www.dropbox.com/s/xpjob8g8flxl3ik/Table_HS_RBP.txt?dl=1", sep = "", header = T, row.names = 1)

# View the loaded data
#head(comparison_RBP)

#comparison_RBP1 <- read.delim("~/GitHub/topic03_team02/Datensatz_RBP2GO_Proteins.txt", row.names=1, comment.char="#") #-> nur local
```

Neue Tabellen laden: RBP und non_RBP aus verschiedenen Datenssätzen.
Vorsicht code braucht seeeehr lange...
```{r}
comparison_RBP = read.csv("https://www.dropbox.com/s/xpjob8g8flxl3ik/Table_HS_RBP.txt?dl=1", sep = "", header = T, row.names = 1)

comparison_RBP = comparison_RBP[order(row.names(comparison_RBP)),]

comparison_non_RBP = read.csv("https://www.dropbox.com/s/cgbrvponhw7arpt/Table_HS_Non_RBP.txt?dl=1", sep = "", header = T, row.names = 1)

comparison_non_RBP = comparison_non_RBP[order(row.names(comparison_non_RBP)),]

# View the loaded data
head(comparison_non_RBP)
```


## Von Fabio vorgeschlagener Vergleich:

Ich nehme alle als max_shift identifizierten Proteine und schaue wie viele von ihnen NICHT in der comparison_RBP datei zu finden sind, aka wie viele wir also fälschlicherweise als shifter identifiziert haben. (man kann auch ganz leicht das ! löschen und dann hat man die umgekehrte selektion)

erstmal wieder mit max_shift:
```{r}
# Get the row names that meet the criteria in shift_comparison_RBP2go
selected_rows <- rownames(shift_comparison_RBP2go)[shift_comparison_RBP2go[, 1] != 0 & shift_comparison_RBP2go[, 1] != 1 & shift_comparison_RBP2go[, 1] != -1]

# Check which selected rows are not found in comparison_RBP
not_found_rows <- sum(!(selected_rows %in% rownames(comparison_RBP)))

# Print the number of rows not found in comparison_RBP
cat("Number of rows meeting the criteria but not found in comparison_RBP:", not_found_rows, "\n")
```
Ergebnis: 143. Also von unseren 581 identifizierten shiftern, haben wir anscheinend 143 laut RDeep tabelle falsch identifiziert.

Jetzt für shifter:
```{r}
# Get the row names of the "shifters" in shifting_quotients
shifter_rows <- rownames(shifting_quotients)[shifting_quotients$Curve_shifters == "shifter"]

# Count the number of rows not found in comparison_RBP
not_found_rows <- sum(!(shifter_rows %in% rownames(comparison_RBP)))

# Print the total number of rows not found
cat("Total number of rows from 'shifters' in shifting_quotients not found in comparison_RBP:", not_found_rows, "\n")
```
Hier als 675 von 2646 wurden falsch positiv identifiziert (für 30% Grenze). Für 40% habe ich 528 von 2168 falsch identifiziert (25.5%), bei 50% 416 von 1749, bei 60% 338 von 1439, für 70% 277 von 1241 (nur noch 22.3% falsch). Je höher ich die Grenze setze, desto weniger falsch positive bekomme ich (auch anteilig).

```{r}
# Get the row names of the "shifters" in quotients_using_z
shifter_rows <- rownames(quotients_using_z)[quotients_using_z$Result == "shifter"]

# Count the number of rows not found in comparison_RBP
not_found_rows <- sum(!(shifter_rows %in% rownames(comparison_RBP)))

# Print the total number of rows not found
cat("Total number of rows from 'shifters' in quotients_using_z not found in comparison_RBP:", not_found_rows, "\n")
```
-> 310 von 1337 (23.2%), das ist etwas schlechter als die 70% Grenze von dem manuellen Code. Später gern noch weiter diskutieren. Können theoretisch alle Kategorien noch durchprobieren, aber ich gehe glaub erstmal schlafen. 

#### 4.2 Venn-Diagramms

Wäre eigentlich cool die Überlappung in Diagrammen darstellen zu können, idealerweise von allen vier Analysemethoden. y-shift ist aber noch nicht fertig, deswegen nehme ich erstmal max shift, local shift und curve shift.

Dataframe preparation:
```{r}
# max shift: 
# Filter rows with "left shift" or "right shift" in the shift_dataframe:
max_shifter_names <- shift_dataframe[shift_dataframe$Shift %in% c("left shift", "right shift"), , drop = FALSE]

# y shift:
# Filter rows from y_max_subset where ProteinType is 'RBP':
y_rows <- y_max_subset[y_max_subset$ProteinType == 'RBP',, drop = FALSE ]

#COMBINE ROWS WITH MAX SHIFT THIS TOOK AGES
colnames(y_rows) <- "Shift"
y_rows$Shift <- ifelse(y_rows$Shift == "RBP", "left shift", y_rows$Shift)
max_shifter_names <- rbind(max_shifter_names, y_rows)

# local shift:
# Filter rows with FALSE results in the identical_fractions dataframe:
local_shifter_names <- subset(identical_fractions, no_shift == FALSE)

# curve shift:
# # Filter rows with "shifter" in the shifting_quotients dataframe:
curve_shifter_names <- shifting_quotients[shifting_quotients$Curve_shifters == "shifter", , drop = FALSE]

curvez_shifter_names <- quotients_using_z[quotients_using_z$Result == "shifter", , drop = FALSE]

#alternative curve shift methode: 
#curve_shifter_names <- quotients_using_z[quotients_using_z$Result == "shifter", , drop = FALSE]

## I also checked the numbers, I did not loose any values.
```

Now trying a Venn-Diagramm
```{r}
#install.packages("VennDiagram")
library(VennDiagram)

# Extract the row names from each dataframe
max_shifter_row_names <- rownames(max_shifter_names)
local_shifter_row_names <- rownames(local_shifter_names)
curve_shifter_row_names <- rownames(curve_shifter_names)

# Create the Venn diagram
venn_result <- venn.diagram(
  x = list(max_shifter_row_names, local_shifter_row_names, curve_shifter_row_names),
  category.names = c("Max & Y Shifters", "Local Shifters", "Curve Shifters"),
  filename = NULL,  # Set filename to NULL to prevent saving as an image file
  fill = c("dodgerblue", "firebrick1", "darkgoldenrod1"),  # Specify colors for the diagram elements
  alpha = 0.5,  # Set transparency for the overlapping areas
  cex = 1.5  # Increase the font size
)

# Print the Venn diagram
grid.newpage()
grid.draw(venn_result)
```

additional test with rdeep values:

```{r}
library(VennDiagram)

# Extract the row names from each dataframe
max_shifter_row_names <- rownames(max_shifter_names)
local_shifter_row_names <- rownames(local_shifter_names)
curve_shifter_row_names <- rownames(curve_shifter_names)
#y_row_names <- rownames(y_rows)
RBP_row_names <- rownames(comparison_RBP)

# Create the Venn diagram
venn_result <- venn.diagram(
  x = list(max_shifter_row_names, local_shifter_row_names, curve_shifter_row_names, RBP_row_names),
  category.names = c("Max Shifters", "Local Shifters", "Curve Shifters", "RBP2GO shifters"),
  filename = NULL,  # Set filename to NULL to prevent saving as an image file
  fill = c("dodgerblue", "firebrick1", "darkgoldenrod1", "springgreen"),  # Specify colors for the diagram elements
  alpha = 0.5,  # Set transparency for the overlapping areas
  cex = 1.5  # Increase the font size
)

# Print the Venn diagram
grid.newpage()
grid.draw(venn_result)
```



Direct test with rdeep values one on one

```{r}
library(VennDiagram)

# Extract the row names from each dataframe
local_shifter_row_names <- rownames(local_shifter_names)
RBP_row_names <- rownames(comparison_RBP)

# Create the Venn diagram
venn_result <- venn.diagram(
  x = list(local_shifter_row_names, RBP_row_names),
  category.names = c(" ", " "),
  filename = NULL,  # Set filename to NULL to prevent saving as an image file
  fill = c("dodgerblue", "firebrick1"),  # Specify colors for the diagram elements
  alpha = 0.5,  # Set transparency for the overlapping areas
  cex = 1.5  # Increase the font size
)

# Print the Venn diagram
grid.newpage()
grid.draw(venn_result)
```

```{r}
# Find the common row names in max_shifter_row_names and RBP_row_names
common_row_names <- intersect(curve_shifter_row_names, RBP_row_names)

# Find the row names that are not present in local_shifter_row_names and curve_shifter_row_names
desired_row_names <- setdiff(common_row_names, union(local_shifter_row_names, max_shifter_row_names))

# Print the desired row names
print(desired_row_names)
length(desired_row_names)
```



OLD thingey to generate the PNG picture
```{r}
# Load the VennDiagram package
library(VennDiagram)

# Extract the row names from each dataframe
max_shifter_row_names <- rownames(max_shifter_names)
local_shifter_row_names <- rownames(local_shifter_names)
curve_shifter_row_names <- rownames(curve_shifter_names)

# Create the Venn diagram
venn_result <- venn.diagram(
  x = list(max_shifter_row_names, local_shifter_row_names, curve_shifter_row_names),
  category.names = c("Max Shifters", "Local Shifters", "Curve Shifters"),
  filename = "venn_diagram.png"  # Optional: Specify the filename to save the diagram as an image
)
```

#### 4.3 alter vergleich: Comparing local with absolute maxima

All rows with "left shift" or "right shift" in the shift_dataframe dataframe are compared with all "FALSE" results in the identical_fractions dataframe (aka shifters). If the rows fullfill both criteria in the respective dataframe, I want to create a new dataframe named dodgy_proteins, in which these rows have the result "TRUE". 
(this code only works if you run the working code beforehand)

```{r}
# Create an empty dataframe to store the results
dodgy_proteins <- data.frame(Result = logical(nrow(shift_dataframe)), row.names = row.names(shift_dataframe))

# Iterate over the rows of shift_dataframe
for (row_name in row.names(shift_dataframe)) {
  # Check if the row meets the criteria in shift_dataframe
  if ((shift_dataframe[row_name, ] %in% c("right shift", "left shift")) & !identical_fractions[row_name, ]) {
    # Assign TRUE to the corresponding row in dodgy_proteins
    dodgy_proteins[row_name, ] <- TRUE #These proteins give different results in each method!!!
  } else {
    # Assign FALSE to the corresponding row in dodgy_proteins
    dodgy_proteins[row_name, ] <- FALSE
  }
}

# Print the dodgy_proteins dataframe
print(dodgy_proteins)

sum(dodgy_proteins$Result)

sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
```
Nice! Both methods seem to give the EXACT SAME PROTEINS. (Only comparing the number would not guarantee that the proteins are identical, but I try to avoid this using this code.) Explanation: we have 581 TRUE results in our dataframe, meaning in 581 rows (proteins) both criteria are fulfilled. Now we count how many proteins are in total identified as shifters in the maximum peak method: also 581
```{r}
#Count how many have been identified using the local fraction comparison method:
sum(!identical_fractions) #Checks all FALSE (aka shifters) results in the dataframe
```
This is A LOT more! Aka the maximum peak shifter only identifies about half of the proteins which the local fraction comparison identifies as shifters.


## 5. Liniear Regression

#### 5.1.Finden von zwei Spalten in einem Dataframe die eine möglichst lineare Beziehung haben

EInen passenden DF hierfür müsste noch erstellt werden
Idee: columns nach jeder unserer Methoden (4?) und wir finden so sozusagen die beiden Methoden die in größer Übereinstimmung RBPs bestimmt haben und wenden dann auf die LR an
Ich denke das wäre bei uns ziemlich cool, eben weil wir diese verschiedenen Methoden haben

Versuch den oben beschriebenen Datensatz zu erstellen:

1. Größe des x-shift: max_shift <- Ctrl_fraction_max - RNase_fraction_max
2. Unterschied in Anzahl local maxima: identical_fractions2$local_shift (ggf problematisch da hier eine verschiebung der local maxima ignoriert wird)
3. Ausmaß des y-shift: results_yshift$YDiff

ggf. 4. column: maximaler/minimaler Kurven quotient?? Vereinfachend den max wert genommen, da dieser in erster Linie größer und somit ggf aussagekräftiger ist.


```{r}
max_shift <- Ctrl_fraction_max - RNase_fraction_max

# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
                               local_shift = identical_fractions2$local_shift,
                               YDiff = results_yshift$YDiff,
                               curve_shift = quotients_minmax$Max,
                               row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"

# Print the shift_comparison dataframe
print(shift_comparison)

```


#### 5.2. Lineare Regression

```{r}
# Assuming you have a dataframe called 'my_data' with multiple columns

# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL

# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
  for (j in (i + 1):ncol(shift_comparison)) {
    # Extract the two columns
    col1 <- shift_comparison[, i]
    col2 <- shift_comparison[, j]
    
    # Calculate the Pearson correlation coefficient
    correlation <- cor(col1, col2, use = "pairwise.complete.obs")
    
    # Fit a linear model and calculate the residuals
    model <- lm(col2 ~ col1)
    residuals <- resid(model)
    
    # Check if the correlation is stronger than the previous best
    if (abs(correlation) > abs(best_correlation)) {
      best_correlation <- correlation
      best_fit <- list(col1 = col1, col2 = col2, residuals = residuals)
    }
  }
}

# Print the columns with the best linear relationship found
print(best_fit$col1)
print(best_fit$col2)

# Optionally, you can also inspect the residuals or other information
print(best_fit$residuals)

```

Verenas modifizierung des coolen codes!

```{r}
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""

# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
  for (j in (i + 1):ncol(shift_comparison)) {
    # Extract the two columns
    col1 <- shift_comparison[, i]
    col2 <- shift_comparison[, j]
    
    # Calculate the Pearson correlation coefficient
    correlation <- cor(col1, col2, use = "pairwise.complete.obs")
    
    # Check if the correlation is stronger than the previous best
    if (abs(correlation) > abs(best_correlation)) {
      best_correlation <- correlation
      best_col1_name <- names(shift_comparison)[i]
      best_col2_name <- names(shift_comparison)[j]
    }
  }
}

# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
```
Lustigerweise egal ob ich den Maximalen wert des Kurven Quotienten Codes nehme oder den minimalen, in beiden Fällen wird die höchste Korrelation zwischen dem curve_shift daten und den max_shift daten gefunden! Eigentlich sehr cool, nächster Schritt wäre dann die lineare Regression durchführen. (und aufräumen kann man immer, aber lieber nichts löschen, sondern vllt mit kurzer überschrift in den old code oder so.)




#### 5.3. Speicherung Code zur Erstellung des result dataframes, aus Working code rüberkopiert:


To put all these values in a new DF we first need to make sure they have the right format:
```{r}
#str(max_shift)
#str(identical_fractions)
#str(results_yshift)
#str(quotients_minmax)

print(class(max_shift))
print(class(identical_fractions))
print(class(results_yshift))
print(class(df_results_yshift))
print(class(quotients_minmax))
#kann man später wieder löschen. Hab ich zum Verständnis gebraucht
```
```{r}
#to put everything into one big dataframe the seperate dataframes need to have the same amount of rows

print(nrow(max_shift))
print(nrow(identical_fractions))
print(nrow(df_results_yshift))
print(nrow(quotients_minmax))
#kann man später wieder löschen. Hab ich zum Verständnis gebraucht
```
Das hab ich gemacht weil beim zusammenführen er mir einen Error bringt der besagt das ich unterschiedlich viele rows habe. Plot twist: habe ich nicht
wtf?!
=> okay jetzt hab ich es: die Values müssen Zahlen sein und ein wenig anders angeordnet 
Ich guck mal oben im Code was wir alles für variablen und DF haben und welche jeweils am besten passen

```{r}
#for max shift
head(max_shift) #should be fine
colnames(max_shift) <- c("Diff_Max")

#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten

#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
  #oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
  #column1 <- my_matrix[, 3]
  #df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
  #head(df_results_yshift2)
#code das das hier zahlen gibt im Ideas

#for curve shift
Diff_quotient <- quotients_minmax$Max - quotients_minmax$Min
Diff_quotient <- data.frame(Diff_quotient)
head(Diff_quotient)
#SINN?!
```
Eine Sache die wir uns unbedingt noch überlegen müssen ist das am Ende alle diese Methoden ein RBP implizieren wenn die values hoch sind (bzw möglichst stark von 0 abweichen) und das value = 0 immer non-shifter impliziert. Aber das müsste passen

#####  6.1.2 generate die actual Dataframe
```{r}
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
                               local_shift = identical_fractions,
                               YDiff = df_diff_yshift,
                               curve_shift = Diff_quotient,
                               row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"

# Print the shift_comparison dataframe
print(shift_comparison)

```

