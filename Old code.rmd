---
title: "Old code"
author: "Orrego Chong, Kantelhardt, Kornelius"
date: "2023-06-08"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")

head(RDeeP_HeLa_Mitosis)
```

## Visualization

```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 1382  # Adjust the row index as needed
row_data <- Mitosis_Ctrl_100[row_index, ]
row_name <- row.names(Mitosis_Ctrl_100)[row_index]

# Step 2: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
  if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
    peaks <- c(peaks, i)
  }
}

# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)
```

#### Checking reproducibility with correlation?

-\> NOT RELEVANT IF T-TEST IS ACCEPTED.

Testing the correlation for the first three entries in our Control dataset. A possible idea is to apply this all on the entire dataset again, and then for example sort out all proteins in which the correlation between the fractions is less than 95%. This will then guarantee that all remaining fractions have a high correlation and thus a high reproducibility. But there is still a lot to do!

```{r}
# Calculate the pairwise correlations between the first three columns
cor_matrix_frac1 <- cor(RDeeP_HeLa_Mitosis_Ctrl[, 1:3], method = "pearson")

# Visualize the correlation matrix using a heatmap
heatmap(cor_matrix_frac1,
        col = colorRampPalette(c("blue", "white", "red"))(100),
        main = "Correlation Heatmap")

#Printing the correlation matrix as data frame
print(as.data.frame(cor_matrix_frac1))
```

#### Shift analysis old

Now the first idea is to start working on shift analysis. First step would be determine the fractions, in which the maximum peak is, and then substract the Control and RNase shifts. This all will be the easiest in proteins with one peak per Control/RNase.
FOR ONE PEAK PROTEINS:

```{r}
# Step 1: Create an empty vector to store the results
#one_peak_shifts <- vector("character", length = length(rows_with_one_peak))
#names(one_peak_shifts) <- rownames(Mitosis_Ctrl_100)[rows_with_one_peak]

#Doesn't matter if we take the row indexes from the control or RNase dataset, theoretically they should be identical. Testing my theory:
#nrow(Mitosis_Ctrl_100[rows_with_one_peak,])
#nrow(Mitosis_RNase_100[rows_with_one_peak,]) #--> works, is identical :)

# Get the row data from Mitosis_Ctrl_100 and Mitosis_RNase_100
row_data_ctrl <- Mitosis_Ctrl_100[rows_with_one_peak,]
row_data_rnase <- Mitosis_RNase_100[rows_with_one_peak,] #HERE IT SHOULD SAY RNASE, BUT THEN THE CODE DOESNT WORK AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHh
  
# Find the column index with the maximum value in each row
max_col_ctrl <- max.col(row_data_ctrl)
max_col_rnase <- max.col(row_data_rnase)

# Create an empty dataframe to store the results
result_df <- data.frame(Result = character(length(rows_with_one_peak)), stringsAsFactors = FALSE)
rownames(result_df) <- seq_along(rows_with_one_peak)

# Compare the elements of the vectors
comparison <- mapply(function(x, y) {
  diff <- x - y 
  
  if (diff < 0) {
    return("right shift")
  } else if (diff > 0) {
    return("left shift")
  } else {
    return("no shift")
  }
}, max_col_ctrl, max_col_rnase)

# Create the result dataframe
result_df <- data.frame(Result = comparison, row.names = seq_along(rows_with_one_peak))

# Print the result dataframe
print(result_df)
```

Also haven't managed to add the names, not sure how yet.

```{r}
# Count the occurrences of "left shift"
left_shift_count <- table(result_df$Result)["left shift"]
right_shift_count <- table(result_df$Result)["right shift"]
no_shift_count <- table(result_df$Result)["no shift"]

# Print the count
print(left_shift_count)
print(right_shift_count)
print(no_shift_count)
```
WELL in principle the code gives a close to right result, I haven't changed Ctrl to RNase yet, but that gives me an error, I do not know why.



##### Jimenas Old Code?

<<<<<<< Updated upstream
## 3.1 Specific visualization of proteins
=======
#### Attempt no.1

This code allows us to identify all rows with multiple peaks

```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks) #this is already a vector
rows_with_multiple_peaks


#rows_with_multiple_peaks_df <- data.frame(Row_Name = rownames(Mitosis_Ctrl_100), value = rows_with_multiple_peaks) 

#rows_with_multiple_peaks_df
#rownames(Mitosis_Ctrl_100 %in% rows_with_multiple_peaks)
```

Rows with just one peak still does not want to cooperate :l

```{r}
# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  # Extract the row
  row <- Mitosis_Ctrl_100[row_index, ]
  
  # Find the global maximum in the row
  global_max <- max(row)
  
  # Check if the row has only one peak
  has_one_peak <- sum(row == global_max) == 1 && all(diff(row) < 0)
  
  # Print the result for the current row
  print(paste("Row", row_index, "has one peak:", has_one_peak))
}



```

still does not cooperte

```{r}
# Create an empty list to store results
maxima_results <- list()

# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  row <- Mitosis_Ctrl_100[row_index, ]
  
  # Find the maximum value in the row
  max_value <- max(row)
  
  # Find the indices of maxima in the row
  max_indices <- which(row == max_value)
  
  # Check if each maximum is a global or local maximum
  max_types <- c()
  for (i in max_indices) {
    if (i > 1 && i < length(row)) {
      if (row[i] > row[i-1] && row[i] > row[i+1]) {
        max_types <- append(max_types, "Local")
      } else {
        max_types <- append(max_types, "Global")
      }
    } else {
      max_types <- append(max_types, "Global")
    }
  }
  
  # Store the results in the list
  maxima_results[[row_index]] <- data.frame(MaximaValue = row[max_indices], MaximaIndex = max_indices, MaximaType = max_types)
}

# Print the results
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  print(paste("Row", row_index, "Maxima:"))
  print(maxima_results[[row_index]])
}
```



Old attempt at using t test for curve quotient analysis, but variance is to small for t test to work.
```{r}
# Create an empty dataframe for curve_p_value
curve_p_value <- data.frame("P-value" = numeric(0), "Curve shifters" = character(0), stringsAsFactors = FALSE)

# Iterate over each row in curve_quotients
for (i in 1:nrow(curve_quotients)) {
  # Get the row values
  row_values <- curve_quotients[i, ]
  
  # Check for constant values in the row
  if (length(unique(row_values)) == 1) {
    # Skip the row if all values are constant
    next
  }
  
  # Perform one-sample t-test
  t_test <- t.test(row_values, mu = 1, alternative = "two.sided", conf.level = 0.95)
  
  # Extract the p-value
  p_value_row <- t_test$p.value
  
  # Assign shifter status based on p-value
  shifter <- ifelse(p_value_row < 0.05, "shifter", "no shifter")
  
  # Add the p-value and shifter status to the dataframe
  curve_p_value[i, "P-value"] <- p_value_row
  curve_p_value[i, "Curve shifters"] <- shifter
}

# Print the curve_p_value dataframe
print(curve_p_value)
```

#### Wilcoxon attemot
If the p-value is less than 0.95 (corresponding to a significance level of 0.05), it assigns the value "shifter" to indicate a significant difference from the mean of 1; otherwise, it assigns "no shifter".

```{r Wilcoxon signed rank test}
# Perform Wilcoxon signed rank test on each row
p_values <- apply(curve_quotients, 1, function(row) {
  wilcox.test(as.numeric(row), mu = 1, alternative = "two.sided", exact = FALSE)$p.value
})

# Create the curve_p_values dataframe
curve_p_values <- data.frame(
  p_value = p_values,
  stringsAsFactors = FALSE
)

# Add a column for Curve_shifters based on p-value significance level
curve_p_values$Curve_shifters <- ifelse(curve_p_values$p_value < 0.95, "shifter", "no shifter")

# Print the curve_p_values dataframe
print(curve_p_values)
```

```{r}
# Count the number of rows with NA values
sum(rowSums(is.na(curve_p_values)) > 0)
```
This doesn't seem to completely work yet. I'll stay on it though.



#### 9. Sylviane Parameters

Kmeans lost attempt

```{r}
#Versuch einen kmeans mit Max shift und Protein quotients zu machen
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
```

We want kmeans to consider different parameters for this we put them in a matrix. Here we create and normalize/scale the matrix:

```{r}
parameters <- cbind(maximum_fraction, quotients_minmax)

rownames(parameters) <- rownames(maximum_fraction)
```

#### 9.1 Sylviane kmeans - clustering

Now we cluster the proteins depending on their parameters:

```{r}
# n = Number of clusters
n <- 3
km.maxquo <- kmeans(parameters, centers = n, nstart = 100)
```

#### 9.2 Sylviane Plot

Let's plot the peaks against each other:

```{r}
cluster <- km.maxquo$cluster

#abhängig davon ob es drei oder vier cluster gibt werden unterschiedliche Vektoren verwendet:

if (n == 3){
  col <- c("springgreen", "violetred1", "cyan")
  vjust <- c(1, -0.5, -0.5)
  labels <- c("no shift", "left shift", "right shift")
}
if (n == 4){
  col <- c("springgreen", "violetred1", "cyan", "orange")
  vjust <- c(-0.5, -0.5, -0.5, -0.5)
  labels <- c("left shift", "right shift", "no shift", "precipitated")
}

library("ggplot2")

#hier wird ein Datframe mit allen für den dotplot relevanten daten erstellt
peaks <- data.frame(Ctrl_fraction_max, RNase_fraction_max, cluster)


#für den barplot muss der auch die Ergebnisse des Clusterings als Dataframe dargestellt werden
number.of.clusters <- data.frame(value = cluster)

#das cluster muss als factor dargestellt sein, vector geht nicht
peaks$cluster <- factor(peaks$cluster)

#hier wird der dotplot erstellt der die peaks gegeneinander aufträgt. Die Punkte werden abhängig von ihrer shiftart eingefärbt
dot.plot <- ggplot(peaks, aes(Ctrl_fraction_max,RNase_fraction_max)) + 
  geom_point(aes(colour = cluster), shape = 19, alpha = 0.5, size = 2)+
  labs(x = "Fraction of Control Peak", y = "Fraction of RNase Peak", title = "Peak distribution")+
  coord_equal()+
  scale_colour_manual(values = col,labels = labels)+
  theme_light()


# hier wird ein Barplot erstellt der anzeigt, wie oft die shifttypes jeweils vorkommen
bar.plot <- ggplot(number.of.clusters, aes(factor(value)))+
  geom_bar(fill = col
           , width = 0.5)+
  theme_minimal()+
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_rect(color = "grey", fill = NA),
        panel.background = element_rect(fill = "white", colour = NA))+
  geom_text(stat = 'count', 
            aes(label = after_stat(count)), 
            vjust = vjust, 
            size = 2.5)

#hier werden die beiden plots zusammengefügt. Der barplot wird unten rechts klein angezeigt
dot.plot +
  annotation_custom(grob = ggplotGrob(bar.plot), 
                    xmin = 15, 
                    xmax = 27, 
                    ymin = -1, 
                    ymax = 8)
```


Saving space for the old, inefficient t-test code:

```{r}
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Extract the values for the current row (protein)
  row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
  
  # Create an empty vector to store the p-values for the current row (protein)
  p_values_row <- c()
  
  # Iterate over every three columns in the current row (protein)
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Extract the values for the current set of three columns
    column_values <- row_values[j:(j + 2)]
    
    # Calculate the p-value for the set of three columns using t-test
    t_result <- t.test(column_values)
    p_value <- t_result$p.value
    
    # Append the p-value to the vector for the current row (protein)
    p_values_row <- c(p_values_row, p_value)
  }
  
  # Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
  p_values_Ctrl[i, ] <- p_values_row
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))

# Print the new dataframe
print(p_values_Ctrl)
```


## 10. COMPARISON TO OTHER DATA

Furthermore, we added data on previously found RBPs and non-RBPs.

```{r Load extra data for comparison of results}
HS_RBPs <- read.csv("https://raw.githubusercontent.com/datascience-mobi-2022/2022-topic-03-team-03/main/1_HS_RBPs.csv", header=TRUE, sep = ",")

HS_non_RBPs <- read.csv("https://raw.githubusercontent.com/datascience-mobi-2022/2022-topic-03-team-03/main/2_HS_non_RBPs.csv", header=TRUE, sep = ",")
```

```{r Quantification of results functions}
# Function to identify True RBP
Find_true_RBP <- function(potential_RBP) {
  Match_RBP <- HS_RBPs$Entry_Name.x %in% potential_RBP    # Compare potential RBP with RBP from other publications
  True_RBP_pos <- which(Match_RBP == TRUE)                # Find the positions of true RBP
  True_RBP_names <- HS_RBPs$Entry_Name.x[True_RBP_pos]    # Find names of true RBP
  return(True_RBP_names)
}

# Function to identify False RBP
Find_false_RBP <- function(potential_RBP) {                    
  Match_RBP <- HS_non_RBPs$Entry_Name.x %in% potential_RBP      # Compare potential RBP with RBP from other publications
  False_RBP_pos <- which(Match_RBP == TRUE)                     # Find the positions of false RBP
  False_RBP_names <- HS_non_RBPs$Entry_Name.x[False_RBP_pos]    # Find names of false RBP
  return(False_RBP_names)
}

# Function to identify true non-RBP
Find_true_non_RBP <- function(potential_non_RBP) {
  Match_non_RBP <- HS_non_RBPs$Entry_Name.x %in% potential_non_RBP    # Compare potential non-RBP with non-RBP from other publications
  True_non_RBP_pos <- which(Match_non_RBP == TRUE)                    # Find the positions of true non-RBP
  True_non_RBP_names <- HS_non_RBPs$Entry_Name.x[True_non_RBP_pos]    # Find names of true non-RBP
  return(True_non_RBP_names)
}

# Function to identify false non-RBP
Find_false_non_RBP <- function(potential_non_RBP) {
  Match_non_RBP <- HS_RBPs$Entry_Name.x %in% potential_non_RBP    # Compare potential non-RBP with non-RBP from other publications
  False_non_RBP_pos <- which(Match_non_RBP == TRUE)               # Find the positions of false non-RBP
  False_non_RBP_names <- HS_RBPs$Entry_Name.x[False_non_RBP_pos]   # Find names of false non-RBP
  return(False_non_RBP_names)
}
# Function to show RBDs
Find_RBD <- function(potential_RBD) {
  RBD_stat <- RBD_stat_non_RBP[rownames(RBD_stat_non_RBP) %in% potential_RBD, ]
  RBD_true_prot_df <- RBD_stat[RBD_stat$RBD_status == "RBD", ]
  RBD_true_prot_names <- rownames(RBD_true_prot_df)
  return(RBD_true_prot_names)
}
```

## 10.1 RBP COMP.
Werte des aus den geladenen Tabellen nun in unseren shift_comparison datensatz laden (um Überschneidungen zu vermeiden habe ich einen neuen, namenähnlichen Datensatz erstellt.)
```{r}
shift_comparison_RBP2go <- shift_comparison
shift_comparison_RBP2go[, 5] = NA
colnames(shift_comparison_RBP2go) = c(colnames(shift_comparison_RBP2go)[-5], "RBP2GO_Score")

shift_comparison_RBP2go[which(rownames(shift_comparison_RBP2go) %in% rownames(comparison_RBP)), 5] = comparison_RBP[which(rownames(comparison_RBP) %in% rownames(shift_comparison_RBP2go)), 3]

shift_comparison_RBP2go[which(rownames(shift_comparison_RBP2go) %in% rownames(comparison_non_RBP)), 5] = comparison_non_RBP[which(rownames(comparison_non_RBP) %in% rownames(shift_comparison_RBP2go)), 3]

head(shift_comparison_RBP2go) #nice, klappt alles!
```

Frage ist jetzt, was wir damit sagen. dieser RBP2Go score gibt uns an, mit welcher Sicherheit die jeweiligen Proteine RBPs sind. 
-> Random Idee: Summe der RBP2Go scores von den von uns als RBP identifizierten Proteinen zusammenaddieren und die mit der der Summe der non-RBPs vergleichen... Idealerweise wäre die erste Summe deutlich größer. GGf je nach Methode einzeln? Dafür müsste man nochmal den Datenframe bei paar Methoden verändern though.

-> oder irgendetwas wie Marcel mit diesen True positive und false negative erstellen. ggf im Tutorium nachfragen. --> wurde begonnen bisschen! Indem man schaut in welchen tabellen die Proteine beide vorkommen. Siehe unten.

Vergleich RBP2go scores im max-shift.

Änderung von vorger: anwendung des richtigen Kriteriums, zudem geteilt durch die anzahl der Zeilen die reinaddiert wurden:

```{r}
# Calculate the sums based on conditions
non_zero_sum <- sum(shift_comparison_RBP2go[, 5][shift_comparison_RBP2go[, 1] != 0 & shift_comparison_RBP2go[, 1] != 1 & shift_comparison_RBP2go[, 1] != -1], na.rm = TRUE)
other_sum <- sum(shift_comparison_RBP2go[, 5][shift_comparison_RBP2go[, 1] == 0 | shift_comparison_RBP2go[, 1] == 1 | shift_comparison_RBP2go[, 1] == -1], na.rm = TRUE)

# Count the number of rows meeting the specific criteria
non_zero_rows <- sum(shift_comparison_RBP2go[, 1] != 0 & shift_comparison_RBP2go[, 1] != 1 & shift_comparison_RBP2go[, 1] != -1)
other_rows <- sum(shift_comparison_RBP2go[, 1] == 0 | shift_comparison_RBP2go[, 1] == 1 | shift_comparison_RBP2go[, 1] == -1)

# Calculate the division
non_zero_avg <- non_zero_sum / non_zero_rows
other_avg <- other_sum / other_rows

# Print the sums and division results
cat("Sum of fifth column values when first column is not equal to zero, one, or minus one:", non_zero_sum, "\n")
cat("Number of rows meeting the specific criteria:", non_zero_rows, "\n")
cat("Average of fifth column values when first column is not equal to zero, one, or minus one:", non_zero_avg, "\n")

cat("\n")

cat("Sum of fifth column values when first column is equal to zero, one, or minus one:", other_sum, "\n")
cat("Number of rows meeting the specific criteria:", other_rows, "\n")
cat("Average of fifth column values when first column is equal to zero, one, or minus one:", other_avg, "\n")
```
Hier klappt es! Der mittlere RBP Wert von non-shifters ist deutlich geringer als der RBP Wert von shiftern! Yay!

Gleiches Prozedere mit 50% grenze und den Curve_shifters:

```{r}
# Calculate the sums based on conditions
shifter_sum <- sum(shift_comparison_RBP2go[, 5][rownames(shift_comparison_RBP2go) %in% rownames(shifting_quotients) & shifting_quotients[, "Curve_shifters"] == "shifter"], na.rm = TRUE)
not_shifter_sum <- sum(shift_comparison_RBP2go[, 5][rownames(shift_comparison_RBP2go) %in% rownames(shifting_quotients) & shifting_quotients[, "Curve_shifters"] != "shifter"], na.rm = TRUE)

# Count the number of rows meeting the specific criteria
shifter_rows <- sum(rownames(shift_comparison_RBP2go) %in% rownames(shifting_quotients) & shifting_quotients[, "Curve_shifters"] == "shifter")
not_shifter_rows <- sum(rownames(shift_comparison_RBP2go) %in% rownames(shifting_quotients) & shifting_quotients[, "Curve_shifters"] != "shifter")

# Calculate the division
shifter_avg <- shifter_sum / shifter_rows
not_shifter_avg <- not_shifter_sum / not_shifter_rows

# Print the sums and division results
cat("Sum of fifth column values for rows with 'shifter' result in shifting_quotients:", shifter_sum, "\n")
cat("Number of rows meeting the 'shifter' criteria:", shifter_rows, "\n")
cat("Average of fifth column values for rows with 'shifter' result in shifting_quotients:", shifter_avg, "\n")

cat("\n")

cat("Sum of fifth column values for rows with 'not shifter' result in shifting_quotients:", not_shifter_sum, "\n")
cat("Number of rows meeting the 'not shifter' criteria:", not_shifter_rows, "\n")
cat("Average of fifth column values for rows with 'not shifter' result in shifting_quotients:", not_shifter_avg, "\n")
```
Mhm, scheint weniger genau. Aber dies ist noch keine tragfähige Aussage.


## 11. Min Max scaling

This would be an alternative to the data scaling to 100 method. We rescale the values to a fixed range, typically between 0 and 1. The scaling process involves subtracting the minimum value from each value in the variable and then dividing by the range (maximum value minus the minimum value). This transformation ensures that all values are proportionally scaled within the specified range.

```{r Min Max scaling}
# Min-max scaling function
min_max_scaling <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column). 

#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling)) 

# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
```

We can later decide which method to chose.

## 12. Visualization
```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 3388     # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein

# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,40), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```


#### 12.1 Index finder 

```{r}
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2

# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_index, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Find the row name
row_name <- row.names(Mitosis_Ctrl_100)[row_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))

```

The same as above, but for a protein name based search :)
```{r}
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "RBM3_HUMAN"

# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_name, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
```

#### 12.2 Web search RNase and Control peak finder

"Web search" for protein indices in the RNase Dataframe
```{r}
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2

# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_index, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Find the row name
row_name <- row.names(Mitosis_RNase_100)[row_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))

```

"Web search" for protein names in the RNase Dataframe
```{r}
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5E_HUMAN"

# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_name, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
```

#### useful peak finder?

Overview to know in which fraction the max was found. The vector should then help for further analysis.
Overview for Ctrl Dataframe.
```{r}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)

# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)

#Results as vector
as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max) 

```

Overview RNase Dataframe.
```{r}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_RNase_100)

# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)

#Results as vector
as.vector(RNase_fraction_max) #just numbers (aka fractions where max) 

```

And this is how I imagine we could detect shifts.
We subtract the value in Ctrl_fraction_max (Ctrl fraction where max) with the value in RNase_fraction_max (RNase fraction where max) . If the result:
'=' 0: no shift
'>' 0: (positive number) left shift (normal, bedeutet max fraction bei Control ist größer als max fraction bei RNase)
'<' 0: (negative number) right shift (ungewöhnlich, bedeutet RNase Fraktion ist größer als Control fraktion, Protein ist irgendwie schwerer geowrden)


```{r}
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))

# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"

# Print the new dataframe
print(shift_dataframe)

#Von Jimena: as.vector(Ctrl_fraction_max) -as.vector(RNase_fraction_max)
```

```{r}
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
```
Nice :)

## 13. Old data preparation

```{r}
#die einzelnen Dataframes skalieren und neuen dataframes zuweisen und im Code danach anpassen

#sc_max_shift <- scale(max_shift, center = FALSE, scale = FALSE)
#sc_identical_fractions2 <- scale(identical_fractions2, center = FALSE, scale = FALSE)
#sc_results_yshift <- scale(results_yshift, center = FALSE, scale = FALSE)
#quotients_max <- data.frame(quotients_minmax$Max)
#sc_quotients_minmax <- scale(quotients_max, center = FALSE, scale = FALSE)



#sc_max_shift <- as.data.frame(sapply(max_shift, function(i){(i/apply(max_shift,1,sum))*100}))

#sc_max_shift <- t(apply(max_shift, 1, min_max_scaling))
#sc_identical_fractions2 <- t(apply(identical_fractions2, 1, min_max_scaling))
#sc_results_yshift <- t(apply(results_yshift, 1, min_max_scaling))
#sc_quotients_minmax <- t(apply(quotients_minmax, 1, min_max_scaling))
```

```{r}
max_shift <- Ctrl_fraction_max - RNase_fraction_max

sc_max_shift <- data.frame(apply(max_shift, 2, function(x) {
  min_val <- min(x)
  max_val <- max(x)
  scaled_col <- 1 + 99 * (x - min_val) / (max_val - min_val)
  return(scaled_col) }))
print(sc_max_shift)
  
sc_identical_fractions2 <- data.frame(apply(identical_fractions2, 2, function(x) {
  min_val <- min(x)
  max_val <- max(x)
  scaled_col2 <- 1 + 99 * (x - min_val) / (max_val - min_val)
  return(scaled_col2) }))
print(sc_identical_fractions2)

sc_results_yshift <- data.frame(apply(results_yshift, 2, function(x) {
  min_val <- min(x)
  max_val <- max(x)
  scaled_col3 <- 1 + 99 * (x - min_val) / (max_val - min_val)
  return(scaled_col3) }))
print(sc_results_yshift)


quotients_max <- data.frame(quotients_minmax$Max)
sc_quotients_max <- data.frame(apply(quotients_max, 2, function(x) {
  min_val <- min(x)
  max_val <- max(x)
  scaled_col4 <- 1 + 99 * (x - min_val) / (max_val - min_val)
  return(scaled_col4) }))
print(sc_quotients_max)

```

In order to generate one big dataframe that sums up the values that we gained in our 4(?) methodes of RBP identification this data has to be brought into the right format

1. Größe des x-shift: max_shift <- Ctrl_fraction_max - RNase_fraction_max
2. Unterschied in Anzahl local maxima: identical_fractions2$local_shift (ggf problematisch da hier eine verschiebung der local maxima ignoriert wird)
3. Ausmaß des y-shift: results_yshift$YDiff

ggf. 4. column: maximaler/minimaler Kurven quotient?? Vereinfachend den max wert genommen, da dieser in erster Linie größer und somit ggf aussagekräftiger ist.

Testen ob ich z test überhaupt nehmen darf -> eher nein
```{r}
# Convert the table to a vector
values <- unlist(curve_quotients)
qqnorm(values)
qqline(values)
```

## 14 alter curve z shift
Alternative method to determine shifters via z-test (t test doesnt work bc in some rows the values do not vary enough). The z-test is a statistical test that compares a sample mean to a population mean, assuming a known standard deviation. It identifies values that significantly deviate from the expected value based on the given confidence interval.
```{r}
# Create a function to perform z-test for each value
perform_z_test <- function(value) {
  z_score <- (value - 1) / sd_value  # Calculate the z-score
  
  if (abs(z_score) > #1.96) {  # Assuming 95% confidence interval. If the absolute value of the z-score is greater than 1.96, it indicates that the value significantly differs from the expectation value.
                    1.645) {  # Assuming 90% confidence interval. The bigger the confidence interval, the more proteins are identified as shifters.
    return("shifter")
  } else {
    return("no shifter")
  }
}

# Calculate the standard deviation across the entire dataframe
sd_value <- sd(as.matrix(curve_quotients)) #shifter abhängig auch von der sd, hier über den gesamten Datensatz eine sd von 0.361562, je kleiner, desto näher nimmt man an sind die Werte aneinander, je größer, desto weiter entfernt.

# Apply the z-test function to each value in the dataframe
quotients_using_z <- apply(curve_quotients, 1, function(row) {
  result <- sapply(row, perform_z_test)
  if ("shifter" %in% result) {
    return("shifter")
  } else {
    return("no shifter")
  }
})

quotients_using_z <- data.frame(quotients_using_z)
colnames(quotients_using_z) <- "Result"
```

```{r}
# Print the count of "shifter" values
table(quotients_using_z$Result)["shifter"]
```
For example 5NT3A_HUMAN	is identified as a shifter here, but not in the first two methods. RDeep says it is a shifter though. not that bad so maybe?

```{r}
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = sc_max_shift,
                               local_shift = sc_identical_fractions2,
                               YDiff = sc_results_yshift,
                               curve_shift = sc_quotients_max,
                               row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"

# Print the shift_comparison dataframe
print(shift_comparison)

```


#### 4.4 y-shift VERALTET NACH FABIOS ARGUMENTATION

```{r}
# Function to calculate difference in y-values between global maxima
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
  # Select the specific row from both dataframes
  row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
  row_data_RNase <- Mitosis_RNase_mean[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_diff <- row_global_max_Ctrl - row_global_max_RNase

  # Return the difference in y-values
  return(y_diff)
}

# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)

# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDiff = results)

# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference 

#as.vector(results_yshift) #results as vector - maybe better to work with afterwards, if needed
```


## 5. Statistical analysis
### 5.1 kmeans
#### 5.1.3. For y-shift
```{r}
#need to generate new dataframe
  row_global_max_Ctrl <- apply(Mitosis_Ctrl_100, 1, max)
  row_global_max_RNase <- apply(Mitosis_RNase_100, 1, max)
  
results_yshift2 <- data.frame(row_global_max_Ctrl, row_global_max_RNase)
show(results_yshift2) 

fviz_nbclust(results_yshift2, kmeans, method='silhouette') #optimal number of cluster = 2

#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km_y <- kmeans(results_yshift2, centers = 2, nstart = 25)
#fviz_cluster(km_y, data = results_yshift2)

# Create a data frame with clustered data and cluster labels
clustered_data5 <- data.frame(results_yshift2, cluster = as.factor(km_y$cluster))
show(clustered_data5)

# Create a scatter plot using ggplot
dotplot5 <- ggplot(clustered_data5, aes(x = row_global_max_Ctrl, y = row_global_max_RNase, color = cluster)) +
  geom_point() +
  labs(title = "K-means Clustering for y-shift",
       x = "row_data_Ctrl",
       y = "row_data_RNase",
       color = "Cluster")

plot(dotplot5)
```

For 3 cluster
```{r}
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km3_y <- kmeans(results_yshift, centers = 3, nstart = 25)
#fviz_cluster(km_y, data = results_yshift)

# Create a data frame with clustered data and cluster labels
clustered_data6 <- data.frame(results_yshift, cluster = as.factor(km3_y$cluster))
show(clustered_data6)

# Create a scatter plot using ggplot
dotplot6 <- ggplot(clustered_data6, aes(x = row_global_max_Ctrl, y = row_global_max_RNase, color = cluster)) +
  geom_point() +
  labs(title = "K-means Clustering for y-shift",
       x = "GlobalMax_Ctrl",
       y = "GlobalMax_RNase",
       color = "Cluster")

plot(dotplot6)
```

###### 5.1.3.1 Description of cluster 2

Lets take a closter look at cluster 2, as those proteins seem to be "extrem y-shifters"
```{r}
# Extract the cluster assignments from the kmeans_result object
cluster_assignments <- km3_y$cluster

# Filter the dataframe based on the cluster assignment
cluster2_values <- results_yshift[cluster_assignments == 2, ]

# Print the values in Cluster 2
print(cluster2_values)

# Count the number of values in Cluster 2
num_cluster2_values <- nrow(cluster2_values)

# Print the count
print(num_cluster2_values)
```

So we have 4 "extrem y-shifters". Lets take a look at them

```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 4269     # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein

# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,40), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```


Auf diesen Grafiken sieht das auf jeden Fall nicht nach extrem-shifters auf

### other correlation
```{r}
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)

# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)

# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)

# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
     xlab = "Observations", ylab = "Distance",
     labels = FALSE, hang = -1, cex = 0.8)

# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)  
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
     #srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)

# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)

# Create an empty list to store split data
split_data <- list()

# Split each column based on cluster assignments
for (col in colnames(maximum_fraction)) {
  split_data[[col]] <- split(maximum_fraction[[col]], as.factor(clusters))
}

# Create a dataframe with each cluster as a column
cluster_dataframe <- do.call(cbind, split_data)

# Print the cluster dataframe
print(cluster_dataframe)

```

```{r}
#Rows in which both Control and RNase p-values exceed 5%:
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 & RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
#length(bad_proteins5)

#Alternative 5%/10% BUT THIS RESULTS IN ANTOHER VALUE, WHY? I DO NOT KNOW.
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.05)
bad_proteins10wierd <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.1)
```

