---
title: "Old code"
author: "Orrego Chong, Kantelhardt, Kornelius"
date: "2023-06-08"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")

head(RDeeP_HeLa_Mitosis)
```

## Visualization

```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 1382  # Adjust the row index as needed
row_data <- Mitosis_Ctrl_100[row_index, ]
row_name <- row.names(Mitosis_Ctrl_100)[row_index]

# Step 2: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
  if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
    peaks <- c(peaks, i)
  }
}

# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)
```

#### Checking reproducibility with correlation?

-\> NOT RELEVANT IF T-TEST IS ACCEPTED.

Testing the correlation for the first three entries in our Control dataset. A possible idea is to apply this all on the entire dataset again, and then for example sort out all proteins in which the correlation between the fractions is less than 95%. This will then guarantee that all remaining fractions have a high correlation and thus a high reproducibility. But there is still a lot to do!

```{r}
# Calculate the pairwise correlations between the first three columns
cor_matrix_frac1 <- cor(RDeeP_HeLa_Mitosis_Ctrl[, 1:3], method = "pearson")

# Visualize the correlation matrix using a heatmap
heatmap(cor_matrix_frac1,
        col = colorRampPalette(c("blue", "white", "red"))(100),
        main = "Correlation Heatmap")

#Printing the correlation matrix as data frame
print(as.data.frame(cor_matrix_frac1))
```

#### Shift analysis old

Now the first idea is to start working on shift analysis. First step would be determine the fractions, in which the maximum peak is, and then substract the Control and RNase shifts. This all will be the easiest in proteins with one peak per Control/RNase.
FOR ONE PEAK PROTEINS:

```{r}
# Step 1: Create an empty vector to store the results
#one_peak_shifts <- vector("character", length = length(rows_with_one_peak))
#names(one_peak_shifts) <- rownames(Mitosis_Ctrl_100)[rows_with_one_peak]

#Doesn't matter if we take the row indexes from the control or RNase dataset, theoretically they should be identical. Testing my theory:
#nrow(Mitosis_Ctrl_100[rows_with_one_peak,])
#nrow(Mitosis_RNase_100[rows_with_one_peak,]) #--> works, is identical :)

# Get the row data from Mitosis_Ctrl_100 and Mitosis_RNase_100
row_data_ctrl <- Mitosis_Ctrl_100[rows_with_one_peak,]
row_data_rnase <- Mitosis_RNase_100[rows_with_one_peak,] #HERE IT SHOULD SAY RNASE, BUT THEN THE CODE DOESNT WORK AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHh
  
# Find the column index with the maximum value in each row
max_col_ctrl <- max.col(row_data_ctrl)
max_col_rnase <- max.col(row_data_rnase)

# Create an empty dataframe to store the results
result_df <- data.frame(Result = character(length(rows_with_one_peak)), stringsAsFactors = FALSE)
rownames(result_df) <- seq_along(rows_with_one_peak)

# Compare the elements of the vectors
comparison <- mapply(function(x, y) {
  diff <- x - y 
  
  if (diff < 0) {
    return("right shift")
  } else if (diff > 0) {
    return("left shift")
  } else {
    return("no shift")
  }
}, max_col_ctrl, max_col_rnase)

# Create the result dataframe
result_df <- data.frame(Result = comparison, row.names = seq_along(rows_with_one_peak))

# Print the result dataframe
print(result_df)
```

Also haven't managed to add the names, not sure how yet.

```{r}
# Count the occurrences of "left shift"
left_shift_count <- table(result_df$Result)["left shift"]
right_shift_count <- table(result_df$Result)["right shift"]
no_shift_count <- table(result_df$Result)["no shift"]

# Print the count
print(left_shift_count)
print(right_shift_count)
print(no_shift_count)
```
WELL in principle the code gives a close to right result, I haven't changed Ctrl to RNase yet, but that gives me an error, I do not know why.



##### Jimenas Old Code?

<<<<<<< Updated upstream
## 3.1 Specific visualization of proteins
=======
#### Attempt no.1

This code allows us to identify all rows with multiple peaks

```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks) #this is already a vector
rows_with_multiple_peaks


#rows_with_multiple_peaks_df <- data.frame(Row_Name = rownames(Mitosis_Ctrl_100), value = rows_with_multiple_peaks) 

#rows_with_multiple_peaks_df
#rownames(Mitosis_Ctrl_100 %in% rows_with_multiple_peaks)
```

Rows with just one peak still does not want to cooperate :l

```{r}
# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  # Extract the row
  row <- Mitosis_Ctrl_100[row_index, ]
  
  # Find the global maximum in the row
  global_max <- max(row)
  
  # Check if the row has only one peak
  has_one_peak <- sum(row == global_max) == 1 && all(diff(row) < 0)
  
  # Print the result for the current row
  print(paste("Row", row_index, "has one peak:", has_one_peak))
}



```

still does not cooperte

```{r}
# Create an empty list to store results
maxima_results <- list()

# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  row <- Mitosis_Ctrl_100[row_index, ]
  
  # Find the maximum value in the row
  max_value <- max(row)
  
  # Find the indices of maxima in the row
  max_indices <- which(row == max_value)
  
  # Check if each maximum is a global or local maximum
  max_types <- c()
  for (i in max_indices) {
    if (i > 1 && i < length(row)) {
      if (row[i] > row[i-1] && row[i] > row[i+1]) {
        max_types <- append(max_types, "Local")
      } else {
        max_types <- append(max_types, "Global")
      }
    } else {
      max_types <- append(max_types, "Global")
    }
  }
  
  # Store the results in the list
  maxima_results[[row_index]] <- data.frame(MaximaValue = row[max_indices], MaximaIndex = max_indices, MaximaType = max_types)
}

# Print the results
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  print(paste("Row", row_index, "Maxima:"))
  print(maxima_results[[row_index]])
}
```



Old attempt at using t test for curve quotient analysis, but variance is to small for t test to work.
```{r}
# Create an empty dataframe for curve_p_value
curve_p_value <- data.frame("P-value" = numeric(0), "Curve shifters" = character(0), stringsAsFactors = FALSE)

# Iterate over each row in curve_quotients
for (i in 1:nrow(curve_quotients)) {
  # Get the row values
  row_values <- curve_quotients[i, ]
  
  # Check for constant values in the row
  if (length(unique(row_values)) == 1) {
    # Skip the row if all values are constant
    next
  }
  
  # Perform one-sample t-test
  t_test <- t.test(row_values, mu = 1, alternative = "two.sided", conf.level = 0.95)
  
  # Extract the p-value
  p_value_row <- t_test$p.value
  
  # Assign shifter status based on p-value
  shifter <- ifelse(p_value_row < 0.05, "shifter", "no shifter")
  
  # Add the p-value and shifter status to the dataframe
  curve_p_value[i, "P-value"] <- p_value_row
  curve_p_value[i, "Curve shifters"] <- shifter
}

# Print the curve_p_value dataframe
print(curve_p_value)
```

#### Wilcoxon attemot
If the p-value is less than 0.95 (corresponding to a significance level of 0.05), it assigns the value "shifter" to indicate a significant difference from the mean of 1; otherwise, it assigns "no shifter".

```{r Wilcoxon signed rank test}
# Perform Wilcoxon signed rank test on each row
p_values <- apply(curve_quotients, 1, function(row) {
  wilcox.test(as.numeric(row), mu = 1, alternative = "two.sided", exact = FALSE)$p.value
})

# Create the curve_p_values dataframe
curve_p_values <- data.frame(
  p_value = p_values,
  stringsAsFactors = FALSE
)

# Add a column for Curve_shifters based on p-value significance level
curve_p_values$Curve_shifters <- ifelse(curve_p_values$p_value < 0.95, "shifter", "no shifter")

# Print the curve_p_values dataframe
print(curve_p_values)
```

```{r}
# Count the number of rows with NA values
sum(rowSums(is.na(curve_p_values)) > 0)
```
This doesn't seem to completely work yet. I'll stay on it though.



#### 9. Sylviane Parameters

Kmeans lost attempt

```{r}
#Versuch einen kmeans mit Max shift und Protein quotients zu machen
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
```

We want kmeans to consider different parameters for this we put them in a matrix. Here we create and normalize/scale the matrix:

```{r}
parameters <- cbind(maximum_fraction, quotients_minmax)

rownames(parameters) <- rownames(maximum_fraction)
```

#### 9.1 Sylviane kmeans - clustering

Now we cluster the proteins depending on their parameters:

```{r}
# n = Number of clusters
n <- 3
km.maxquo <- kmeans(parameters, centers = n, nstart = 100)
```

#### 9.2 Sylviane Plot

Let's plot the peaks against each other:

```{r}
cluster <- km.maxquo$cluster

#abhÃ¤ngig davon ob es drei oder vier cluster gibt werden unterschiedliche Vektoren verwendet:

if (n == 3){
  col <- c("springgreen", "violetred1", "cyan")
  vjust <- c(1, -0.5, -0.5)
  labels <- c("no shift", "left shift", "right shift")
}
if (n == 4){
  col <- c("springgreen", "violetred1", "cyan", "orange")
  vjust <- c(-0.5, -0.5, -0.5, -0.5)
  labels <- c("left shift", "right shift", "no shift", "precipitated")
}

library("ggplot2")

#hier wird ein Datframe mit allen fÃ¼r den dotplot relevanten daten erstellt
peaks <- data.frame(Ctrl_fraction_max, RNase_fraction_max, cluster)


#fÃ¼r den barplot muss der auch die Ergebnisse des Clusterings als Dataframe dargestellt werden
number.of.clusters <- data.frame(value = cluster)

#das cluster muss als factor dargestellt sein, vector geht nicht
peaks$cluster <- factor(peaks$cluster)

#hier wird der dotplot erstellt der die peaks gegeneinander auftrÃ¤gt. Die Punkte werden abhÃ¤ngig von ihrer shiftart eingefÃ¤rbt
dot.plot <- ggplot(peaks, aes(Ctrl_fraction_max,RNase_fraction_max)) + 
  geom_point(aes(colour = cluster), shape = 19, alpha = 0.5, size = 2)+
  labs(x = "Fraction of Control Peak", y = "Fraction of RNase Peak", title = "Peak distribution")+
  coord_equal()+
  scale_colour_manual(values = col,labels = labels)+
  theme_light()


# hier wird ein Barplot erstellt der anzeigt, wie oft die shifttypes jeweils vorkommen
bar.plot <- ggplot(number.of.clusters, aes(factor(value)))+
  geom_bar(fill = col
           , width = 0.5)+
  theme_minimal()+
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_rect(color = "grey", fill = NA),
        panel.background = element_rect(fill = "white", colour = NA))+
  geom_text(stat = 'count', 
            aes(label = after_stat(count)), 
            vjust = vjust, 
            size = 2.5)

#hier werden die beiden plots zusammengefÃ¼gt. Der barplot wird unten rechts klein angezeigt
dot.plot +
  annotation_custom(grob = ggplotGrob(bar.plot), 
                    xmin = 15, 
                    xmax = 27, 
                    ymin = -1, 
                    ymax = 8)
```


Saving space for the old, inefficient t-test code:

```{r}
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Extract the values for the current row (protein)
  row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
  
  # Create an empty vector to store the p-values for the current row (protein)
  p_values_row <- c()
  
  # Iterate over every three columns in the current row (protein)
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Extract the values for the current set of three columns
    column_values <- row_values[j:(j + 2)]
    
    # Calculate the p-value for the set of three columns using t-test
    t_result <- t.test(column_values)
    p_value <- t_result$p.value
    
    # Append the p-value to the vector for the current row (protein)
    p_values_row <- c(p_values_row, p_value)
  }
  
  # Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
  p_values_Ctrl[i, ] <- p_values_row
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))

# Print the new dataframe
print(p_values_Ctrl)
```


## 10. COMPARISON TO OTHER DATA

Furthermore, we added data on previously found RBPs and non-RBPs.

```{r Load extra data for comparison of results}
HS_RBPs <- read.csv("https://raw.githubusercontent.com/datascience-mobi-2022/2022-topic-03-team-03/main/1_HS_RBPs.csv", header=TRUE, sep = ",")

HS_non_RBPs <- read.csv("https://raw.githubusercontent.com/datascience-mobi-2022/2022-topic-03-team-03/main/2_HS_non_RBPs.csv", header=TRUE, sep = ",")
```

```{r Quantification of results functions}
# Function to identify True RBP
Find_true_RBP <- function(potential_RBP) {
  Match_RBP <- HS_RBPs$Entry_Name.x %in% potential_RBP    # Compare potential RBP with RBP from other publications
  True_RBP_pos <- which(Match_RBP == TRUE)                # Find the positions of true RBP
  True_RBP_names <- HS_RBPs$Entry_Name.x[True_RBP_pos]    # Find names of true RBP
  return(True_RBP_names)
}

# Function to identify False RBP
Find_false_RBP <- function(potential_RBP) {                    
  Match_RBP <- HS_non_RBPs$Entry_Name.x %in% potential_RBP      # Compare potential RBP with RBP from other publications
  False_RBP_pos <- which(Match_RBP == TRUE)                     # Find the positions of false RBP
  False_RBP_names <- HS_non_RBPs$Entry_Name.x[False_RBP_pos]    # Find names of false RBP
  return(False_RBP_names)
}

# Function to identify true non-RBP
Find_true_non_RBP <- function(potential_non_RBP) {
  Match_non_RBP <- HS_non_RBPs$Entry_Name.x %in% potential_non_RBP    # Compare potential non-RBP with non-RBP from other publications
  True_non_RBP_pos <- which(Match_non_RBP == TRUE)                    # Find the positions of true non-RBP
  True_non_RBP_names <- HS_non_RBPs$Entry_Name.x[True_non_RBP_pos]    # Find names of true non-RBP
  return(True_non_RBP_names)
}

# Function to identify false non-RBP
Find_false_non_RBP <- function(potential_non_RBP) {
  Match_non_RBP <- HS_RBPs$Entry_Name.x %in% potential_non_RBP    # Compare potential non-RBP with non-RBP from other publications
  False_non_RBP_pos <- which(Match_non_RBP == TRUE)               # Find the positions of false non-RBP
  False_non_RBP_names <- HS_RBPs$Entry_Name.x[False_non_RBP_pos]   # Find names of false non-RBP
  return(False_non_RBP_names)
}
# Function to show RBDs
Find_RBD <- function(potential_RBD) {
  RBD_stat <- RBD_stat_non_RBP[rownames(RBD_stat_non_RBP) %in% potential_RBD, ]
  RBD_true_prot_df <- RBD_stat[RBD_stat$RBD_status == "RBD", ]
  RBD_true_prot_names <- rownames(RBD_true_prot_df)
  return(RBD_true_prot_names)
}
```

## 11. Yshift reste

## 12. Min Max scaling

This would be an alternative to the data scaling to 100 method. We rescale the values to a fixed range, typically between 0 and 1. The scaling process involves subtracting the minimum value from each value in the variable and then dividing by the range (maximum value minus the minimum value). This transformation ensures that all values are proportionally scaled within the specified range.

```{r Min Max scaling}
# Min-max scaling function
min_max_scaling <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column). 

#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling)) 

# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
```

We can later decide which method to chose.

## Visualization
```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 3388     # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein

# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,40), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```


#### Index finder (not visualization)

```{r}
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2

# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_index, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Find the row name
row_name <- row.names(Mitosis_Ctrl_100)[row_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))

```

The same as above, but for a protein name based search :)
```{r}
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "RBM3_HUMAN"

# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_name, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
```

#### Web search RNase peak finder
"Web search" for protein indices in the RNase Dataframe
```{r}
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2

# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_index, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Find the row name
row_name <- row.names(Mitosis_RNase_100)[row_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))

```

"Web search" for protein names in the RNase Dataframe
```{r}
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5E_HUMAN"

# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_name, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
```

#### useful peak finder?

Overview to know in which fraction the max was found. The vector should then help for further analysis.
Overview for Ctrl Dataframe.
```{r}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)

# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)

#Results as vector
as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max) 

```

Overview RNase Dataframe.
```{r}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_RNase_100)

# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)

#Results as vector
as.vector(RNase_fraction_max) #just numbers (aka fractions where max) 

```

And this is how I imagine we could detect shifts.
We subtract the value in Ctrl_fraction_max (Ctrl fraction where max) with the value in RNase_fraction_max (RNase fraction where max) . If the result:
'=' 0: no shift
'>' 0: (positive number) left shift (normal, bedeutet max fraction bei Control ist grÃ¶Ãer als max fraction bei RNase)
'<' 0: (negative number) right shift (ungewÃ¶hnlich, bedeutet RNase Fraktion ist grÃ¶Ãer als Control fraktion, Protein ist irgendwie schwerer geowrden)


```{r}
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))

# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"

# Print the new dataframe
print(shift_dataframe)

#Von Jimena: as.vector(Ctrl_fraction_max) -as.vector(RNase_fraction_max)
```

```{r}
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
```
Nice :)

## 13. Old data preparation

```{r}
#die einzelnen Dataframes skalieren und neuen dataframes zuweisen und im Code danach anpassen

#sc_max_shift <- scale(max_shift, center = FALSE, scale = FALSE)
#sc_identical_fractions2 <- scale(identical_fractions2, center = FALSE, scale = FALSE)
#sc_results_yshift <- scale(results_yshift, center = FALSE, scale = FALSE)
#quotients_max <- data.frame(quotients_minmax$Max)
#sc_quotients_minmax <- scale(quotients_max, center = FALSE, scale = FALSE)



#sc_max_shift <- as.data.frame(sapply(max_shift, function(i){(i/apply(max_shift,1,sum))*100}))

#sc_max_shift <- t(apply(max_shift, 1, min_max_scaling))
#sc_identical_fractions2 <- t(apply(identical_fractions2, 1, min_max_scaling))
#sc_results_yshift <- t(apply(results_yshift, 1, min_max_scaling))
#sc_quotients_minmax <- t(apply(quotients_minmax, 1, min_max_scaling))
```

```{r}
max_shift <- Ctrl_fraction_max - RNase_fraction_max

sc_max_shift <- data.frame(apply(max_shift, 2, function(x) {
  min_val <- min(x)
  max_val <- max(x)
  scaled_col <- 1 + 99 * (x - min_val) / (max_val - min_val)
  return(scaled_col) }))
print(sc_max_shift)
  
sc_identical_fractions2 <- data.frame(apply(identical_fractions2, 2, function(x) {
  min_val <- min(x)
  max_val <- max(x)
  scaled_col2 <- 1 + 99 * (x - min_val) / (max_val - min_val)
  return(scaled_col2) }))
print(sc_identical_fractions2)

sc_results_yshift <- data.frame(apply(results_yshift, 2, function(x) {
  min_val <- min(x)
  max_val <- max(x)
  scaled_col3 <- 1 + 99 * (x - min_val) / (max_val - min_val)
  return(scaled_col3) }))
print(sc_results_yshift)


quotients_max <- data.frame(quotients_minmax$Max)
sc_quotients_max <- data.frame(apply(quotients_max, 2, function(x) {
  min_val <- min(x)
  max_val <- max(x)
  scaled_col4 <- 1 + 99 * (x - min_val) / (max_val - min_val)
  return(scaled_col4) }))
print(sc_quotients_max)

```

In order to generate one big dataframe that sums up the values that we gained in our 4(?) methodes of RBP identification this data has to be brought into the right format

1. GrÃ¶Ãe des x-shift: max_shift <- Ctrl_fraction_max - RNase_fraction_max
2. Unterschied in Anzahl local maxima: identical_fractions2$local_shift (ggf problematisch da hier eine verschiebung der local maxima ignoriert wird)
3. AusmaÃ des y-shift: results_yshift$YDiff

ggf. 4. column: maximaler/minimaler Kurven quotient?? Vereinfachend den max wert genommen, da dieser in erster Linie grÃ¶Ãer und somit ggf aussagekrÃ¤ftiger ist.


```{r}
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = sc_max_shift,
                               local_shift = sc_identical_fractions2,
                               YDiff = sc_results_yshift,
                               curve_shift = sc_quotients_max,
                               row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"

# Print the shift_comparison dataframe
print(shift_comparison)

```

