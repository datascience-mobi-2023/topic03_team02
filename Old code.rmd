---
title: "Old code"
author: "Orrego Chong, Kantelhardt, Kornelius"
date: "2023-06-08"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")

head(RDeeP_HeLa_Mitosis)
```

## Visualization

```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 1382  # Adjust the row index as needed
row_data <- Mitosis_Ctrl_100[row_index, ]
row_name <- row.names(Mitosis_Ctrl_100)[row_index]

# Step 2: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
  if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
    peaks <- c(peaks, i)
  }
}

# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)
```

#### Gaussian attempt

"Shifters": Laut maiwen SIN3A und CASP7
"Non-shifters": ASNS (Asparagine synthetase), MCM2 (DNA replication licensing factor MCM2), etc.

```{r gaussian distribution}
# Step 1: Extract the row you want to fit the Gaussian to
row_data <- Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("CASP7_HUMAN")),]

# Step 2: Define the Gaussian function
gaussian <- function(x, mean, sd, amplitude) {
  amplitude * dnorm(x, mean, sd)
}

# Step 3: Define the negative log-likelihood (NLL) function
nll <- function(params, x, y) {
  mean <- params[1]
  sd <- params[2]
  amplitude <- params[3]
  
  y_pred <- gaussian(x, mean, sd, amplitude)
  -sum(log(y_pred + 1e-10))  # Adding a small value to avoid log(0)
}

# Step 4: Fit the Gaussian using optimization
nonzero_data <- row_data[row_data != 0]
nonzero_indices <- which(row_data != 0)

initial_params <- c(mean = mean(nonzero_data),
                    sd = sd(nonzero_data),
                    amplitude = max(nonzero_data))

fitted_params <- optim(par = initial_params,
                       fn = nll,
                       x = nonzero_indices,
                       y = nonzero_data,
                       method = "L-BFGS-B",
                       lower = c(-Inf, 0, 0),  # Lower bounds for parameters
                       upper = c(Inf, Inf, Inf))  # Upper bounds for parameters

mean_fitted <- fitted_params$par[1]
sd_fitted <- fitted_params$par[2]
amplitude_fitted <- fitted_params$par[3]

# Step 5: Visualize the original data and the fitted Gaussian
x_values <- seq(1, length(row_data), length.out = 100)
y_values <- gaussian(x_values, mean_fitted, sd_fitted, amplitude_fitted)

# Plot the data points and the fitted Gaussian curve
plot(seq_along(row_data), row_data, type = "p", col = "blue", xlab = "Index", ylab = "Value")
lines(x_values, y_values, col = "red")
```

Gauss Graph funktioniert nicht immer, nur bei manchen verteilungen! Vielleicht t-verteilung?

```{r t-distribution}
# Step 1: Extract the row you want to fit the t-distribution to
row_data <- Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100) == "CASP7_HUMAN"), ]

# Step 2: Define the t-distribution function
t_distribution <- function(x, df, mean, scale) {
  dt((x - mean) / scale, df) / scale
}

# Step 3: Define the negative log-likelihood (NLL) function
nll_t <- function(params, x, y) {
  df <- params[1]
  mean <- params[2]
  scale <- params[3]
  
  if (df <= 0 || scale <= 0) {
    return(Inf)  # Return infinite value if parameters are invalid
  }
  
  y_pred <- t_distribution(x, df, mean, scale)
  -sum(log(y_pred + 1e-10))  # Adding a small value to avoid log(0)
}

# Step 4: Fit the t-distribution using optimization
nonzero_data <- row_data[row_data != 0]
nonzero_indices <- which(row_data != 0)

initial_params <- c(df = 1,
                    mean = mean(nonzero_data),
                    scale = sd(nonzero_data))

fitted_params <- optim(par = initial_params,
                       fn = nll_t,
                       x = nonzero_indices,
                       y = nonzero_data,
                       method = "L-BFGS-B",
                       lower = c(0.01, -Inf, 0.01),  # Adjust parameter bounds if needed
                       upper = c(Inf, Inf, Inf))

df_fitted <- fitted_params$par[1]
mean_fitted <- fitted_params$par[2]
scale_fitted <- fitted_params$par[3]

# Step 5: Visualize the original data and the fitted t-distribution
x_values <- seq(1, length(row_data), length.out = 100)
y_values <- t_distribution(x_values, df_fitted, mean_fitted, scale_fitted)

# Plot the data points and the fitted t-distribution curve
plot(seq_along(row_data), row_data, type = "p", col = "blue", xlab = "Index", ylab = "Value",ylim=c(0,0.5))
lines(x_values, y_values, col = "red")

```

Funktioniert schonmal besser... Aber noch immer höchst ungünstig.


#### Checking reproducibility with correlation?

-\> NOT RELEVANT IF T-TEST IS ACCEPTED.

Testing the correlation for the first three entries in our Control dataset. A possible idea is to apply this all on the entire dataset again, and then for example sort out all proteins in which the correlation between the fractions is less than 95%. This will then guarantee that all remaining fractions have a high correlation and thus a high reproducibility. But there is still a lot to do!

```{r}
# Calculate the pairwise correlations between the first three columns
cor_matrix_frac1 <- cor(RDeeP_HeLa_Mitosis_Ctrl[, 1:3], method = "pearson")

# Visualize the correlation matrix using a heatmap
heatmap(cor_matrix_frac1,
        col = colorRampPalette(c("blue", "white", "red"))(100),
        main = "Correlation Heatmap")

#Printing the correlation matrix as data frame
print(as.data.frame(cor_matrix_frac1))
```

#### Shift analysis old

Now the first idea is to start working on shift analysis. First step would be determine the fractions, in which the maximum peak is, and then substract the Control and RNase shifts. This all will be the easiest in proteins with one peak per Control/RNase.
FOR ONE PEAK PROTEINS:

```{r}
# Step 1: Create an empty vector to store the results
#one_peak_shifts <- vector("character", length = length(rows_with_one_peak))
#names(one_peak_shifts) <- rownames(Mitosis_Ctrl_100)[rows_with_one_peak]

#Doesn't matter if we take the row indexes from the control or RNase dataset, theoretically they should be identical. Testing my theory:
#nrow(Mitosis_Ctrl_100[rows_with_one_peak,])
#nrow(Mitosis_RNase_100[rows_with_one_peak,]) #--> works, is identical :)

# Get the row data from Mitosis_Ctrl_100 and Mitosis_RNase_100
row_data_ctrl <- Mitosis_Ctrl_100[rows_with_one_peak,]
row_data_rnase <- Mitosis_RNase_100[rows_with_one_peak,] #HERE IT SHOULD SAY RNASE, BUT THEN THE CODE DOESNT WORK AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHh
  
# Find the column index with the maximum value in each row
max_col_ctrl <- max.col(row_data_ctrl)
max_col_rnase <- max.col(row_data_rnase)

# Create an empty dataframe to store the results
result_df <- data.frame(Result = character(length(rows_with_one_peak)), stringsAsFactors = FALSE)
rownames(result_df) <- seq_along(rows_with_one_peak)

# Compare the elements of the vectors
comparison <- mapply(function(x, y) {
  diff <- x - y 
  
  if (diff < 0) {
    return("right shift")
  } else if (diff > 0) {
    return("left shift")
  } else {
    return("no shift")
  }
}, max_col_ctrl, max_col_rnase)

# Create the result dataframe
result_df <- data.frame(Result = comparison, row.names = seq_along(rows_with_one_peak))

# Print the result dataframe
print(result_df)
```

Also haven't managed to add the names, not sure how yet.

```{r}
# Count the occurrences of "left shift"
left_shift_count <- table(result_df$Result)["left shift"]
right_shift_count <- table(result_df$Result)["right shift"]
no_shift_count <- table(result_df$Result)["no shift"]

# Print the count
print(left_shift_count)
print(right_shift_count)
print(no_shift_count)
```
WELL in principle the code gives a close to right result, I haven't changed Ctrl to RNase yet, but that gives me an error, I do not know why.



##### Jimenas Old Code?

<<<<<<< Updated upstream
## 3.1 Specific visualization of proteins
=======
#### Attempt no.1

This code allows us to identify all rows with multiple peaks

```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks) #this is already a vector
rows_with_multiple_peaks


#rows_with_multiple_peaks_df <- data.frame(Row_Name = rownames(Mitosis_Ctrl_100), value = rows_with_multiple_peaks) 

#rows_with_multiple_peaks_df
#rownames(Mitosis_Ctrl_100 %in% rows_with_multiple_peaks)
```

Rows with just one peak still does not want to cooperate :l

```{r}
# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  # Extract the row
  row <- Mitosis_Ctrl_100[row_index, ]
  
  # Find the global maximum in the row
  global_max <- max(row)
  
  # Check if the row has only one peak
  has_one_peak <- sum(row == global_max) == 1 && all(diff(row) < 0)
  
  # Print the result for the current row
  print(paste("Row", row_index, "has one peak:", has_one_peak))
}



```

still does not cooperte

```{r}
# Create an empty list to store results
maxima_results <- list()

# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  row <- Mitosis_Ctrl_100[row_index, ]
  
  # Find the maximum value in the row
  max_value <- max(row)
  
  # Find the indices of maxima in the row
  max_indices <- which(row == max_value)
  
  # Check if each maximum is a global or local maximum
  max_types <- c()
  for (i in max_indices) {
    if (i > 1 && i < length(row)) {
      if (row[i] > row[i-1] && row[i] > row[i+1]) {
        max_types <- append(max_types, "Local")
      } else {
        max_types <- append(max_types, "Global")
      }
    } else {
      max_types <- append(max_types, "Global")
    }
  }
  
  # Store the results in the list
  maxima_results[[row_index]] <- data.frame(MaximaValue = row[max_indices], MaximaIndex = max_indices, MaximaType = max_types)
}

# Print the results
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
  print(paste("Row", row_index, "Maxima:"))
  print(maxima_results[[row_index]])
}
```



Old attempt at using t test for curve quotient analysis, but variance is to small for t test to work.
```{r}
# Create an empty dataframe for curve_p_value
curve_p_value <- data.frame("P-value" = numeric(0), "Curve shifters" = character(0), stringsAsFactors = FALSE)

# Iterate over each row in curve_quotients
for (i in 1:nrow(curve_quotients)) {
  # Get the row values
  row_values <- curve_quotients[i, ]
  
  # Check for constant values in the row
  if (length(unique(row_values)) == 1) {
    # Skip the row if all values are constant
    next
  }
  
  # Perform one-sample t-test
  t_test <- t.test(row_values, mu = 1, alternative = "two.sided", conf.level = 0.95)
  
  # Extract the p-value
  p_value_row <- t_test$p.value
  
  # Assign shifter status based on p-value
  shifter <- ifelse(p_value_row < 0.05, "shifter", "no shifter")
  
  # Add the p-value and shifter status to the dataframe
  curve_p_value[i, "P-value"] <- p_value_row
  curve_p_value[i, "Curve shifters"] <- shifter
}

# Print the curve_p_value dataframe
print(curve_p_value)
```

#### Wilcoxon attemot
If the p-value is less than 0.95 (corresponding to a significance level of 0.05), it assigns the value "shifter" to indicate a significant difference from the mean of 1; otherwise, it assigns "no shifter".

```{r Wilcoxon signed rank test}
# Perform Wilcoxon signed rank test on each row
p_values <- apply(curve_quotients, 1, function(row) {
  wilcox.test(as.numeric(row), mu = 1, alternative = "two.sided", exact = FALSE)$p.value
})

# Create the curve_p_values dataframe
curve_p_values <- data.frame(
  p_value = p_values,
  stringsAsFactors = FALSE
)

# Add a column for Curve_shifters based on p-value significance level
curve_p_values$Curve_shifters <- ifelse(curve_p_values$p_value < 0.95, "shifter", "no shifter")

# Print the curve_p_values dataframe
print(curve_p_values)
```

```{r}
# Count the number of rows with NA values
sum(rowSums(is.na(curve_p_values)) > 0)
```
This doesn't seem to completely work yet. I'll stay on it though.

Kmeans lost attempt

```{r}
#Versuch einen kmeans mit Max shift und Protein quotients zu machen
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
```

#### Parameters

We want kmeans to consider different parameters for this we put them in a matrix. Here we create and normalize/scale the matrix:

```{r}
parameters <- cbind(maximum_fraction, quotients_minmax)

rownames(parameters) <- rownames(maximum_fraction)
```

#### 8.1.2. kmeans - clustering

Now we cluster the proteins depending on their parameters:

```{r}
# n = Number of clusters
n <- 3
km.maxquo <- kmeans(parameters, centers = n, nstart = 100)
```

#### 8.1.3. Plot

Let's plot the peaks against each other:

```{r}
cluster <- km.maxquo$cluster

#abhängig davon ob es drei oder vier cluster gibt werden unterschiedliche Vektoren verwendet:

if (n == 3){
  col <- c("springgreen", "violetred1", "cyan")
  vjust <- c(1, -0.5, -0.5)
  labels <- c("no shift", "left shift", "right shift")
}
if (n == 4){
  col <- c("springgreen", "violetred1", "cyan", "orange")
  vjust <- c(-0.5, -0.5, -0.5, -0.5)
  labels <- c("left shift", "right shift", "no shift", "precipitated")
}

library("ggplot2")

#hier wird ein Datframe mit allen für den dotplot relevanten daten erstellt
peaks <- data.frame(Ctrl_fraction_max, RNase_fraction_max, cluster)


#für den barplot muss der auch die Ergebnisse des Clusterings als Dataframe dargestellt werden
number.of.clusters <- data.frame(value = cluster)

#das cluster muss als factor dargestellt sein, vector geht nicht
peaks$cluster <- factor(peaks$cluster)

#hier wird der dotplot erstellt der die peaks gegeneinander aufträgt. Die Punkte werden abhängig von ihrer shiftart eingefärbt
dot.plot <- ggplot(peaks, aes(Ctrl_fraction_max,RNase_fraction_max)) + 
  geom_point(aes(colour = cluster), shape = 19, alpha = 0.5, size = 2)+
  labs(x = "Fraction of Control Peak", y = "Fraction of RNase Peak", title = "Peak distribution")+
  coord_equal()+
  scale_colour_manual(values = col,labels = labels)+
  theme_light()


# hier wird ein Barplot erstellt der anzeigt, wie oft die shifttypes jeweils vorkommen
bar.plot <- ggplot(number.of.clusters, aes(factor(value)))+
  geom_bar(fill = col
           , width = 0.5)+
  theme_minimal()+
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_rect(color = "grey", fill = NA),
        panel.background = element_rect(fill = "white", colour = NA))+
  geom_text(stat = 'count', 
            aes(label = after_stat(count)), 
            vjust = vjust, 
            size = 2.5)

#hier werden die beiden plots zusammengefügt. Der barplot wird unten rechts klein angezeigt
dot.plot +
  annotation_custom(grob = ggplotGrob(bar.plot), 
                    xmin = 15, 
                    xmax = 27, 
                    ymin = -1, 
                    ymax = 8)
```


Saving space for the old, inefficient t-test code:

```{r}
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Extract the values for the current row (protein)
  row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
  
  # Create an empty vector to store the p-values for the current row (protein)
  p_values_row <- c()
  
  # Iterate over every three columns in the current row (protein)
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Extract the values for the current set of three columns
    column_values <- row_values[j:(j + 2)]
    
    # Calculate the p-value for the set of three columns using t-test
    t_result <- t.test(column_values)
    p_value <- t_result$p.value
    
    # Append the p-value to the vector for the current row (protein)
    p_values_row <- c(p_values_row, p_value)
  }
  
  # Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
  p_values_Ctrl[i, ] <- p_values_row
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))

# Print the new dataframe
print(p_values_Ctrl)
```

