---
title: "Ideas and Experiments"
author: "Orrego Chong, Kantelhardt, Kornelius"
date: "2023-05-23"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")

head(RDeeP_HeLa_Mitosis)
```
```{r}
#Deleting the complete zero rows:
RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),]
```


### Student t-test 

```{r}
# Extract the first three values from the column
subset_values <- RDeeP_HeLa_Mitosis[1, 1:3]

# Perform the t-test
t_test_result <- t.test(subset_values)

# Print the t-test result
print(t_test_result)
```
### Reorder dataset

```{r}
RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])

#For RNase it is easier, because we now can just take all the row which were not taken in the first table. 
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]

head(RDeeP_HeLa_Mitosis_RNase)
```


## 2. Scale and Reduce Dataset

#### 2.1 Normalization (scaling, or z-transformation?)

Old complicated version for finding mean:

1. Create an empty dataframe to store the mean values
mean_values <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

2.Outer loop: Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Inner loop: Iterate over every three columns at a time
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Select the three columns for the current iteration
    selected_columns <- RDeeP_HeLa_Mitosis_Ctrl[i, j:(j + 2)]
    # Calculate the mean of the selected columns
    mean_value <- mean(selected_columns, na.rm = TRUE)
    # Assign the mean value to the corresponding cell in the mean_values dataframe
    mean_values[i, (j + 2) %/% 3] <- mean_value
  }
}

NEW VERSION:

```{r}
#First finding the mean of all three replicates for every fraction separately:
Mitosis_Ctrl_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
    apply(RDeeP_HeLa_Mitosis_Ctrl[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    #inner loop which calculates the mean for the three replicates, for each row anew. 
    
    }))

#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")

print(Mitosis_Ctrl_mean)
```

Now trying data scaling to 100:
```{r}
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))

head(Mitosis_Ctrl_100)

```
Seems to work? Now all the same for RNase:

```{r}
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(RDeeP_HeLa_Mitosis_RNase[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    }))

colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")


#Now scaling 
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))

head(Mitosis_RNase_100)

```


```{r}
#Then maybe applying the z transformation on each row was a whole, Control and RNase separate? Still needs a lot of refining...
#Mitosis_Ctrl_norm <- apply(t(Mitosis_Ctrl_mean),1, function(x)(x - mean(x)) / sd(x))

#transpose is necessary as "apply" is always iterates the command or each column 

head(Mitosis_Ctrl_mean)
```


Min Max scaling?
We rescale the values to a fixed range, typically between 0 and 1. The scaling process involves subtracting the minimum value from each value in the variable and then dividing by the range (maximum value minus the minimum value). This transformation ensures that all values are proportionally scaled within the specified range.


```{r}
# Min-max scaling function
min_max_scaling <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column). 

# Print the scaled data
View(Mitosis_Ctrl_MM)
```

We can later decide which method to chose. 


### Plot visulization ideas


##### Without Normalization
```{r}
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="SIN3B_HUMAN", ylim=c(0,180000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

```{r}
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN",ylim=c(0,1500000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

##### With Normailzation (scaling to 100)

Also added ylim
```{r}
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="SIN3B_HUMAN Normalized", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

```{r}
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("TARA_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="TARA_HUMAN Normailzed", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("TARA_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```
With this last plot we already see a potential problem, as Control and RNase seem to be identical after scaling? Confusion

##### With Normalization (min max scaling) 

```{r}
plot(1:25, Mitosis_Ctrl_MM[which(rownames(Mitosis_Ctrl_MM)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN MinMax",ylim=c(0,1))
lines(1:25, Mitosis_RNase_MM[which(rownames(Mitosis_RNase_MM)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```


#### PEAK ANALYSIS OLD

```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_mean)) {
  row_data <- Mitosis_Ctrl_mean[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks)
```

PROTEINS WITH A LOT OF PEAKS? AKA MORE THAN SEVEN
```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_mean)) {
  row_data <- Mitosis_Ctrl_mean[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {  #More than 1 peak, can be adjusted to different thresholds!
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks)
#rows_with_multiple_peaks
```


This code allows us to identify all rows with ONE peak each
```{r}
# Step 1: Create an empty vector to store the row indices with one peak
rows_with_one_peak <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {   #why here with MitosisCtrl100 and above with MitosisCtrlMean?? Should it not be the same for comparison?
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has only one peak
  if (length(peaks) == 1) {
    rows_with_one_peak <- c(rows_with_one_peak, row_index)
  }
}

# Step 5: Print the row indices with only one peak
length(rows_with_one_peak)  # Number of rows with one peak
#rows_with_one_peak  # Row indices with one peak
#head(rows_with_one_peak)

# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) == nrow(Mitosis_Ctrl_100) #FALSE, not all proteins have one peak or mulitple peaks
length(rows_with_multiple_peaks) + length(rows_with_one_peak)
nrow(Mitosis_Ctrl_100) #some proteins have not yet been identified

```
Mhmm, it is FALSE, so maybe:
This code allows us to indentify all rows without a peak:
```{r}
# Step 1: Create an empty vector to store the row indices with no peak
rows_with_no_peak <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) { #Ich habe das gleiche auch mit dem nicht "clean" dataframe durchgeführt, da waren es 100 Proteine, hier sind es jetzt 82. Also 18 davon hatten wir schon im Data cleanup gelöscht. 
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) { 
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has no peak
  if (length(peaks) == 0) {
    rows_with_no_peak <- c(rows_with_no_peak, row_index)
  }
}

# Step 5: Print the row indices with no peak
length(rows_with_no_peak)  # Number of rows with no peak #84
#what are rows with no peaks? Theoretically we already cleaned up the dataframe, should it not be free of 0 rows? #what does it mean (for our data) that the protein accumulates in the first/last fraction

# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) + length(rows_with_no_peak) == nrow(Mitosis_Ctrl_100)

```
YAY! Now it works!

Testing if all no peak proteins have their highest value in the first fraction:

```{r}
# Test maximum value is in the last fraction (column), this means the protein accumulated at the bottom
has_max_in_last_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
  max_index <- which.max(row)
  max_index == ncol(Mitosis_Ctrl_100)
})

# Test if maximum value is in the first fraction, protein accumulated and the top
has_max_in_first_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
  max_index <- which.max(row)
  max_index == 1
})

# Check if has_max_in_last_col and has_max_in_first_col are complementary
are_complementary <- all(has_max_in_last_col != has_max_in_first_col)
are_complementary #TRUE means the protein has accumulated in the last column
```

TRUE, this means all proteins without a peak have either accumulated in first or last fraction.
-> does it mean error? or normalization side effect? No.

## Visualization
```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 3388     # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein

# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,40), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```


#### Index finder (not visualization)

```{r}
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2

# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_index, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Find the row name
row_name <- row.names(Mitosis_Ctrl_100)[row_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))

```

The same as above, but for a protein name based search :)
```{r}
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "RBM3_HUMAN"

# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_name, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
```

#### Web search RNase peak finder
"Web search" for protein indices in the RNase Dataframe
```{r}
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2

# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_index, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Find the row name
row_name <- row.names(Mitosis_RNase_100)[row_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))

```

"Web search" for protein names in the RNase Dataframe
```{r}
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5E_HUMAN"

# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_name, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
```

#### useful peak finder?

Overview to know in which fraction the max was found. The vector should then help for further analysis.
Overview for Ctrl Dataframe.
```{r}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)

# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)

#Results as vector
as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max) 

```

Overview RNase Dataframe.
```{r}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_RNase_100)

# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)

#Results as vector
as.vector(RNase_fraction_max) #just numbers (aka fractions where max) 

```

And this is how I imagine we could detect shifts.
We subtract the value in Ctrl_fraction_max (Ctrl fraction where max) with the value in RNase_fraction_max (RNase fraction where max) . If the result:
'=' 0: no shift
'>' 0: (positive number) left shift (normal, bedeutet max fraction bei Control ist größer als max fraction bei RNase)
'<' 0: (negative number) right shift (ungewöhnlich, bedeutet RNase Fraktion ist größer als Control fraktion, Protein ist irgendwie schwerer geowrden)


```{r}
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))

# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"

# Print the new dataframe
print(shift_dataframe)

#Von Jimena: as.vector(Ctrl_fraction_max) -as.vector(RNase_fraction_max)
```

```{r}
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
```
Nice :)

## Statistical analysis

#### y- shifts

Detection of y-shifts aka difference between global max in Ctrl und global max in RNase.
We observe the changes of peaks in the Ctrl Dataframe (here Mitosis_mean) after the addition of RNase and thats why we calculate the shifts as: Ctrl - RNase
If the result is:
'=' 0: no shift 
'>' 0: (positive number) Ctrl peak is higher than RNase peak -> Down shift as Ctrl goes 'down' to RNase
'<' 0: (negative number) Ctrl peak is lower than RNase peak -> Up shift as Ctrl goes 'up' to RNase
```{r}
#Mitosis_Ctrl_clean
#Mitosis_Ctrl_mean 

# Row name for the desired row in both dataframes
row_name <- "2A5E_HUMAN"  # Replace with the desired row name aka protein

# Select the specific row from both dataframes
row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
row_data_RNase <- Mitosis_RNase_mean[row_name, ]

# Find the global maximum from the selected row in Ctrl
row_global_max_Ctrl <- max(row_data_Ctrl)

# Find the global maximum from the selected row in RNase
row_global_max_RNase <- max(row_data_RNase)

# Calculate the difference in y-values between the global maxima
y_diff <- row_global_max_Ctrl - row_global_max_RNase

# Print the global maximums and the difference in y-values
print(row_global_max_Ctrl) #max y Wert von Ctrl
print(row_global_max_RNase) #max y Wert von RNase
print(y_diff) # Ctrl - RNase

if(y_diff > 0) {print("Down shift")}
if(y_diff < 0) {print("Up shift")}
if(y_diff == 0) {print("No shift")}
```
Copied the 'protein web- search' to directly compare and see what our results of y-shifts mean
```{r}
# Step 1: Select a specific row by name
row_name <- "2A5E_HUMAN"

# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
row_data_RNase <- Mitosis_RNase_mean[row_name, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_mean[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,525000), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_mean[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)

max(Mitosis_Ctrl_mean[row_name, ])
max(Mitosis_RNase_mean[row_name, ])

```


Reeeeaaally big overview for all proteins: their  global max in Ctrl aka in RNase and the difference of this max.
```{r}
# Function to calculate global maxima and difference in y-values
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {        
  
  # Select the specific row from both dataframes
  row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
  row_data_RNase <- Mitosis_RNase_100[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_diff <- row_global_max_Ctrl - row_global_max_RNase

  # Return row name, global maxima, and difference in y-values
  return(c( GlobalMax_Ctrl = row_global_max_Ctrl, GlobalMax_RNase = row_global_max_RNase, YDiff = y_diff))
}

# Get the row names of Mitosis Ctrl Dataframe
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name and combine the results into a dataframe
results <- mapply(calculate_maxima_diff, row_names, MoreArgs = list(Mitosis_Ctrl_100, Mitosis_RNase_100), SIMPLIFY = FALSE)
                    #list(df1 = df1, df2 = df2), SIMPLIFY = FALSE)

# Convert the results into a dataframe
results_yshift <- do.call(rbind, results)

# Print the results
head(results_yshift)

##Here we go from vector to matrix to dataframe
# Convert the vector to a matrix with desired number of columns
num_cols <- 3  # Number of columns in the matrix
my_matrix <- matrix(results_yshift, ncol = num_cols)

# Extract two columns from the matrix
column1 <- my_matrix[, 1]
column2 <- my_matrix[, 2]

#Convert the first two columns of the matrix into a dataframe that we can use in kmeans
df_results_yshift <- data.frame(GlobalMax_Ctrl  = column1, GlobalMax_RNase  = column2)
show(df_results_yshift)
```

Calculates y-shifts and shows (only) the difference between Ctrl peaks and RNase peaks
```{r}

# Function to calculate difference in y-values between global maxima
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
  # Select the specific row from both dataframes
  row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
  row_data_RNase <- Mitosis_RNase_mean[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_diff <- row_global_max_Ctrl - row_global_max_RNase

  # Return the difference in y-values
  return(y_diff)
}

# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)

# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDiff = results)

# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference 

as.vector(results_yshift) #results as vector - maybe better to work with afterwards, if needed

```



## 3. Update LOCAL MAXIMA!

#### 3.1 Visualizer

```{r}
# Step 1: Select a specific row by name
row_name <- "ABCA1_HUMAN" #'ABT1_HUMAN' (right shifter) #'ABCF1_HUMAN' (left shifter) #UTP11_HUMAN PERCIPITATED PROTEIN?? #ehemals problematisch: SQOR_HUMAN

#WICHTIG: ABCA1_HUMAN... von welchem verfahren wird dies (wahrscheinlich korrekterweise) als shifter erkannt? Ist aber noch in keiner Datenbank drinnen...

# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)

# Step 5: Count the number of peaks
num_peaks_Ctrl <- length(peaks_Ctrl)
num_peaks_RNase <- length(peaks_RNase)

# Print the number of peaks
cat("Number of peaks in Control:", num_peaks_Ctrl, "\n")
cat("Number of peaks in RNase:", num_peaks_RNase, "\n")
```

#### 3.2 Alter code: SQOR_HUMAN Problem

TRUE: no shifter
FALSE: shifter

```{r}
# Step 1: Find column indices of local maxima in Mitosis_RNase_100
RNase_maxima <- apply(Mitosis_RNase_100, 1, function(row) {
  local_maxima <- which(row == max(row))
  return(local_maxima)
})

# Step 2: Create RNase_maxima dataframe with row names
RNase_maxima <- data.frame(Maxima = I(RNase_maxima), row.names = row.names(Mitosis_RNase_100))

# Step 3: Repeat the same process for Mitosis_Ctrl_100
Ctrl_maxima <- apply(Mitosis_Ctrl_100, 1, function(row) {
  local_maxima <- which(row == max(row))
  return(local_maxima)
})
Ctrl_maxima <- data.frame(Maxima = I(Ctrl_maxima), row.names = row.names(Mitosis_Ctrl_100))

# Step 4: Compare number of maxima and column indices between RNase_maxima and Ctrl_maxima
identical_fractions <- data.frame(no_shift = row.names(Mitosis_RNase_100), row.names = row.names(Mitosis_RNase_100), stringsAsFactors = FALSE)
identical_fractions$no_shift <- RNase_maxima$Maxima == Ctrl_maxima$Maxima & 
                             lengths(RNase_maxima$Maxima) == lengths(Ctrl_maxima$Maxima)

# Count the total number of maxima in RNase_maxima dataframe
rnase_maxima_count <- sum(lengths(RNase_maxima$Maxima))

# Count the total number of maxima in Ctrl_maxima dataframe
ctrl_maxima_count <- sum(lengths(Ctrl_maxima$Maxima))

# Check if the total number of maxima and column indices are identical
identical_fractions$no_shift <- identical_fractions$no_shift & rnase_maxima_count == ctrl_maxima_count
#DAS & IST HIER DER ENTSCHEIDENDE!

# Step 5: Print the identical_fractions dataframe
print(identical_fractions)

identical_fractions["SQOR_HUMAN",]
sum(identical_fractions$no_shift == FALSE)
```
#### 3.3 NEUER LOCAL MAX CODE -> schon rüberkopiert

Alles fertig ready für working code
```{r}
# Create an empty vector to store the results
results <- vector("logical", nrow(Mitosis_Ctrl_100))

# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
  # Get the row data for Ctrl and RNase
  row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
  row_data_RNase <- Mitosis_RNase_100[i, ]
  
  # Find the peaks in the row data for Ctrl
  peaks_Ctrl <- c()
  for (j in 2:(length(row_data_Ctrl) - 1)) {
    if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
      peaks_Ctrl <- c(peaks_Ctrl, j)
    }
  }
  
  # Find the peaks in the row data for RNase
  peaks_RNase <- c()
  for (j in 2:(length(row_data_RNase) - 1)) {
    if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
      peaks_RNase <- c(peaks_RNase, j)
    }
  }
  
  # Compare the peaks between Ctrl and RNase
  if (identical(peaks_Ctrl, peaks_RNase)) {
    results[i] <- TRUE
  } else {
    results[i] <- FALSE
  }
}

# Create a data frame with the results
result_df <- data.frame(identical_fractions = results, row.names = row.names(Mitosis_Ctrl_100))

# Print the result_df
print(result_df)

result_df["SQOR_HUMAN",] 
sum(result_df$identical_fractions == FALSE)
```

#### 3.4 LOCAL MAX CODE DER ANZAHL DES LOCAL SHIFTS IDENTIFIZIERT -> schon rüberkopiert

--> Hier wird jedoch nicht ein shift in den local maxima betrachtet, sondern nur ob mehr entstehen oder welche verschwinden zwischen Control und RNase. Dadurch werden ziemlich viele Proteine vernachlässigt, genauer gesagt 1570-900, also 670 Proteine werden dadurch nicht aufgeführt... Evt. später anpassen.

```{r}
# Create an empty vector to store the results
results <- vector("integer", nrow(Mitosis_Ctrl_100))

# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
  # Get the row data for Ctrl and RNase
  row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
  row_data_RNase <- Mitosis_RNase_100[i, ]
  
  # Find the peaks in the row data for Ctrl
  peaks_Ctrl <- c()
  for (j in 2:(length(row_data_Ctrl) - 1)) {
    if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
      peaks_Ctrl <- c(peaks_Ctrl, j)
    }
  }
  
  # Find the peaks in the row data for RNase
  peaks_RNase <- c()
  for (j in 2:(length(row_data_RNase) - 1)) {
    if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
      peaks_RNase <- c(peaks_RNase, j)
    }
  }
  
  # Calculate the difference in peak counts
  diff_peaks <- length(peaks_RNase) - length(peaks_Ctrl)
  
  # Store the difference in the results vector
  results[i] <- diff_peaks
}

# Create a data frame with the results
identical_fractions2 <- data.frame(local_shift = results, row.names = row.names(Mitosis_Ctrl_100))

# Print the identical_fractions dataframe
print(identical_fractions2)

# Count the number of entries not equal to zero in the no_shift column
sum(identical_fractions2$local_shift != 0)
```


## 4. VERGLEICH MIT RBP2GO

Übersicht:
##### absolute maxima shifts
shift_dataframe #right shift, left shift, no shift -> not usable
Sondern mit (wie Alexandra schon gemacht):
data.frame(Ctrl_fraction_max, RNase_fraction_max)

##### local maxima amount and location comparison
identical_fractions #TRUE: no shifter, FALSE: Shifter -> not really usable I think, directly already calculated into two categories

##### protein content quotiens 
quotients_minmax #Werte umdie 1, je mehr sie abweichen, desto eher sind es shifter -> usable? GGF hier einfach NUR DEN WERT NEHMEN, DER AM MEISTEN ABWEICHT!

##### y-shifts
results_yshift #relativ große und relativ unterschiedliche Werte

#### 4.1 RBP2GO Datensatz ins Rmd Laden:

```{r}
# Load a text file into R
#comparison_RBP = read.csv("https://www.dropbox.com/s/xpjob8g8flxl3ik/Table_HS_RBP.txt?dl=1", sep = "", header = T, row.names = 1)

# View the loaded data
#head(comparison_RBP)

#comparison_RBP1 <- read.delim("~/GitHub/topic03_team02/Datensatz_RBP2GO_Proteins.txt", row.names=1, comment.char="#") #-> nur local
```

Neue Tabellen laden: RBP und non_RBP aus verschiedenen Datenssätzen.
Vorsicht code braucht seeeehr lange...
```{r}
comparison_RBP = read.csv("https://www.dropbox.com/s/xpjob8g8flxl3ik/Table_HS_RBP.txt?dl=1", sep = "", header = T, row.names = 1)

comparison_RBP = comparison_RBP[order(row.names(comparison_RBP)),]

comparison_non_RBP = read.csv("https://www.dropbox.com/s/cgbrvponhw7arpt/Table_HS_Non_RBP.txt?dl=1", sep = "", header = T, row.names = 1)

comparison_non_RBP = comparison_non_RBP[order(row.names(comparison_non_RBP)),]

# View the loaded data
head(comparison_RBP)
```

Werte des aus den geladenen Tabellen nun in unseren shift_comparison datensatz laden (um Überschneidungen zu vermeiden habe ich einen neuen, namenähnlichen Datensatz erstellt.)
```{r}
shift_comparison_RBP2go <- shift_comparison
shift_comparison_RBP2go[, 5] = NA
colnames(shift_comparison_RBP2go) = c(colnames(shift_comparison_RBP2go)[-5], "RBP2GO_Score")

shift_comparison_RBP2go[which(rownames(shift_comparison_RBP2go) %in% rownames(comparison_RBP)), 5] = comparison_RBP[which(rownames(comparison_RBP) %in% rownames(shift_comparison_RBP2go)), 3]

shift_comparison_RBP2go[which(rownames(shift_comparison_RBP2go) %in% rownames(comparison_non_RBP)), 5] = comparison_non_RBP[which(rownames(comparison_non_RBP) %in% rownames(shift_comparison_RBP2go)), 3]

head(shift_comparison_RBP2go) #nice, klappt alles!
```

Frage ist jetzt, was wir damit sagen. dieser RBP2Go score gibt uns an, mit welcher Sicherheit die jeweiligen Proteine RBPs sind. 
-> Random Idee: Summe der RBP2Go scores von den von uns als RBP identifizierten Proteinen zusammenaddieren und die mit der der Summe der non-RBPs vergleichen... Idealerweise wäre die erste Summe deutlich größer. GGf je nach Methode einzeln? Dafür müsste man nochmal den Datenframe bei paar Methoden verändern though.
-> oder irgendetwas wie Marcel mit diesen True positive und false negative erstellen. Bin aber gerade etwas zu müde um zu verstehen wie ich das mit dem RBP2go score machen würde. ggf im Tutorium nachfragen.

Vergleich RBP2go scores im max-shift.

```{r}
# Initialize variables to store the sums
non_zero_sum <- sum(shift_comparison_RBP2go[, 5][shift_comparison_RBP2go[, 1] != 0], na.rm = TRUE)
zero_sum <- sum(shift_comparison_RBP2go[, 5][shift_comparison_RBP2go[, 1] == 0], na.rm = TRUE)

# Print the sums
cat("Sum of fifth column values when first column is not equal to zero:", non_zero_sum, "\n")
cat("Sum of fifth column values when first column is equal to zero:", zero_sum, "\n")

sum(is.na(shift_comparison_RBP2go[, 5]))
```
Mist. der Wert bei non-shifters (max_shift = 0) ist höher als bei den shifters. Scheint irgendwie doch nicht ganz so einfach zu funktionieren


## Liniear Regression

#### 5.1.Finden von zwei Spalten in einem Dataframe die eine möglichst lineare Beziehung haben

EInen passenden DF hierfür müsste noch erstellt werden
Idee: columns nach jeder unserer Methoden (4?) und wir finden so sozusagen die beiden Methoden die in größer Übereinstimmung RBPs bestimmt haben und wenden dann auf die LR an
Ich denke das wäre bei uns ziemlich cool, eben weil wir diese verschiedenen Methoden haben

Versuch den oben beschriebenen Datensatz zu erstellen:

1. Größe des x-shift: max_shift <- Ctrl_fraction_max - RNase_fraction_max
2. Unterschied in Anzahl local maxima: identical_fractions2$local_shift (ggf problematisch da hier eine verschiebung der local maxima ignoriert wird)
3. Ausmaß des y-shift: results_yshift$YDiff

ggf. 4. column: maximaler/minimaler Kurven quotient?? Vereinfachend den max wert genommen, da dieser in erster Linie größer und somit ggf aussagekräftiger ist.


```{r}
max_shift <- Ctrl_fraction_max - RNase_fraction_max

# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
                               local_shift = identical_fractions2$local_shift,
                               YDiff = results_yshift$YDiff,
                               curve_shift = quotients_minmax$Max,
                               row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"

# Print the shift_comparison dataframe
print(shift_comparison)

```


## Alexandras Code

```{r}
# Assuming you have a dataframe called 'my_data' with multiple columns

# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL

# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
  for (j in (i + 1):ncol(shift_comparison)) {
    # Extract the two columns
    col1 <- shift_comparison[, i]
    col2 <- shift_comparison[, j]
    
    # Calculate the Pearson correlation coefficient
    correlation <- cor(col1, col2, use = "pairwise.complete.obs")
    
    # Fit a linear model and calculate the residuals
    model <- lm(col2 ~ col1)
    residuals <- resid(model)
    
    # Check if the correlation is stronger than the previous best
    if (abs(correlation) > abs(best_correlation)) {
      best_correlation <- correlation
      best_fit <- list(col1 = col1, col2 = col2, residuals = residuals)
    }
  }
}

# Print the columns with the best linear relationship found
print(best_fit$col1)
print(best_fit$col2)

# Optionally, you can also inspect the residuals or other information
print(best_fit$residuals)

```

Verenas modifizierung des coolen codes!

```{r}
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""

# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
  for (j in (i + 1):ncol(shift_comparison)) {
    # Extract the two columns
    col1 <- shift_comparison[, i]
    col2 <- shift_comparison[, j]
    
    # Calculate the Pearson correlation coefficient
    correlation <- cor(col1, col2, use = "pairwise.complete.obs")
    
    # Check if the correlation is stronger than the previous best
    if (abs(correlation) > abs(best_correlation)) {
      best_correlation <- correlation
      best_col1_name <- names(shift_comparison)[i]
      best_col2_name <- names(shift_comparison)[j]
    }
  }
}

# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
```
Lustigerweise egal ob ich den Maximalen wert des Kurven Quotienten Codes nehme oder den minimalen, in beiden Fällen wird die höchste Korrelation zwischen dem curve_shift daten und den max_shift daten gefunden! Eigentlich sehr cool, nächster Schritt wäre dann die lineare Regression durchführen. (und aufräumen kann man immer, aber lieber nichts löschen, sondern vllt mit kurzer überschrift in den old code oder so.)




## Speicherung Alexandras Code zur Erstellung des result dataframes, aus Working code rüberkopiert:


To put all these values in a new DF we first need to make sure they have the right format:
```{r}
#str(max_shift)
#str(identical_fractions)
#str(results_yshift)
#str(quotients_minmax)

print(class(max_shift))
print(class(identical_fractions))
print(class(results_yshift))
print(class(df_results_yshift))
print(class(quotients_minmax))
#kann man später wieder löschen. Hab ich zum Verständnis gebraucht
```
```{r}
#to put everything into one big dataframe the seperate dataframes need to have the same amount of rows

print(nrow(max_shift))
print(nrow(identical_fractions))
print(nrow(df_results_yshift))
print(nrow(quotients_minmax))
#kann man später wieder löschen. Hab ich zum Verständnis gebraucht
```
Das hab ich gemacht weil beim zusammenführen er mir einen Error bringt der besagt das ich unterschiedlich viele rows habe. Plot twist: habe ich nicht
wtf?!
=> okay jetzt hab ich es: die Values müssen Zahlen sein und ein wenig anders angeordnet 
Ich guck mal oben im Code was wir alles für variablen und DF haben und welche jeweils am besten passen

```{r}
#for max shift
head(max_shift) #should be fine
colnames(max_shift) <- c("Diff_Max")

#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten

#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
  #oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
  #column1 <- my_matrix[, 3]
  #df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
  #head(df_results_yshift2)
#code das das hier zahlen gibt im Ideas

#for curve shift
Diff_quotient <- quotients_minmax$Max - quotients_minmax$Min
Diff_quotient <- data.frame(Diff_quotient)
head(Diff_quotient)
#SINN?!
```
Eine Sache die wir uns unbedingt noch überlegen müssen ist das am Ende alle diese Methoden ein RBP implizieren wenn die values hoch sind (bzw möglichst stark von 0 abweichen) und das value = 0 immer non-shifter impliziert. Aber das müsste passen

#####  6.1.2 generate die actual Dataframe
```{r}
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
                               local_shift = identical_fractions,
                               YDiff = df_diff_yshift,
                               curve_shift = Diff_quotient,
                               row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"

# Print the shift_comparison dataframe
print(shift_comparison)

```

