---
title: "Ideas and Experiments"
author: "Orrego Chong, Kantelhardt, Kornelius"
date: "2023-05-23"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")

head(RDeeP_HeLa_Mitosis)
```
```{r}
#Deleting the complete zero rows:
RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),]
```


### Student t-test 

```{r}
# Extract the first three values from the column
subset_values <- RDeeP_HeLa_Mitosis[1, 1:3]

# Perform the t-test
t_test_result <- t.test(subset_values)

# Print the t-test result
print(t_test_result)
```
### Reorder dataset

```{r}
RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])

#For RNase it is easier, because we now can just take all the row which were not taken in the first table. 
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]

head(RDeeP_HeLa_Mitosis_RNase)
```

Saving space for the old, inefficient t-test code:

```{r}
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Extract the values for the current row (protein)
  row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
  
  # Create an empty vector to store the p-values for the current row (protein)
  p_values_row <- c()
  
  # Iterate over every three columns in the current row (protein)
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Extract the values for the current set of three columns
    column_values <- row_values[j:(j + 2)]
    
    # Calculate the p-value for the set of three columns using t-test
    t_result <- t.test(column_values)
    p_value <- t_result$p.value
    
    # Append the p-value to the vector for the current row (protein)
    p_values_row <- c(p_values_row, p_value)
  }
  
  # Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
  p_values_Ctrl[i, ] <- p_values_row
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))

# Print the new dataframe
print(p_values_Ctrl)
```



## 2. Scale and Reduce Dataset

#### 2.1 Normalization (scaling, or z-transformation?)

Old complicated version for finding mean:

1. Create an empty dataframe to store the mean values
mean_values <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

2.Outer loop: Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Inner loop: Iterate over every three columns at a time
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Select the three columns for the current iteration
    selected_columns <- RDeeP_HeLa_Mitosis_Ctrl[i, j:(j + 2)]
    # Calculate the mean of the selected columns
    mean_value <- mean(selected_columns, na.rm = TRUE)
    # Assign the mean value to the corresponding cell in the mean_values dataframe
    mean_values[i, (j + 2) %/% 3] <- mean_value
  }
}

NEW VERSION:

```{r}
#First finding the mean of all three replicates for every fraction separately:
Mitosis_Ctrl_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
    apply(RDeeP_HeLa_Mitosis_Ctrl[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    #inner loop which calculates the mean for the three replicates, for each row anew. 
    
    }))

#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")

print(Mitosis_Ctrl_mean)
```

Now trying data scaling to 100:
```{r}
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))

head(Mitosis_Ctrl_100)

```
Seems to work? Now all the same for RNase:

```{r}
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(RDeeP_HeLa_Mitosis_RNase[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    }))

colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")


#Now scaling 
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))

head(Mitosis_RNase_100)

```


```{r}
#Then maybe applying the z transformation on each row was a whole, Control and RNase separate? Still needs a lot of refining...
#Mitosis_Ctrl_norm <- apply(t(Mitosis_Ctrl_mean),1, function(x)(x - mean(x)) / sd(x))

#transpose is necessary as "apply" is always iterates the command or each column 

head(Mitosis_Ctrl_mean)
```


Min Max scaling?
We rescale the values to a fixed range, typically between 0 and 1. The scaling process involves subtracting the minimum value from each value in the variable and then dividing by the range (maximum value minus the minimum value). This transformation ensures that all values are proportionally scaled within the specified range.


```{r}
# Min-max scaling function
min_max_scaling <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column). 

# Print the scaled data
View(Mitosis_Ctrl_MM)
```

We can later decide which method to chose. 


### Plot visulization ideas


##### Without Normalization
```{r}
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="SIN3B_HUMAN", ylim=c(0,180000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

```{r}
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN",ylim=c(0,1500000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

##### With Normailzation (scaling to 100)

Also added ylim
```{r}
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="SIN3B_HUMAN Normalized", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

```{r}
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("TARA_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="TARA_HUMAN Normailzed", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("TARA_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```
With this last plot we already see a potential problem, as Control and RNase seem to be identical after scaling? Confusion

##### With Normalization (min max scaling) 

```{r}
plot(1:25, Mitosis_Ctrl_MM[which(rownames(Mitosis_Ctrl_MM)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN MinMax",ylim=c(0,1))
lines(1:25, Mitosis_RNase_MM[which(rownames(Mitosis_RNase_MM)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```


#### PEAK ANALYSIS OLD

```{r}
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_mean)) {
  row_data <- Mitosis_Ctrl_mean[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has multiple peaks
  if (length(peaks) > 1) {
    rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
  }
}

# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks)
rows_with_multiple_peaks
```

This code allows us to identify all rows with ONE peak each
```{r}
# Step 1: Create an empty vector to store the row indices with one peak
rows_with_one_peak <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {   #why here with MitosisCtrl100 and above with MitosisCtrlMean?? Should it not be the same for comparison?
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) {
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has only one peak
  if (length(peaks) == 1) {
    rows_with_one_peak <- c(rows_with_one_peak, row_index)
  }
}

# Step 5: Print the row indices with only one peak
length(rows_with_one_peak)  # Number of rows with one peak
rows_with_one_peak  # Row indices with one peak
head(rows_with_one_peak)

# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) == nrow(Mitosis_Ctrl_100)
length(rows_with_multiple_peaks) + length(rows_with_one_peak) #7074 rows
nrow(Mitosis_Ctrl_100) #7158 rows

```
Mhmm, it is FALSE, so maybe:
This code allows us to indentify all rows without a peak:
```{r}
# Step 1: Create an empty vector to store the row indices with no peak
rows_with_no_peak <- c()

# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) { #Ich habe das gleiche auch mit dem nicht "clean" dataframe durchgeführt, da waren es 100 Proteine, hier sind es jetzt 82. Also 18 davon hatten wir schon im Data cleanup gelöscht. 
  row_data <- Mitosis_Ctrl_100[row_index, ]
  
  # Step 3: Find the peaks in the row data
  peaks <- c()
  for (i in 2:(length(row_data) - 1)) { 
    if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
      peaks <- c(peaks, i)
    }
  }
  
  # Step 4: Check if the row has no peak
  if (length(peaks) == 0) {
    rows_with_no_peak <- c(rows_with_no_peak, row_index)
  }
}

# Step 5: Print the row indices with no peak
length(rows_with_no_peak)  # Number of rows with no peak #84
#what are rows with no peaks? Theoretically we already cleaned up the dataframe, should it not be free of 0 rows? #what does it mean (for our data) that the protein accumulates in the first/last fraction

# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) + length(rows_with_no_peak) == nrow(Mitosis_Ctrl_100)

```
YAY! Now it works!

Testing if all no peak proteins have their highest value in the first fraction:

```{r}
# Test maximum value is in the last fraction (column), this means the protein accumulated at the bottom
has_max_in_last_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
  max_index <- which.max(row)
  max_index == ncol(Mitosis_Ctrl_100)
})

# Test if maximum value is in the first fraction, protein accumulated and the top
has_max_in_first_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
  max_index <- which.max(row)
  max_index == 1
})

# Check if has_max_in_last_col and has_max_in_first_col are complementary
are_complementary <- all(has_max_in_last_col != has_max_in_first_col)
are_complementary

plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)

```
TRUE, this means all proteins without a peak have either accumulated in first or last fraction.
-> does it mean error? or normalization side effect? No.

## Visualization
```{r}
# Step 1: Extract the row you want to find peaks in
row_index <- 477  # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein

# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,100), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```


#### Index finder (not visualization)

```{r}
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2

# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_index, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Find the row name
row_name <- row.names(Mitosis_Ctrl_100)[row_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))

```

The same as above, but for a protein name based search :)
```{r}
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5B_HUMAN"

# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_name, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
```

#### Web search RNase peak finder
"Web search" for protein indices in the RNase Dataframe
```{r}
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2

# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_index, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Find the row name
row_name <- row.names(Mitosis_RNase_100)[row_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))

```

"Web search" for protein names in the RNase Dataframe
```{r}
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5E_HUMAN"

# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_name, ]

# Find the column index of the global maximum
column_index <- which.max(row)

# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]

# Find the value corresponding to the column of the global maximum
value <- row[column_index]

# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
```

#### useful peak finder?

Overview to know in which fraction the max was found. The vector should then help for further analysis.
Overview for Ctrl Dataframe.
```{r}
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)

# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)

#Results as vector
as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max) 

```
Overview RNase Dataframe.
-> error in function: I don't know why, its the same code as above :'l
```{r}
# ERROR because we had RNAse rows with only zeros. I fixed that, for this code to run simply run the working code again. 

# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)

# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)

# Find the row names
row_names <- row.names(Mitosis_RNase_100)

# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind

# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)

#Results as vector
as.vector(RNase_fraction_max) #just numbers (aka fractions where max) 

```

And this is how I imagine we could detect shifts.
We subtract the value in Ctrl_fraction_max (Ctrl fraction where max) with the value in RNase_fraction_max (RNase fraction where max) . If the result:
'=' 0: no shift
'>' 0: (positive number) left shift (normal, bedeutet max fraction bei Control ist größer als max fraction bei RNase)
'<' 0: (negative number) right shift (ungewöhnlich, bedeutet RNase Fraktion ist größer als Control fraktion, Protein ist irgendwie schwerer geowrden)


```{r}
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))

# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"

# Print the new dataframe
print(shift_dataframe)

#Von Jimena: as.vector(Ctrl_fraction_max) -as.vector(RNase_fraction_max)
```

```{r}
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
```
Nice :)

## COMPARISON TO OTHER DATA

Furthermore, we added data on previously found RBPs and non-RBPs.

```{r Load extra data for comparison of results}
HS_RBPs <- read.csv("https://raw.githubusercontent.com/datascience-mobi-2022/2022-topic-03-team-03/main/1_HS_RBPs.csv", header=TRUE, sep = ",")

HS_non_RBPs <- read.csv("https://raw.githubusercontent.com/datascience-mobi-2022/2022-topic-03-team-03/main/2_HS_non_RBPs.csv", header=TRUE, sep = ",")
```

```{r Quantification of results functions}
# Function to identify True RBP
Find_true_RBP <- function(potential_RBP) {
  Match_RBP <- HS_RBPs$Entry_Name.x %in% potential_RBP    # Compare potential RBP with RBP from other publications
  True_RBP_pos <- which(Match_RBP == TRUE)                # Find the positions of true RBP
  True_RBP_names <- HS_RBPs$Entry_Name.x[True_RBP_pos]    # Find names of true RBP
  return(True_RBP_names)
}

# Function to identify False RBP
Find_false_RBP <- function(potential_RBP) {                    
  Match_RBP <- HS_non_RBPs$Entry_Name.x %in% potential_RBP      # Compare potential RBP with RBP from other publications
  False_RBP_pos <- which(Match_RBP == TRUE)                     # Find the positions of false RBP
  False_RBP_names <- HS_non_RBPs$Entry_Name.x[False_RBP_pos]    # Find names of false RBP
  return(False_RBP_names)
}

# Function to identify true non-RBP
Find_true_non_RBP <- function(potential_non_RBP) {
  Match_non_RBP <- HS_non_RBPs$Entry_Name.x %in% potential_non_RBP    # Compare potential non-RBP with non-RBP from other publications
  True_non_RBP_pos <- which(Match_non_RBP == TRUE)                    # Find the positions of true non-RBP
  True_non_RBP_names <- HS_non_RBPs$Entry_Name.x[True_non_RBP_pos]    # Find names of true non-RBP
  return(True_non_RBP_names)
}

# Function to identify false non-RBP
Find_false_non_RBP <- function(potential_non_RBP) {
  Match_non_RBP <- HS_RBPs$Entry_Name.x %in% potential_non_RBP    # Compare potential non-RBP with non-RBP from other publications
  False_non_RBP_pos <- which(Match_non_RBP == TRUE)               # Find the positions of false non-RBP
  False_non_RBP_names <- HS_RBPs$Entry_Name.x[False_non_RBP_pos]   # Find names of false non-RBP
  return(False_non_RBP_names)
}
# Function to show RBDs
Find_RBD <- function(potential_RBD) {
  RBD_stat <- RBD_stat_non_RBP[rownames(RBD_stat_non_RBP) %in% potential_RBD, ]
  RBD_true_prot_df <- RBD_stat[RBD_stat$RBD_status == "RBD", ]
  RBD_true_prot_names <- rownames(RBD_true_prot_df)
  return(RBD_true_prot_names)
}
```


## Statistical analysis

#### y- shifts

Detection of y-shifts aka difference between global max in Ctrl und global max in RNase.
We observe the changes of peaks in the Ctrl Dataframe (here Mitosis_mean) after the addition of RNase and thats why we calculate the shifts as: Ctrl - RNase
If the result is:
'=' 0: no shift 
'>' 0: (positive number) Ctrl peak is higher than RNase peak -> Down shift as Ctrl goes 'down' to RNase
'<' 0: (negative number) Ctrl peak is lower than RNase peak -> Up shift as Ctrl goes 'up' to RNase
```{r}
#Mitosis_Ctrl_clean
#Mitosis_Ctrl_mean 

# Row name for the desired row in both dataframes
row_name <- "2A5E_HUMAN"  # Replace with the desired row name aka protein

# Select the specific row from both dataframes
row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
row_data_RNase <- Mitosis_RNase_mean[row_name, ]

# Find the global maximum from the selected row in Ctrl
row_global_max_Ctrl <- max(row_data_Ctrl)

# Find the global maximum from the selected row in RNase
row_global_max_RNase <- max(row_data_RNase)

# Calculate the difference in y-values between the global maxima
y_diff <- row_global_max_Ctrl - row_global_max_RNase

# Print the global maximums and the difference in y-values
print(row_global_max_Ctrl)
print(row_global_max_RNase)
print(y_diff)

if(y_diff > 0) {print("Down shift")}
if(y_diff < 0) {print("Up shift")}
if(y_diff == 0) {print("No shift")}
```
Copied the 'protein web- search' to directly compare and see what our results of y-shifts mean
```{r}
# Step 1: Select a specific row by name
row_name <- "2A5E_HUMAN"

# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
row_data_RNase <- Mitosis_RNase_mean[row_name, ]

# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
  if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
    peaks_Ctrl <- c(peaks_Ctrl, i)
  }
}

peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
  if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
    peaks_RNase <- c(peaks_RNase, i)
  }
}

# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_mean[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,525000), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)

lines(1:25, Mitosis_RNase_mean[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)

max(Mitosis_Ctrl_mean[row_name, ])
max(Mitosis_RNase_mean[row_name, ])

```


Reeeeaaally big overview for all proteins: their  global max in Ctrl aka in RNase and the difference of this max.
```{r}
# Function to calculate global maxima and difference in y-values
calculate_maxima_diff <- function(row_name, df1, df2) {
  # Select the specific row from both dataframes
  row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
  row_data_RNase <- Mitosis_RNase_mean[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_diff <- row_global_max_Ctrl - row_global_max_RNase

  # Return row name, global maxima, and difference in y-values
  return(c( GlobalMax_Ctrl = row_global_max_Ctrl, GlobalMax_RNase = row_global_max_RNase, YDiff = y_diff))
}

# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name and combine the results into a dataframe
results <- mapply(calculate_maxima_diff, row_names, MoreArgs = list(df1 = df1, df2 = df2), SIMPLIFY = FALSE)

# Convert the results into a dataframe
results_yshift <- do.call(rbind, results)

# Print the results
print(results_yshift)

```

Calculates y-shifts and shows (only) the difference between Ctrl peaks and RNase peaks
```{r}

# Function to calculate difference in y-values between global maxima
calculate_maxima_diff <- function(row_name, df1, df2) {
  # Select the specific row from both dataframes
  row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
  row_data_RNase <- Mitosis_RNase_mean[row_name, ]

  # Find the global maximum from the selected row in df1
  row_global_max_Ctrl <- max(row_data_Ctrl)

  # Find the global maximum from the selected row in df2
  row_global_max_RNase <- max(row_data_RNase)

  # Calculate the difference in y-values between the global maxima
  y_diff <- row_global_max_Ctrl - row_global_max_RNase

  # Return the difference in y-values
  return(y_diff)
}

# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)

# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)

# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDiff = results)

# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference 

as.vector(results_yshift) #results as vector - maybe better to work with afterwards, if needed

```






