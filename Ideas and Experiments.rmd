---
title: "Ideas and Experiments"
author: "Orrego Chong, Kantelhardt, Kornelius"
date: "2023-05-23"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")

head(RDeeP_HeLa_Mitosis)
```
```{r}
#Deleting the complete zero rows:
RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),]
```


### Student t-test 

```{r}
# Extract the first three values from the column
subset_values <- RDeeP_HeLa_Mitosis[1, 1:3]

# Perform the t-test
t_test_result <- t.test(subset_values)

# Print the t-test result
print(t_test_result)
```
### Reorder dataset

```{r}
RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])

#For RNase it is easier, because we now can just take all the row which were not taken in the first table. 
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]

head(RDeeP_HeLa_Mitosis_RNase)
```

Saving space for the old, inefficient t-test code:

```{r}
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Extract the values for the current row (protein)
  row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
  
  # Create an empty vector to store the p-values for the current row (protein)
  p_values_row <- c()
  
  # Iterate over every three columns in the current row (protein)
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Extract the values for the current set of three columns
    column_values <- row_values[j:(j + 2)]
    
    # Calculate the p-value for the set of three columns using t-test
    t_result <- t.test(column_values)
    p_value <- t_result$p.value
    
    # Append the p-value to the vector for the current row (protein)
    p_values_row <- c(p_values_row, p_value)
  }
  
  # Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
  p_values_Ctrl[i, ] <- p_values_row
}

# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))

# Print the new dataframe
print(p_values_Ctrl)
```



## 2. Scale and Reduce Dataset

#### 2.1 Normalization (scaling, or z-transformation?)

Old complicated version for finding mean:

1. Create an empty dataframe to store the mean values
mean_values <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))

2.Outer loop: Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
  # Inner loop: Iterate over every three columns at a time
  for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
    # Select the three columns for the current iteration
    selected_columns <- RDeeP_HeLa_Mitosis_Ctrl[i, j:(j + 2)]
    # Calculate the mean of the selected columns
    mean_value <- mean(selected_columns, na.rm = TRUE)
    # Assign the mean value to the corresponding cell in the mean_values dataframe
    mean_values[i, (j + 2) %/% 3] <- mean_value
  }
}

NEW VERSION:

```{r}
#First finding the mean of all three replicates for every fraction separately:
Mitosis_Ctrl_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
    apply(RDeeP_HeLa_Mitosis_Ctrl[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    #inner loop which calculates the mean for the three replicates, for each row anew. 
    
    }))

#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")

print(Mitosis_Ctrl_mean)
```

Now trying data scaling to 100:
```{r}
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))

head(Mitosis_Ctrl_100)

```
Seems to work? Now all the same for RNase:

```{r}
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(RDeeP_HeLa_Mitosis_RNase[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
    }))

colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")


#Now scaling 
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))

head(Mitosis_RNase_100)

```


```{r}
#Then maybe applying the z transformation on each row was a whole, Control and RNase separate? Still needs a lot of refining...
#Mitosis_Ctrl_norm <- apply(t(Mitosis_Ctrl_mean),1, function(x)(x - mean(x)) / sd(x))

#transpose is necessary as "apply" is always iterates the command or each column 

head(Mitosis_Ctrl_mean)
```


Min Max scaling?
We rescale the values to a fixed range, typically between 0 and 1. The scaling process involves subtracting the minimum value from each value in the variable and then dividing by the range (maximum value minus the minimum value). This transformation ensures that all values are proportionally scaled within the specified range.


```{r}
# Min-max scaling function
min_max_scaling <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column). 

# Print the scaled data
View(Mitosis_Ctrl_MM)
```

We can later decide which method to chose. 


### Plot visulization ideas VERY MESSY


##### Without Normalization
```{r}
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="SIN3B_HUMAN", ylim=c(0,180000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```
```{r}
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN",ylim=c(0,1500000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

##### With Normailzation (scaling to 100)

Also added ylim
```{r}
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="SIN3B_HUMAN Normalized", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

```{r}
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("TARA_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="TARA_HUMAN Normailzed", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("TARA_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```
With this last plot we already see a potential problem, as Control and RNase seem to be identical after scaling? Confusion

##### With Normalization (min max scaling) 

```{r}
plot(1:25, Mitosis_Ctrl_MM[which(rownames(Mitosis_Ctrl_MM)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN MinMax",ylim=c(0,1))
lines(1:25, Mitosis_RNase_MM[which(rownames(Mitosis_RNase_MM)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
```

#### EXTRAS

"Shifters": Laut maiwen SIN3A und CASP7
"Non-shifters": ASNS (Asparagine synthetase), MCM2 (DNA replication licensing factor MCM2), etc.

```{r}
# Step 1: Extract the row you want to fit the Gaussian to
row_data <- Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("1433F_HUMAN")),]

# Step 2: Define the Gaussian function
gaussian <- function(x, mean, sd, amplitude) {
  amplitude * dnorm(x, mean, sd)
}

# Step 3: Define the negative log-likelihood (NLL) function
nll <- function(params, x, y) {
  mean <- params[1]
  sd <- params[2]
  amplitude <- params[3]
  
  y_pred <- gaussian(x, mean, sd, amplitude)
  -sum(log(y_pred + 1e-10))  # Adding a small value to avoid log(0)
}

# Step 4: Fit the Gaussian using optimization
nonzero_data <- row_data[row_data != 0]
nonzero_indices <- which(row_data != 0)

initial_params <- c(mean = mean(nonzero_data),
                    sd = sd(nonzero_data),
                    amplitude = max(nonzero_data))

fitted_params <- optim(par = initial_params,
                       fn = nll,
                       x = nonzero_indices,
                       y = nonzero_data,
                       method = "L-BFGS-B",
                       lower = c(-Inf, 0, 0),  # Lower bounds for parameters
                       upper = c(Inf, Inf, Inf))  # Upper bounds for parameters

mean_fitted <- fitted_params$par[1]
sd_fitted <- fitted_params$par[2]
amplitude_fitted <- fitted_params$par[3]

# Step 5: Visualize the original data and the fitted Gaussian
x_values <- seq(1, length(row_data), length.out = 100)
y_values <- gaussian(x_values, mean_fitted, sd_fitted, amplitude_fitted)

# Plot the data points and the fitted Gaussian curve
plot(seq_along(row_data), row_data, type = "p", col = "blue", xlab = "Index", ylab = "Value")
lines(x_values, y_values, col = "red")
```
Gauss Graph funktioniert nicht immer, nur bei manchen verteilungen! Vielleicht t-verteilung?

```{r}
# Step 1: Extract the row you want to fit the t-distribution to
row_data <- Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100) == "CASP7_HUMAN"), ]

# Step 2: Define the t-distribution function
t_distribution <- function(x, df, mean, scale) {
  dt((x - mean) / scale, df) / scale
}

# Step 3: Define the negative log-likelihood (NLL) function
nll_t <- function(params, x, y) {
  df <- params[1]
  mean <- params[2]
  scale <- params[3]
  
  if (df <= 0 || scale <= 0) {
    return(Inf)  # Return infinite value if parameters are invalid
  }
  
  y_pred <- t_distribution(x, df, mean, scale)
  -sum(log(y_pred + 1e-10))  # Adding a small value to avoid log(0)
}

# Step 4: Fit the t-distribution using optimization
nonzero_data <- row_data[row_data != 0]
nonzero_indices <- which(row_data != 0)

initial_params <- c(df = 1,
                    mean = mean(nonzero_data),
                    scale = sd(nonzero_data))

fitted_params <- optim(par = initial_params,
                       fn = nll_t,
                       x = nonzero_indices,
                       y = nonzero_data,
                       method = "L-BFGS-B",
                       lower = c(0.01, -Inf, 0.01),  # Adjust parameter bounds if needed
                       upper = c(Inf, Inf, Inf))

df_fitted <- fitted_params$par[1]
mean_fitted <- fitted_params$par[2]
scale_fitted <- fitted_params$par[3]

# Step 5: Visualize the original data and the fitted t-distribution
x_values <- seq(1, length(row_data), length.out = 100)
y_values <- t_distribution(x_values, df_fitted, mean_fitted, scale_fitted)

# Plot the data points and the fitted t-distribution curve
plot(seq_along(row_data), row_data, type = "p", col = "blue", xlab = "Index", ylab = "Value",ylim=c(0,1))
lines(x_values, y_values, col = "red")

```

Funktioniert schonmal besser...
God this is so much work AHHHHHHHHHHHHHHH

