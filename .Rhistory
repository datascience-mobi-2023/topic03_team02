show(results_yshift2)
fviz_nbclust(results_yshift2, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km_y <- kmeans(results_yshift2, centers = 2, nstart = 25)
#fviz_cluster(km_y, data = results_yshift2)
# Create a data frame with clustered data and cluster labels
clustered_data5 <- data.frame(results_yshift2, cluster = as.factor(km_y$cluster))
show(clustered_data5)
# Create a scatter plot using ggplot
dotplot5 <- ggplot(clustered_data5, aes(x = row_global_max_Ctrl, y = row_global_max_RNase, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "row_data_Ctrl",
y = "row_data_RNase",
color = "Cluster")
plot(dotplot5)
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km3_y <- kmeans(results_yshift, centers = 3, nstart = 25)
#fviz_cluster(km_y, data = results_yshift)
# Create a data frame with clustered data and cluster labels
clustered_data6 <- data.frame(results_yshift, cluster = as.factor(km3_y$cluster))
show(clustered_data6)
# Create a scatter plot using ggplot
dotplot6 <- ggplot(clustered_data6, aes(x = row_global_max_Ctrl, y = row_global_max_RNase, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "GlobalMax_Ctrl",
y = "GlobalMax_RNase",
color = "Cluster")
plot(dotplot6)
# Extract the cluster assignments from the kmeans_result object
cluster_assignments <- km3_y$cluster
# Filter the dataframe based on the cluster assignment
cluster2_values <- results_yshift[cluster_assignments == 2, ]
# Print the values in Cluster 2
print(cluster2_values)
# Count the number of values in Cluster 2
num_cluster2_values <- nrow(cluster2_values)
# Print the count
print(num_cluster2_values)
# Step 1: Extract the row you want to find peaks in
row_index <- 4269     # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein
# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,40), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Create an empty list to store split data
split_data <- list()
# Split each column based on cluster assignments
for (col in colnames(maximum_fraction)) {
split_data[[col]] <- split(maximum_fraction[[col]], as.factor(clusters))
}
# Create a dataframe with each cluster as a column
cluster_dataframe <- do.call(cbind, split_data)
# Print the cluster dataframe
print(cluster_dataframe)
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val) * 100
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) * 100 / (max_val - min_val)
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
View(row_data_Ctrl)
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) * 100 / (max_val - min_val)
scaled <- ifelse(is.na(x), NA, scaled) # Preserve NA values
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val)
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled <- scaled * 100  # Scale to the range of 0 to 100
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(lapply(shift_comparison, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val) * 100
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(lapply(shift_comparison, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val) * 100
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val)
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled <- scaled * 100  # Scale to the range of 0 to 100
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Apply min-max scaling to each column
# Load the 'scales' package
library(scales)
# Apply separate min-max scaling to each column
shift_comparison <- as.data.frame(lapply(shift_comparison, function(x) rescale(x, to = c(0, 100))))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- data.frame()
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
nrow(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
# Perform MinMax scaling on the 'max_shift' dataframe
scaled_col <- (max_shift[, 1] - min(max_shift[, 1])) / (max(max_shift[, 1]) - min(max_shift[, 1])) * 100
# Create a new dataframe with scaled column and preserved row names
scaled_df <- data.frame(Values = scaled_col, row.names = rownames(max_shift))
# Print the scaled dataframe
print(scaled_df)
shift_comparison <- data.frame(max_shift = scaled_df,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Apply separate scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val)
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled <- scaled * 100  # Scale to the range of 0 to 100
scaled
}))
# Print the original and scaled dataframes
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframe based on 'max_shift'
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
# Set the row names of the new dataframe
row.names(new_df) <- rownames(max_shift)
# Print the new dataframe
print(new_df)
shift_comparison <- data.frame(max_shift = new_df,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframe based on 'max_shift'
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
# Set the row names of the new dataframe
#row.names(new_df) <- rownames(max_shift)
shift_comparison <- data.frame(max_shift = new_df,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframe based on 'max_shift'
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == 0, 0, 1))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframes
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == TRUE, 0, 1))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
