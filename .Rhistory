#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling))
# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values,protein1_Ctrl_frac1,protein8_Ctrl_frac1,bad_proteins5)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein
# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Step 1: Select a specific row by name
row_name <- "2A5E_HUMAN"
# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
#as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind
# Print the results
# Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)
#Results as vector
#as.vector(RNase_fraction_max) #just numbers (aka fractions where max)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))
# Code which would assign a shift of 1 to "no shift": *HERE THE NUMBER CAN BE CHANGED!*
# shift_result <- ifelse((shift_result >= -1) & (shift_result <= 1), "no shift", ifelse(shift_result > 1, "left shift", "right shift"))
# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"
# Print the new dataframe
print(shift_dataframe)
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
# Step 1: Find column indices of local maxima in Mitosis_RNase_100
RNase_maxima <- apply(Mitosis_RNase_100, 1, function(row) {
local_maxima <- which(row == max(row))
return(local_maxima)
})
# Step 2: Create RNase_maxima dataframe with row names
RNase_maxima <- data.frame(Maxima = I(RNase_maxima), row.names = row.names(Mitosis_RNase_100))
# Step 3: Repeat the same process for Mitosis_Ctrl_100
Ctrl_maxima <- apply(Mitosis_Ctrl_100, 1, function(row) {
local_maxima <- which(row == max(row))
return(local_maxima)
})
Ctrl_maxima <- data.frame(Maxima = I(Ctrl_maxima), row.names = row.names(Mitosis_Ctrl_100))
# Step 4: Compare number of maxima and column indices between RNase_maxima and Ctrl_maxima
identical_fractions <- data.frame(Result = row.names(Mitosis_RNase_100), row.names = row.names(Mitosis_RNase_100), stringsAsFactors = FALSE)
identical_fractions$Result <- RNase_maxima$Maxima == Ctrl_maxima$Maxima &
lengths(RNase_maxima$Maxima) == lengths(Ctrl_maxima$Maxima)
# Step 5: Print the identical_fractions dataframe
print(identical_fractions)
print(shift_result)
#zuerst muss ein dataframe mit dem nummerischen Wert der Shifts generiert werden
#optimale Anzahl an clustern via silhouette method or elbow method.
#then a k-means clustering with the optimal amount of cluter and interpretation
#generate a dataframe that holds the nummeric data of the shift
shift_result_nummeric <- Ctrl_fraction_max - RNase_fraction_max
head(shift_result_nummeric)
#optimale Anzahl an clustern via silhouette method or elbow method.
#then a k-means clustering with the optimal amount of cluter and interpretation
#generate a dataframe that holds the nummeric data of the shift
shift_result_nummeric <- Ctrl_fraction_max - RNase_fraction_max
show(shift_result_nummeric)
#optimale Anzahl an clustern via silhouette method or elbow method.
#then a k-means clustering with the optimal amount of cluter and interpretation
#generate a dataframe that holds the nummeric data of the shift
shift_result_nummeric <- Ctrl_fraction_max - RNase_fraction_max
show(shift_result_nummeric)
#find the optimal amount of cluster before k-means
wss = sapply(1:7,function(k) {
kmeans(x=t(shift_result_nummeric), centers =k)$tot.withinss
})
#generate a dataframe that holds the nummeric data of the shift
shift_result_nummeric <- Ctrl_fraction_max - RNase_fraction_max
show(shift_result_nummeric)
#find the optimal amount of cluster before k-means
wss = sapply(1:7,function(k) {
kmeans(x=t(shift_result_nummeric), centers =k)$tot.withinss
})
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(shift_result_nummeric),
centers = 2,
nstart = 10)
#generate a dataframe that holds the nummeric data of the shift
shift_result_nummeric <- Ctrl_fraction_max - RNase_fraction_max
show(shift_result_nummeric)
#find the optimal amount of cluster before k-means
wss = sapply(1:7,function(k) {
kmeans(x=t(shift_result_nummeric), centers =k)
})
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
show(maxium_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
#shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))
# Code which would assign a shift of 1 to "no shift": *HERE THE NUMBER CAN BE CHANGED!*
shift_result <- ifelse((shift_result >= -1) & (shift_result <= 1), "no shift", ifelse(shift_result > 1, "left shift", "right shift"))
# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"
# Print the new dataframe
print(shift_dataframe)
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) = Ctrl_fraction_max, RNase_fraction_max
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) = Ctrl_fraction_max, RNase_fraction_max
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- ("Ctrl_fraction_max", "RNase_fraction_max")
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maxium_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maxium_fraction)
#find the optimal amount of cluster before k-means
wss = sapply(2:7,function(k) {
kmeans(x=t(maxium_fraction), centers =k)
})
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maxium_fraction)
#find the optimal amount of cluster before k-means
wss = sapply(2:7,function(k) {
kmeans(x=t(maxium_fraction), centers =k)
})
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maxium_fraction),
centers = 2,
nstart = 10)
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maxium_fraction),
centers = 1,
nstart = 10)
print(km)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maxium_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
km$tot.withinss
library(knitr)
library(rmdformats)
## Global options
options(max.print="120")
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE)
opts_knit$set(width=120)
dat = read.delim('https://tinyurl.com/y4fark9g')
# set the row names using the column id
rownames(dat) = dat$id
# now we remove some columns: first, we determine which column index corresponds to the column names id, bp.2s, bp.2d, time.ppn
i.remove = which(colnames(dat) %in% c("id","bp.2s", "bp.2d", "time.ppn"))
i.remove
# now remove these columns, using the - sign:
dat = dat[, -i.remove]
# we reorder the remaining columns, in order to put the categorical columns first, and numerical columns after
dat = dat[,c(8,6,11,9,10,14,15,2,5,1,3,4,12,13)]
# Go through each row and sum up all missing values
rmv.rows = apply(dat,1,function(x){sum(is.na(x))})
# see the number of missing values of the first rows:
head(rmv.rows)
# determine the row index of rows with 1 or more missing values
i.missing = which(rmv.rows >0)
head(i.missing)
# remove the rows which have more than one missing value
dat = dat[-i.missing,]
dat.num = dat[,4:14]
mean(dat$stab.glu)
median(dat$stab.glu)
quantile(dat$stab.glu)
# question 1
m.chol = mean(dat$chol,na.rm=TRUE)
# question 2
q.chol = quantile(dat$chol,probs= c(0.01,0.1,0.25,0.5,0.75,0.9,0.99))
# question 3 & 4
hist(dat$chol);abline(v=q.chol,lty=3,lwd=2,col='red')
# lwd = line width, lty = line type, col = color
plot(dat$stab.glu,dat$glyhb,
pch=20,
xlab='Stabilized glucose',
ylab='Glycosylated hemoglobin'
)
## compute the Pearson correlation
cor(dat$stab.glu,dat$glyhb,method='pearson')
##
## compute the Spearman correlation
cor(dat$stab.glu,dat$glyhb,method='spearman')
plot(rank(dat$stab.glu),rank(dat$glyhb),
pch=20,
xlab='Ranks Stabilized glucose',
ylab='Ranks Glycosylated hemoglobin'
)
# Question 1
plot(dat$hip,dat$waist,pch=19)
##
plot(rank(dat$hip),rank(dat$waist),pch=19)
##
cor(dat$hip,dat$waist,method='pearson')  ##Note: as Pearson is the default method, we do not need to explicitely indicate it!
cor(dat$hip,dat$waist,method='spearman')
# Question 2
all.cor = cor(dat.num)
head(all.cor)
## We can also plot a heatmap
pheatmap::pheatmap(all.cor)
# Question 3
min(all.cor)
i.min = which(all.cor == min(all.cor),arr.ind = TRUE)
## Beware that the matrix is symmetrical, so there are 2 entries with the min value!
## colum/row on the min entry
col.min = i.min[1,2]
row.min = i.min[1,1]
colnames(all.cor)[col.min]
rownames(all.cor)[row.min]
max(all.cor) # This will give a value of 1, as all diagonal values are 1, whcih is trivial
# we can put all diagonal values to NA
diag(all.cor) = NA
max(all.cor,na.rm=TRUE)
i.max = which(all.cor == max(all.cor,na.rm=TRUE),arr.ind = TRUE)
## Beware that the matrix is symmetrical, so there are 2 entries with the max value!
## colum/row on the min entry
col.max = i.max[1,2]
row.max = i.max[1,1]
colnames(all.cor)[col.max]
rownames(all.cor)[row.max]
pairs(dat.num, pch=20, cex=0.5, col="grey")
brca.exp = readRDS(url('https://www.dropbox.com/s/qububmfvtv443mq/brca.exp.rds?dl=1'))
dim(brca.exp)
brca.exp[1:10,1:10]
#brca.exp = readRDS("xxxx") # xxxx should be replaced with the path to the downloaded file!
apply(brca.exp,2,mean)
apply(brca.exp,2,median)
apply(brca.exp,2,sd)
m.genes = apply(brca.exp,1,mean)
M.genes = apply(brca.exp,1,median)
s.genes = apply(brca.exp,1,sd)
hist(M.genes,breaks=20)
hist(s.genes,breaks=20)
# mean standard deviation
S = mean(s.genes)
sum(s.genes<S)/length(s.genes)
brca.anno = readRDS(url('https://www.dropbox.com/s/z6bzwzgzdhky1qz/brca.anno.rds?dl=1'))
km = kmeans(x=t(brca.exp),
centers = 2,
nstart = 10)
km = kmeans(x=t(brca.exp),
centers = 2,
nstart = 10)
print(km)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maxium_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maxium_fraction),
centers = 2,
nstart = 10)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maxium_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maxium_fraction),
centers = 1,
nstart = 10)
print(km)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maxium_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maxium_fraction),
centers = 1,
nstart = 10)
print(km)
table(km$cluster)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maxium_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maxium_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maxium_fraction),
centers = 1,
nstart = 10)
#print(km)
table(km$cluster)
#find the optimal amount of cluster before k-means
km$tot.withinss
km$tot.withinss
wss = sapply(1:7,function(k) {
kmeans(x=t(maxium_fraction), centers =k)$tot.withinss
})
print(brca.exp)
head(brca.exp)
plot(maxium_fraction)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maxium_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction)
#find the optimal amount of cluster before k-means
km$tot.withinss
wss = sapply(1:7,function(k) {
kmeans(x=t(maximum_fraction), centers =k)$tot.withinss
})
plot(1:7,wss,type='b',pch=19,xlab="Number of clusters K",
ylab="Total within-clusters sum of squares")
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction)
#find the optimal amount of cluster before k-means
km$tot.withinss
wss = sapply(1:2,function(k) {
kmeans(x=t(maximum_fraction), centers =k)$tot.withinss
})
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction)
#find the optimal amount of cluster before k-means
kmeans(maximum_fraction)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maximum_fraction),
centers = 1,
nstart = 10)
#print(km)
table(km$cluster)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction)
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maximum_fraction),
centers = 1)
#print(km)
table(km$cluster)
print(km)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, title = maxima comparison)
plot(maximum_fraction)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = comparison of maxima)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#find the optimal amount of cluster before k-means
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maximum_fraction),
centers = 1)
table(km$cluster)
#find the optimal amount of cluster before k-means
fviz_nbclust(maximum_fraction, kmeans, method='silhouette')
#find the optimal amount of cluster before k-means
library(cluster)
fviz_nbclust(maximum_fraction, kmeans, method='silhouette')
silhouette(maximum_fraction)
install.packages("fviz_nbclust")
install.packages("factoextra")
library(factoextra)
fviz_nbclust(maximum_fraction, kmeans, method='silhouette')
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#find the optimal amount of cluster before k-means
#hier bin ich für die Funktion "fviz_nbclust" nicht darum gekommen das package factoextra zu installieren. Nach Alternativen suche ich noch
fviz_nbclust(maximum_fraction, kmeans, method='silhouette')
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maximum_fraction),
centers = 1)
table(km$cluster)
km = kmeans(x=t(maximum_fraction),
centers = 2)
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(x=t(maximum_fraction), k=2)
#then a k-means clustering with the optimal amount of cluster and interpretation
km = kmeans(maximum_fraction)
#find the optimal amount of cluster before k-means
#hier bin ich für die Funktion "fviz_nbclust" nicht darum gekommen das package factoextra zu installieren. Nach Alternativen suche ich noch
fviz_nbclust(maximum_fraction, kmeans, method='silhouette')
fviz_nbclust(maximum_fraction, kmeans, method='elbow')
fviz_nbclust(maximum_fraction, kmeans, method='wss')
fviz_nbclust(maximum_fraction, kmeans, method='wsgfd')
fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
km
fviz_cluster(km, data = maximum_fraction)
km3 <- kmeans(maximum_fraction, centers = 3, nstart = 25)
km3
fviz_cluster(km3, data = maximum_fraction)
km3 <- kmeans(maximum_fraction, centers = 3, nstart = 25)
km3
fviz_cluster(km3, data = maximum_fraction)
#macht vlt aus biologischer Sicht mehr Sinn. Würde das Clustering gerne nochmal nach Verenas Quotienten-Idee durchführen
