Mitosis_Ctrl_clean <- Mitosis_Ctrl_clean[!(rownames(Mitosis_Ctrl_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
Mitosis_RNase_clean <- Mitosis_RNase_clean[!(rownames(Mitosis_RNase_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
#First finding the mean of all three replicates for every fraction separately in our Mitosis_Ctrl_clean data:
Mitosis_Ctrl_mean = as.data.frame(
sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
apply(Mitosis_Ctrl_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
#inner loop which calculates the mean for the three replicates, for each row anew. and CAUTION: if we delete some rows, we might have to adjust the name of the dataframe.
}))
#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")
head(Mitosis_Ctrl_mean)
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))
head(Mitosis_Ctrl_100)
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
sapply(seq(0,72,3), function(i) {
apply(Mitosis_RNase_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
}))
colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
#Now scaling
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))
head(Mitosis_RNase_100)
# Min-max scaling function
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column).
#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling))
# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values,protein1_Ctrl_frac1,protein8_Ctrl_frac1,bad_proteins5)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein
# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Step 1: Select a specific row by name
row_name <- "2A5E_HUMAN" #'ABT1_HUMAN' (right shifter) #'ABCF1_HUMAN' (left shifter)
# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
#as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind
#Bei mir passt alles? Ist das noch aktuell? Wenn nein kommentare gern lÃ¶schen - Verena
# Print the results
# Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)
#Results as vector
#as.vector(RNase_fraction_max) #just numbers (aka fractions where max)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
#Code which would only assign a shift of 0 to no shift
#shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))
# Code which would assign a shift of 1 or less to "no shift": *HERE THE NUMBER CAN BE CHANGED!*
shift_result <- ifelse((shift_result >= -1) & (shift_result <= 1), "no shift", ifelse(shift_result > 1, "left shift", "right shift"))
# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"
# Print the new dataframe
print(shift_dataframe)
shift_dataframe["RBM3_HUMAN",] #RBM3 is a sure shifter, siehe graph etc. (aber auch komplex)
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
# Create an empty vector to store the results
results <- vector("logical", nrow(Mitosis_Ctrl_100))
# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
# Get the row data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
row_data_RNase <- Mitosis_RNase_100[i, ]
# Find the peaks in the row data for Ctrl
peaks_Ctrl <- c()
for (j in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
peaks_Ctrl <- c(peaks_Ctrl, j)
}
}
# Find the peaks in the row data for RNase
peaks_RNase <- c()
for (j in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
peaks_RNase <- c(peaks_RNase, j)
}
}
# Compare the peaks between Ctrl and RNase
if (identical(peaks_Ctrl, peaks_RNase)) {
results[i] <- TRUE
} else {
results[i] <- FALSE
}
}
# Create a data frame with the results
identical_fractions <- data.frame(no_shift = results, row.names = row.names(Mitosis_Ctrl_100))
# Print the identical_fractions dataframe
print(identical_fractions)
identical_fractions["SQOR_HUMAN",] #-> FALSE, thus this protein is rightly identified as a shifter
sum(identical_fractions$no_shift == FALSE) #-> 1570 proteins are identified as shifters
# Create an empty vector to store the results
results <- vector("integer", nrow(Mitosis_Ctrl_100))
# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
# Get the row data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
row_data_RNase <- Mitosis_RNase_100[i, ]
# Find the peaks in the row data for Ctrl
peaks_Ctrl <- c()
for (j in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
peaks_Ctrl <- c(peaks_Ctrl, j)
}
}
# Find the peaks in the row data for RNase
peaks_RNase <- c()
for (j in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
peaks_RNase <- c(peaks_RNase, j)
}
}
# Calculate the difference in peak counts
diff_peaks <- length(peaks_RNase) - length(peaks_Ctrl)
# Store the difference in the results vector
results[i] <- diff_peaks
}
# Create a data frame with the results
identical_fractions2 <- data.frame(local_shift = results, row.names = row.names(Mitosis_Ctrl_100))
# Print the identical_fractions dataframe
print(identical_fractions2)
# Count the number of entries not equal to zero in the no_shift column
sum(identical_fractions2$local_shift != 0)
# Create an empty dataframe to store the results
dodgy_proteins <- data.frame(Result = logical(nrow(shift_dataframe)), row.names = row.names(shift_dataframe))
# Iterate over the rows of shift_dataframe
for (row_name in row.names(shift_dataframe)) {
# Check if the row meets the criteria in shift_dataframe
if ((shift_dataframe[row_name, ] %in% c("right shift", "left shift")) & !identical_fractions[row_name, ]) {
# Assign TRUE to the corresponding row in dodgy_proteins
dodgy_proteins[row_name, ] <- TRUE #These proteins give different results in each method!!!
} else {
# Assign FALSE to the corresponding row in dodgy_proteins
dodgy_proteins[row_name, ] <- FALSE
}
}
# Print the dodgy_proteins dataframe
print(dodgy_proteins)
sum(dodgy_proteins$Result)
sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
#Count how many have been identified using the local fraction comparison method:
sum(!identical_fractions) #Checks all FALSE (aka shifters) results in the dataframe
# Calculate the curve quotients using vectorized operations
curve_quotients <- (Mitosis_Ctrl_100+1) / (Mitosis_RNase_100+1)
# Set the row names of curve_quotients
row.names(curve_quotients) <- row.names(Mitosis_Ctrl_100)
# Print the curve_quotients dataframe
print(curve_quotients)
# Create the shifting_quotients dataframe
shifting_quotients <- data.frame("Curve_shifters" = apply(curve_quotients, 1, function(row) {
if (any(row < (4/(4*1.3)) | row > 1.3)) { #Code so angepasst das direkt die Prozentzahlen eingetragen werden kÃ¶nnen. Alternatives Vorgehen: mit "signifikanter Abweichung" arbeiten. Aber wie definiert?)
"shifter"
} else {
"not shifter"
}
}))
# Print the shifting_quotients dataframe
print(shifting_quotients)
shifting_quotients["RBM3_HUMAN",] #RBM3 is a sure shifter, but a bit complex
sum(shifting_quotients$"Curve_shifters" == "shifter")
# Create a function to perform z-test for each value
perform_z_test <- function(value) {
z_score <- (value - 1) / sd_value  # Calculate the z-score
if (abs(z_score) > #1.96) {  # Assuming 95% confidence interval. If the absolute value of the z-score is greater than 1.96, it indicates that the value significantly differs from the expectation value.
1.645) {  # Assuming 90% confidence interval. The bigger the confidence interval, the more proteins are identified as shifters.
return("shifter")
} else {
return("no shifter")
}
}
# Calculate the standard deviation across the entire dataframe
sd_value <- sd(as.matrix(curve_quotients)) #shifter abhÃ¤ngig auch von der sd, hier Ã¼ber den gesamten Datensatz eine sd von 0.361562, je kleiner, desto nÃ¤her nimmt man an sind die Werte aneinander, je grÃ¶Ãer, desto weiter entfernt.
# Apply the z-test function to each value in the dataframe
quotients_using_z <- apply(curve_quotients, 1, function(row) {
result <- sapply(row, perform_z_test)
if ("shifter" %in% result) {
return("shifter")
} else {
return("no shifter")
}
})
quotients_using_z <- data.frame(quotients_using_z)
colnames(quotients_using_z) <- "Result"
# Print the count of "shifter" values
table(quotients_using_z$Result)["shifter"]
# Calculate the minimum and maximum values for each row in curve_quotients
quotients_minmax <- data.frame("Min" = apply(curve_quotients, 1, min), "Max" = apply(curve_quotients, 1, max), row.names = row.names(curve_quotients))
# Print the quotients_minmax dataframe
print(quotients_minmax)
# Function to calculate difference in y-values between global maxima #wo kommt die funktion her?
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
# Select the specific row from both dataframes #which one?
row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
row_data_RNase <- Mitosis_RNase_mean[row_name, ]
# Find the global maximum from the selected row in df1
row_global_max_Ctrl <- max(row_data_Ctrl)
# Find the global maximum from the selected row in df2
row_global_max_RNase <- max(row_data_RNase)
# Calculate the difference in y-values between the global maxima
y_diff <- row_global_max_Ctrl - row_global_max_RNase
# Return the difference in y-values
return(y_diff)
}
# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)
# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)
# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDiff = results)
# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference
#as.vector(results_yshift) #results as vector - maybe better to work with afterwards, if needed
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
#visualizing the result of kmeans
fviz_cluster(km, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)
# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data1, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot1)
#kmeans with same data but 3 cluster
km3 <- kmeans(maximum_fraction, centers = 3, nstart = 25)
#fviz_cluster(km3, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data2 <- data.frame(maximum_fraction, cluster = as.factor(km3$cluster))
show(clustered_data2)
# Create a scatter plot using ggplot
dotplot2 <- ggplot(clustered_data2, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot2)
#here we donÂ´t need to generate a new dataframe since we already have one we can work with
show(quotients_minmax)
#Calculate optimal number of cluster
fviz_nbclust(quotients_minmax, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
km_q <- kmeans(quotients_minmax, centers = 2, nstart = 25, algorithm = "MacQueen")
#visualizing the result of kmeans
km_q
#fviz_cluster(km_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data3 <- data.frame(quotients_minmax, cluster = as.factor(km_q$cluster))
show(clustered_data3)
# Create a scatter plot using ggplot
dotplot3 <- ggplot(clustered_data3, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot3)
km3_q <- kmeans(quotients_minmax, centers = 3, nstart = 25)
#fviz_cluster(km3_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data4 <- data.frame(quotients_minmax, cluster = as.factor(km3_q$cluster))
show(clustered_data4)
# Create a scatter plot using ggplot
dotplot4 <- ggplot(clustered_data4, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot4)
#need to generate new dataframe
row_global_max_Ctrl2 <- apply(Mitosis_Ctrl_mean, 1, max)
row_global_max_RNase2 <- apply(Mitosis_RNase_mean, 1, max)
results_yshift2 <- data.frame(row_global_max_Ctrl2, row_global_max_RNase2)
show(results_yshift2)
fviz_nbclust(results_yshift2, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km_y <- kmeans(results_yshift2, centers = 2, nstart = 25)
#fviz_cluster(km_y, data = results_yshift2)
# Create a data frame with clustered data and cluster labels
clustered_data5 <- data.frame(results_yshift2, cluster = as.factor(km_y$cluster))
show(clustered_data5)
# Create a scatter plot using ggplot
dotplot5 <- ggplot(clustered_data5, aes(x = row_global_max_Ctrl2, y = row_global_max_RNase2, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "row_data_Ctrl",
y = "row_data_RNase",
color = "Cluster")
plot(dotplot5)
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km3_y <- kmeans(results_yshift2, centers = 3, nstart = 25)
#fviz_cluster(km_y, data = results_yshift2)
# Create a data frame with clustered data and cluster labels
clustered_data6 <- data.frame(results_yshift2, cluster = as.factor(km3_y$cluster))
show(clustered_data6)
# Create a scatter plot using ggplot
dotplot6 <- ggplot(clustered_data6, aes(x = row_global_max_Ctrl2, y = row_global_max_RNase2, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "GlobalMax_Ctrl",
y = "GlobalMax_RNase",
color = "Cluster")
plot(dotplot6)
# Extract the cluster assignments from the kmeans_result object
cluster_assignments <- km3_y$cluster
# Filter the dataframe based on the cluster assignment
cluster2_values <- df_results_yshift[cluster_assignments == 2, ]
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram")
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Print the cluster assignments
print(clusters)
# Create a dotplot using ggplot
dotplot <- ggplot(sorted_data, aes(x = reorder(Cluster, desc(Cluster)), y = Value, color = Cluster)) +
geom_point(size = 3) +
labs(title = "Hierarchical Clustering - Dotplot", x = "Cluster", y = "Value") +
theme_minimal()
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram")
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Print the cluster assignments
print(clusters)
# Create a dataframe with cluster assignments
data_with_clusters <- cbind(distance_matrix, Cluster = clusters)
# Sort the dataframe by cluster assignments
sorted_data <- data_with_clusters[order(data_with_clusters$Cluster), ]
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram")
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Print the cluster assignments
print(clusters)
# Create a dataframe with cluster assignments
data_with_clusters <- data.frame(Value = distance_matrix$Value, Cluster = clusters)
head(distance_matrix)
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram")
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Print the cluster assignments
print(clusters)
# Create a dataframe with cluster assignments
data_with_clusters <- data.frame(Value = distance_matrix[, 1], Cluster = clusters)
type(hclust_result)
show(hclust_result)
