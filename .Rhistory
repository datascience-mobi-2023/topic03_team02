if (abs(z_score) > #1.96) {  # Assuming 95% confidence interval. If the absolute value of the z-score is greater than 1.96, it indicates that the value significantly differs from the expectation value.
1.645) {  # Assuming 90% confidence interval. The bigger the confidence interval, the more proteins are identified as shifters.
return("shifter")
} else {
return("no shifter")
}
}
# Calculate the standard deviation across the entire dataframe
sd_value <- sd(as.matrix(curve_quotients)) #shifter abhängig auch von der sd, hier über den gesamten Datensatz eine sd von 0.361562, je kleiner, desto näher nimmt man an sind die Werte aneinander, je größer, desto weiter entfernt.
# Apply the z-test function to each value in the dataframe
quotients_using_z <- apply(curve_quotients, 1, function(row) {
result <- sapply(row, perform_z_test)
if ("shifter" %in% result) {
return("shifter")
} else {
return("no shifter")
}
})
quotients_using_z <- data.frame(quotients_using_z)
colnames(quotients_using_z) <- "Result"
quotients_using_z
# Print the count of "shifter" values
table(quotients_using_z$Result)["shifter"]
# Calculate the minimum and maximum values for each row in curve_quotients
quotients_minmax <- data.frame("Min" = apply(curve_quotients, 1, min), "Max" = apply(curve_quotients, 1, max), row.names = row.names(curve_quotients))
# Print the quotients_minmax dataframe
print(quotients_minmax)
# Function to calculate global maxima and difference in y-values
calculate_maxima_diff <- function(row_name, df1, df2) {           #was sind df1 und df2
# Select the specific row from both dataframes
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]
# Find the global maximum from the selected row in df1
row_global_max_Ctrl <- max(row_data_Ctrl)
# Find the global maximum from the selected row in df2
row_global_max_RNase <- max(row_data_RNase)
# Calculate the difference in y-values between the global maxima
y_diff <- row_global_max_Ctrl - row_global_max_RNase
# Return row name, global maxima, and difference in y-values
return(c( GlobalMax_Ctrl = row_global_max_Ctrl, GlobalMax_RNase = row_global_max_RNase, YDiff = y_diff))
}
# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)
# Apply the function to each row name and combine the results into a dataframe
results <- mapply(calculate_maxima_diff, row_names, MoreArgs = list(df1 = df1, df2 = df2), SIMPLIFY = FALSE)
# Convert the results into a dataframe
results_yshift <- do.call(rbind, results)
# Print the results
head(results_yshift)
##Here we go from vector to matrix to dataframe
# Convert the vector to a matrix with desired number of columns
num_cols <- 3  # Number of columns in the matrix
my_matrix <- matrix(results_yshift, ncol = num_cols)
# Extract two columns from the matrix
column1 <- my_matrix[, 1]
column2 <- my_matrix[, 2]
#Convert the first two columns of the matrix into a dataframe that we can use in kmeans
df_results_yshift <- data.frame(GlobalMax_Ctrl  = column1, GlobalMax_RNase  = column2)
show(df_results_yshift)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#find the optimal amount of cluster before k-means
library(cluster)
library(ggplot2)
library(factoextra)
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
#visualizing the result of kmeans
km
fviz_cluster(km, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)
# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot1)
#kmeans with same data but 3 cluster
km3 <- kmeans(maximum_fraction, centers = 3, nstart = 25)
#fviz_cluster(km3, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data2 <- data.frame(maximum_fraction, cluster = as.factor(km3$cluster))
show(clustered_data2)
# Create a scatter plot using ggplot
dotplot2 <- ggplot(clustered_data2, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot2)
#here we don´t need to generate a new dataframe since we already have one we can work with
show(quotients_minmax)
#Calculate optimal number of cluster
fviz_nbclust(quotients_minmax, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
km_q <- kmeans(quotients_minmax, centers = 2, nstart = 25, algorithm = "MacQueen")
#visualizing the result of kmeans
km_q
#fviz_cluster(km_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data3 <- data.frame(quotients_minmax, cluster = as.factor(km_q$cluster))
show(clustered_data3)
# Create a scatter plot using ggplot
dotplot3 <- ggplot(clustered_data3, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot3)
km3_q <- kmeans(quotients_minmax, centers = 3, nstart = 25)
#fviz_cluster(km3_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data4 <- data.frame(quotients_minmax, cluster = as.factor(km3_q$cluster))
show(clustered_data4)
# Create a scatter plot using ggplot
dotplot4 <- ggplot(clustered_data4, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot4)
#here we don´t need to generate a new dataframe since we already have one we can work with
show(df_results_yshift)
fviz_nbclust(df_results_yshift, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km_y <- kmeans(df_results_yshift, centers = 2, nstart = 25)
#fviz_cluster(km_y, data = df_results_yshift)
# Create a data frame with clustered data and cluster labels
clustered_data5 <- data.frame(df_results_yshift, cluster = as.factor(km_y$cluster))
show(clustered_data5)
# Create a scatter plot using ggplot
dotplot5 <- ggplot(clustered_data5, aes(x = GlobalMax_Ctrl, y = GlobalMax_RNase, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "GlobalMax_Ctrl",
y = "GlobalMax_RNase",
color = "Cluster")
plot(dotplot5)
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km3_y <- kmeans(df_results_yshift, centers = 3, nstart = 25)
#fviz_cluster(km_y, data = df_results_yshift)
# Create a data frame with clustered data and cluster labels
clustered_data6 <- data.frame(df_results_yshift, cluster = as.factor(km3_y$cluster))
show(clustered_data6)
# Create a scatter plot using ggplot
dotplot6 <- ggplot(clustered_data6, aes(x = GlobalMax_Ctrl, y = GlobalMax_RNase, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "GlobalMax_Ctrl",
y = "GlobalMax_RNase",
color = "Cluster")
plot(dotplot6)
# Extract the cluster assignments from the kmeans_result object
cluster_assignments <- km3_y$cluster
# Filter the dataframe based on the cluster assignment
cluster2_values <- df_results_yshift[cluster_assignments == 2, ]
# Print the values in Cluster 2
print(cluster2_values)
# Count the number of values in Cluster 2
num_cluster2_values <- nrow(cluster2_values)
# Print the count
print(num_cluster2_values)
# Step 1: Extract the row you want to find peaks in
row_index <- 4269     # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein
# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,40), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
#1. Größe des x-shift: max_shift <- Ctrl_fraction_max - RNase_fraction_max
#2. Unterschied in Anzahl local maxima: identical_fractions2$local_shift (ggf problematisch da hier eine verschiebung der local maxima ignoriert wird)
#3. Ausmaß des y-shift: results_yshift$YDiff
#ggf. 4. column: maximaler/minimaler Kurven quotient?? Vereinfachend den max wert genommen, da dieser in erster Linie größer und somit ggf aussagekräftiger ist.
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2$local_shift,
YDiff = results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
YDiff = results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
str(max_shift)
str(identical_fractions2)
str(max_shift)
str(identical_fractions2)
str(results_yshift)
str(quotients_minmax)
s
print(class(max_shift))
#str(max_shift)
#str(identical_fractions2)
#str(results_yshift)
#str(quotients_minmax)
print(class(max_shift))
print(class(identical_fractions2))
print(class(results_yshift))
print(class(quotients_minmax))
print(class(identical_fractions))
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions$local_shift,
YDiff = results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
#str(max_shift)
#str(identical_fractions)
#str(results_yshift)
#str(quotients_minmax)
print(class(max_shift))
print(class(identical_fractions))
print(class(results_yshift))
print(class(quotients_minmax))
#str(max_shift)
#str(identical_fractions)
#str(results_yshift)
#str(quotients_minmax)
print(class(max_shift))
print(class(identical_fractions))
print(class(results_yshift))
print(class(df_results_yshift))
print(class(quotients_minmax))
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions$local_shift,
YDiff = df_results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
knitr::opts_chunk$set(echo = TRUE)
#1. Größe des x-shift: max_shift <- Ctrl_fraction_max - RNase_fraction_max
#2. Unterschied in Anzahl local maxima: identical_fractions2$local_shift (ggf problematisch da hier eine verschiebung der local maxima ignoriert wird)
#3. Ausmaß des y-shift: results_yshift$YDiff
#ggf. 4. column: maximaler/minimaler Kurven quotient?? Vereinfachend den max wert genommen, da dieser in erster Linie größer und somit ggf aussagekräftiger ist.
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions$local_shift,
YDiff = df_results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
knitr::opts_chunk$set(echo = TRUE)
#1. Größe des x-shift: max_shift <- Ctrl_fraction_max - RNase_fraction_max
#2. Unterschied in Anzahl local maxima: identical_fractions2$local_shift (ggf problematisch da hier eine verschiebung der local maxima ignoriert wird)
#3. Ausmaß des y-shift: results_yshift$YDiff
#ggf. 4. column: maximaler/minimaler Kurven quotient?? Vereinfachend den max wert genommen, da dieser in erster Linie größer und somit ggf aussagekräftiger ist.
max_shift <- Ctrl_fraction_max - RNase_fraction_max
#str(max_shift)
#str(identical_fractions)
#str(results_yshift)
#str(quotients_minmax)
print(class(max_shift))
print(class(identical_fractions))
print(class(results_yshift))
print(class(df_results_yshift))
print(class(quotients_minmax))
#to put everything into one big dataframe the seperate dataframes need to have the same amount of rows
print(nrow(max_shift))
print(nrow(identical_fractions))
print(nrow(df_results_yshift))
print(nrow(quotients_minmax))
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions$local_shift,
YDiff = df_results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions$local_shift,
YDiff = df_results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
# Print the shift_comparison dataframe
print(shift_comparison)
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions$local_shift,
YDiff = df_results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
print(identical_fractions$local_shift)
head(identical_fractions)
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions,
YDiff = df_results_yshift$YDiff,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
head(df_results_yshift)
head(max_shift)
head(identical_fractions)
head(df_results_yshift)
#for max shift
head(max_shift) #should be fine
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
#for curve shift
df_diff_yshift <- data.frame(Diff_yshift)
#for max shift
head(max_shift) #should be fine
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
#for curve shift
column1 <- my_matrix[, 3]
df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
show(df_results_yshift2)
#for max shift
head(max_shift) #should be fine
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
#oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
#Convert the last column of the matrix into a dataframe
column1 <- my_matrix[, 3]
df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
show(df_results_yshift2)
#for curve shift
#for max shift
head(max_shift) #should be fine
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
#oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
#Convert the last column of the matrix into a dataframe
column1 <- my_matrix[, 3]
df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
head(df_results_yshift2)
#for curve shift
head(quotients_minmax)
Diff_quotient <- quotients_minmax$Max - quotients_minmax$Min
Diff_quotient <- data.frame(Diff_yshift)
head(Diff_quotient)
#for max shift
head(max_shift) #should be fine
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
#oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
#column1 <- my_matrix[, 3]
#df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
#head(df_results_yshift2)
#for curve shift
Diff_quotient <- quotients_minmax$Max - quotients_minmax$Min
Diff_quotient <- data.frame(Diff_yshift)
head(Diff_quotient)
#for max shift
head(max_shift) #should be fine
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
#oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
#column1 <- my_matrix[, 3]
#df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
#head(df_results_yshift2)
#for curve shift
Diff_quotient <- quotients_minmax$Max - quotients_minmax$Min
Diff_quotient <- data.frame(Diff_yshift)
head(Diff_quotient)
#for max shift
head(max_shift) #should be fine
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
#oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
#column1 <- my_matrix[, 3]
#df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
#head(df_results_yshift2)
#for curve shift
Diff_quotient <- quotients_minmax$Max - quotients_minmax$Min
Diff_quotient <- data.frame(Diff_quotient)
head(Diff_quotient)
show(peaks_Ctrl)
print(peaks_Ctrl)
print(peaks_RNase)
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions,
YDiff = df_diff_yshift,
curve_shift = Diff_quotient,
row.names = row.names(max_shift))
#colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = Diff_max_shift,
local_shift = identical_fractions,
YDiff = df_diff_yshift,
curve_shift = Diff_quotient,
row.names = row.names(max_shift))
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions,
YDiff = df_diff_yshift,
curve_shift = Diff_quotient,
row.names = row.names(max_shift))
#colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
colnames(shift_comparison)[1] <- "max_shift"
i
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions,
YDiff = df_diff_yshift,
curve_shift = Diff_quotient,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
#for max shift
head(max_shift) #should be fine
colnames(max_shift) <- c("Diff_Max")
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
#oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
#column1 <- my_matrix[, 3]
#df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
#head(df_results_yshift2)
#for curve shift
Diff_quotient <- quotients_minmax$Max - quotients_minmax$Min
Diff_quotient <- data.frame(Diff_quotient)
head(Diff_quotient)
#for max shift
head(max_shift) #should be fine
colnames(max_shift) <- c("Diff_Max")
#for local shift
head(identical_fractions) #ich will einen DF mit Zahlenwerten
#for y shift
Diff_yshift <- df_results_yshift$GlobalMax_Ctrl - df_results_yshift$GlobalMax_RNase
df_diff_yshift <- data.frame(Diff_yshift)
head(df_diff_yshift)
#oder ich nehme die Maxtrix in der schon ein y-diff berechnet wurde, wandle sie in einen DF um und extrahiere die Spalte -> kommt auf das gleiche raus
#column1 <- my_matrix[, 3]
#df_results_yshift2 <- data.frame(Y_DiffLR  = column1)
#head(df_results_yshift2)
#for curve shift
Diff_quotient <- quotients_minmax$Max - quotients_minmax$Min
Diff_quotient <- data.frame(Diff_quotient)
head(Diff_quotient)
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions,
YDiff = df_diff_yshift,
curve_shift = Diff_quotient,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
