#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val)
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled <- scaled * 100  # Scale to the range of 0 to 100
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(lapply(shift_comparison, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val) * 100
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Assuming your dataframe is called 'df'
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(lapply(shift_comparison, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val) * 100
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Apply min-max scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val)
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled <- scaled * 100  # Scale to the range of 0 to 100
scaled
}))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Apply min-max scaling to each column
# Load the 'scales' package
library(scales)
# Apply separate min-max scaling to each column
shift_comparison <- as.data.frame(lapply(shift_comparison, function(x) rescale(x, to = c(0, 100))))
# Print the scaled dataframe
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- data.frame()
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
nrow(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
# Perform MinMax scaling on the 'max_shift' dataframe
scaled_col <- (max_shift[, 1] - min(max_shift[, 1])) / (max(max_shift[, 1]) - min(max_shift[, 1])) * 100
# Create a new dataframe with scaled column and preserved row names
scaled_df <- data.frame(Values = scaled_col, row.names = rownames(max_shift))
# Print the scaled dataframe
print(scaled_df)
shift_comparison <- data.frame(max_shift = scaled_df,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Create a new dataframe for scaled values
scaled_df <- shift_comparison
# Apply separate scaling to each column
for (col in colnames(shift_comparison)) {
col_data <- shift_comparison[[col]]
min_val <- min(col_data, na.rm = TRUE)
max_val <- max(col_data, na.rm = TRUE)
scaled_col <- (col_data - min_val) / (max_val - min_val) * 100
scaled_df[[col]] <- scaled_col
}
# Print the original and scaled dataframes
print(shift_comparison)
print(scaled_df)
#also der R-Wert beträgt noch immer 0.2658505
#first adadpted dataframe will have the columns independently scaled to 100
# Apply separate scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val)
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled <- scaled * 100  # Scale to the range of 0 to 100
scaled
}))
# Print the original and scaled dataframes
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframe based on 'max_shift'
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
# Set the row names of the new dataframe
row.names(new_df) <- rownames(max_shift)
# Print the new dataframe
print(new_df)
shift_comparison <- data.frame(max_shift = new_df,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframe based on 'max_shift'
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
# Set the row names of the new dataframe
#row.names(new_df) <- rownames(max_shift)
shift_comparison <- data.frame(max_shift = new_df,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframe based on 'max_shift'
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == 0, 0, 1))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframes
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == TRUE, 0, 1))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
head(y_max_subset)
knitr::opts_chunk$set(echo = TRUE)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframes
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == TRUE, 0, 1))
new_df3 <- as.data.frame(ifelse(y_max_subset == "RBP", 1, 0))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
YDiff = new_df3,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
#as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
#Code which would only assign a shift of 0 to no shift
#shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))
# Code which would assign a shift of 1 or less to "no shift": *HERE THE NUMBER CAN BE CHANGED!*
shift_result <- ifelse((shift_result >= -1) & (shift_result <= 1), "no shift", ifelse(shift_result > 1, "left shift", "right shift"))
# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"
# Print the new dataframe
print(shift_dataframe)
shift_dataframe["RBM3_HUMAN",] #RBM3 is a sure shifter, siehe graph etc. (aber auch komplex)
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# select proteins which have 0:
max_shift_0 <- max_shift[max_shift$Fraction == 0, , drop = FALSE]
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100, max_shift_0) {
if (row_name %in% rownames(max_shift_0)) {
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]
row_global_max_Ctrl <- max(row_data_Ctrl)
row_global_max_RNase <- max(row_data_RNase)
lower_bound <- row_global_max_Ctrl * 0.8
upper_bound <- row_global_max_Ctrl * 1.2
y_rbp <- if (row_global_max_RNase >= lower_bound && row_global_max_RNase <= upper_bound) {
"Non RBP"
} else {
"RBP"
}
return(y_rbp)
} else {
return(NULL)  # Return NULL for rows not found in max_shift_0
}
}
row_names <- rownames(max_shift_0)
results <- sapply(row_names, calculate_maxima_diff, Mitosis_Ctrl_100, Mitosis_RNase_100, max_shift_0)
y_max_subset <- data.frame(ProteinType = results)
# Print the final dataframe
y_max_subset
sum(y_max_subset$ProteinType == 'RBP') #503 additional partial shifters identified!!
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframes
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == TRUE, 0, 1))
new_df3 <- as.data.frame(ifelse(y_max_subset == "RBP", 1, 0))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
YDiff = new_df3,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
head(new_df3)
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
library(cluster)
library(ggplot2)
library(factoextra)
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframes
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == TRUE, 0, 1))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
