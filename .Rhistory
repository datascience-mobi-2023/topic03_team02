num_sets <- ncol(RDeeP_HeLa_Mitosis_Ctrl) %/% 3
print(num_sets) #25 - number of fractions
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))
print(p_values_Ctrl)
# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
# Extract the values for the current set of three columns
column_values <- RDeeP_HeLa_Mitosis_Ctrl[, i:(i + 2)]
# Calculate the p-values for the set of three columns using t-tests
p_values <- apply(column_values, 1, function(x) {
if (length(unique(x)) > 1) {
t_result <- t.test(x)
t_result$p.value
} else {
0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
}
})
# Assign the p-values to the corresponding column in the new dataframe
p_values_Ctrl[, (i %/% 3 + 1)] <- p_values
}
# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_Ctrl) <- rownames(RDeeP_HeLa_Mitosis_Ctrl)
# Print the new dataframe
print(p_values_Ctrl)
# Finding the maximum
# Create a new dataframe to store the maximum values
max_values_RNase <- data.frame(MaxValue = apply(p_values_RNase[, -1], 1, max))
# Calculate the number of sets in the RNase dataset
num_sets <- ncol(RDeeP_HeLa_Mitosis_RNase) %/% 3
# Create an empty dataframe to store the p-values
p_values_RNase <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_RNase)))
# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_RNase), by = 3)) {
# Extract the values for the current set of three columns
column_values <- RDeeP_HeLa_Mitosis_RNase[, i:(i + 2)]
# Calculate the p-values for the set of three columns using t-tests
p_values <- apply(column_values, 1, function(x) {
if (length(unique(x)) > 1) {
t_result <- t.test(x)
t_result$p.value
} else {
0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
}
})
# Assign the p-values to the corresponding column in the new dataframe
p_values_RNase[, (i %/% 3 + 1)] <- p_values
}
# Optional: Rename the columns
colnames(p_values_RNase) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_RNase) <- rownames(RDeeP_HeLa_Mitosis_RNase)
# Print the new dataframe
print(p_values_RNase)
# Finding the maximum
# Create a new dataframe to store the maximum values
max_values_RNase <- data.frame(MaxValue = apply(p_values_RNase[, -1], 1, max))
# Adding the protein names to the new dataframe:
rownames(max_values_RNase) <- rownames(p_values_RNase)
# Print the new dataframe
print(max_values_RNase)
#Testing how many RNase values we have above 5%/10%:
sum(max_values_RNase > 0.05)
sum(max_values_RNase > 0.1)
#For control
sum(max_values_Ctrl > 0.05)
# Calculate the number of sets in the Control Dataset
num_sets <- ncol(RDeeP_HeLa_Mitosis_Ctrl) %/% 3
print(num_sets) #25 - number of fractions
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))
print(p_values_Ctrl)
# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
# Extract the values for the current set of three columns
column_values <- RDeeP_HeLa_Mitosis_Ctrl[, i:(i + 2)]
# Calculate the p-values for the set of three columns using t-tests
p_values <- apply(column_values, 1, function(x) {
if (length(unique(x)) > 1) {
t_result <- t.test(x)
t_result$p.value
} else {
0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
}
})
# Assign the p-values to the corresponding column in the new dataframe
p_values_Ctrl[, (i %/% 3 + 1)] <- p_values
}
# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_Ctrl) <- rownames(RDeeP_HeLa_Mitosis_Ctrl)
# Print the new dataframe
print(p_values_Ctrl)
# Replace NA values with zero in p_values_Ctrl dataframe
# p_values_Ctrl[is.na(p_values_Ctrl)] <- 0
# Create a new dataframe to store the maximum values
max_values_Ctrl <- data.frame(MaxValue = apply(p_values_Ctrl[, -1], 1, max))
# Adding the protein names to the new dataframe:
rownames(max_values_Ctrl) <- rownames(p_values_Ctrl)
# Print the new dataframe
print(max_values_Ctrl)
# Finding the maximum
# Create a new dataframe to store the maximum values
max_values_RNase <- data.frame(MaxValue = apply(p_values_RNase[, -1], 1, max))
# Adding the protein names to the new dataframe:
rownames(max_values_RNase) <- rownames(p_values_RNase)
# Print the new dataframe
print(max_values_RNase)
#Testing how many RNase values we have above 5%/10%:
sum(max_values_RNase > 0.05)
sum(max_values_RNase > 0.1)
#For control
sum(max_values_Ctrl > 0.05)
sum(max_values_Ctrl > 0.1)
# --> RNase has a lot more fluctiation in comparison to Control!
#Alternative ways to calculate the above
#length(which(max_values_RNase > 0.1))
#length(max_values_RNase[max_values_RNase$MaxValue > 0.1, ])
RDeeP_HeLa_Mitosis_p <- data.frame(RDeeP_HeLa_Mitosis, max_values_Ctrl, max_values_RNase)
# Identify all rows where the value in _one_ of the last two columns exceeds 5% or 10%
bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 | RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
bad_proteins10 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.1 | RDeeP_HeLa_Mitosis_p[, 152] > 0.1)
#When using the logical OR (|) operator, if either condition is true, the result will be true.
#Rows in which both Control and RNase p-values exceed 5%:
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 & RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
#length(bad_proteins5)
#Alternative 5%/10% BUT THIS RESULTS IN ANTOHER VALUE, WHY? I DO NOT KNOW.
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.05)
bad_proteins10wierd <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.1)
length(bad_proteins5)
length(bad_proteins10)
length(bad_proteins10wierd)
RDeeP_HeLa_Mitosis_clean <- RDeeP_HeLa_Mitosis_p[!(RDeeP_HeLa_Mitosis_p[, 151] > 0.1 | RDeeP_HeLa_Mitosis_p[, 152] > 0.1), ] #the ! Operator negate the condition.It excludes rows where the condition is TRUE, thus effectively filtering out rows that exceed 10%.
# Remove the last two columns
RDeeP_HeLa_Mitosis_clean <- RDeeP_HeLa_Mitosis_clean[, 1:(ncol(RDeeP_HeLa_Mitosis_clean) - 2)]
#Print the new dataframe
print(RDeeP_HeLa_Mitosis_clean)
#First finding the mean of all three replicates for every fraction separately in our Mitosis_Ctrl_clean data:
Mitosis_Ctrl_mean = as.data.frame(
sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
apply(Mitosis_Ctrl_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
#inner loop which calculates the mean for the three replicates, for each row anew. and CAUTION: if we delete some rows, we might have to adjust the name of the dataframe.
}))
#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")
head(Mitosis_Ctrl_mean)
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))
head(Mitosis_Ctrl_100)
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
sapply(seq(0,72,3), function(i) {
apply(Mitosis_RNase_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
}))
colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
#Now scaling
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))
head(Mitosis_RNase_100)
# Min-max scaling function
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column).
#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling))
# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values)
# Min-max scaling function
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column).
#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling))
# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
row_data <- Mitosis_Ctrl_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has multiple peaks
if (length(peaks) > 1) {
rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
}
}
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values)
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
row_data <- Mitosis_Ctrl_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has multiple peaks
if (length(peaks) > 1) {
rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
}
}
# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60))
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
knitr::opts_chunk$set(echo = TRUE)
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")
head(RDeeP_HeLa_Mitosis)
#Deleting the complete zero rows:
RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),]
# Extract the first three values from the column
subset_values <- RDeeP_HeLa_Mitosis[1, 1:3]
# Perform the t-test
t_test_result <- t.test(subset_values)
# Print the t-test result
print(t_test_result)
RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])
#For RNase it is easier, because we now can just take all the row which were not taken in the first table.
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]
head(RDeeP_HeLa_Mitosis_RNase)
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))
# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
# Extract the values for the current row (protein)
row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
# Create an empty vector to store the p-values for the current row (protein)
p_values_row <- c()
# Iterate over every three columns in the current row (protein)
for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
# Extract the values for the current set of three columns
column_values <- row_values[j:(j + 2)]
# Calculate the p-value for the set of three columns using t-test
t_result <- t.test(column_values)
p_value <- t_result$p.value
# Append the p-value to the vector for the current row (protein)
p_values_row <- c(p_values_row, p_value)
}
# Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
p_values_Ctrl[i, ] <- p_values_row
}
# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))
# Print the new dataframe
print(p_values_Ctrl)
#First finding the mean of all three replicates for every fraction separately:
Mitosis_Ctrl_mean = as.data.frame(
sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
apply(RDeeP_HeLa_Mitosis_Ctrl[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
#inner loop which calculates the mean for the three replicates, for each row anew.
}))
#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")
print(Mitosis_Ctrl_mean)
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))
head(Mitosis_Ctrl_100)
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
sapply(seq(0,72,3), function(i) {
apply(RDeeP_HeLa_Mitosis_RNase[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
}))
colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
#Now scaling
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))
head(Mitosis_RNase_100)
#Then maybe applying the z transformation on each row was a whole, Control and RNase separate? Still needs a lot of refining...
#Mitosis_Ctrl_norm <- apply(t(Mitosis_Ctrl_mean),1, function(x)(x - mean(x)) / sd(x))
#transpose is necessary as "apply" is always iterates the command or each column
head(Mitosis_Ctrl_mean)
# Min-max scaling function
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column).
# Print the scaled data
View(Mitosis_Ctrl_MM)
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="SIN3B_HUMAN", ylim=c(0,180000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN",ylim=c(0,1500000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="SIN3B_HUMAN Normalized", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("TARA_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="TARA_HUMAN Normailzed", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("TARA_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_MM[which(rownames(Mitosis_Ctrl_MM)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN MinMax",ylim=c(0,1))
lines(1:25, Mitosis_RNase_MM[which(rownames(Mitosis_RNase_MM)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Step 1: Extract the row you want to fit the Gaussian to
row_data <- Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("CASP7_HUMAN")),]
# Step 2: Define the Gaussian function
gaussian <- function(x, mean, sd, amplitude) {
amplitude * dnorm(x, mean, sd)
}
# Step 3: Define the negative log-likelihood (NLL) function
nll <- function(params, x, y) {
mean <- params[1]
sd <- params[2]
amplitude <- params[3]
y_pred <- gaussian(x, mean, sd, amplitude)
-sum(log(y_pred + 1e-10))  # Adding a small value to avoid log(0)
}
# Step 4: Fit the Gaussian using optimization
nonzero_data <- row_data[row_data != 0]
nonzero_indices <- which(row_data != 0)
initial_params <- c(mean = mean(nonzero_data),
sd = sd(nonzero_data),
amplitude = max(nonzero_data))
fitted_params <- optim(par = initial_params,
fn = nll,
x = nonzero_indices,
y = nonzero_data,
method = "L-BFGS-B",
lower = c(-Inf, 0, 0),  # Lower bounds for parameters
upper = c(Inf, Inf, Inf))  # Upper bounds for parameters
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_data <- Mitosis_Ctrl_mean[row_index, ]
# Step 2: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value")
points(peaks, row_data[peaks], col = "red", pch = 16)
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_mean)) {
row_data <- Mitosis_Ctrl_mean[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has multiple peaks
if (length(peaks) > 1) {
rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
}
}
# Step 5: Print the row indices with multiple peaks
head(rows_with_multiple_peaks)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_data <- Mitosis_Ctrl_mean[row_index, ]
# Step 2: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value",main = paste("Plot of Row", row_index))
points(peaks, row_data[peaks], col = "red", pch = 16)
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value",main = row_index)
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value",main = rownames(row_index))
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value",main = rownames(row_index))
points(peaks, row_data[peaks], col = "red", pch = 16)
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value"))
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_data <- Mitosis_Ctrl_mean[row_index, ]
# Step 2: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value"))
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value")
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value")
points(peaks, row_data[peaks], col = "red", pch = 16)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_data <- Mitosis_Ctrl_mean[row_index, ]
row_name <- row.names(Mitosis_Ctrl_mean)[row_index]
# Step 2: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index]
# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_name <- row.names(Mitosis_RNase_100)[row_index]
# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_data <- Mitosis_Ctrl_mean[row_index, ]
row_name <- row.names(Mitosis_Ctrl_mean)[row_index]
# Step 2: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 3: Visualize the peaks on a plot
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)
