Mitosis_Ctrl_clean <- Mitosis_Ctrl_clean[!(rownames(Mitosis_Ctrl_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
Mitosis_RNase_clean <- Mitosis_RNase_clean[!(rownames(Mitosis_RNase_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
#First finding the mean of all three replicates for every fraction separately in our Mitosis_Ctrl_clean data:
Mitosis_Ctrl_mean = as.data.frame(
sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
apply(Mitosis_Ctrl_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
#inner loop which calculates the mean for the three replicates, for each row anew. and CAUTION: if we delete some rows, we might have to adjust the name of the dataframe.
}))
#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")
head(Mitosis_Ctrl_mean)
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))
head(Mitosis_Ctrl_100)
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
sapply(seq(0,72,3), function(i) {
apply(Mitosis_RNase_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
}))
colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
#Now scaling
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))
head(Mitosis_RNase_100)
# Min-max scaling function
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column).
#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling))
# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values,protein1_Ctrl_frac1,protein8_Ctrl_frac1,bad_proteins5)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein
# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Step 1: Select a specific row by name
row_name <- "2A5E_HUMAN" #'ABT1_HUMAN' (right shifter) #'ABCF1_HUMAN' (left shifter)
# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
#as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind
#Bei mir passt alles? Ist das noch aktuell? Wenn nein kommentare gern löschen - Verena
# Print the results
# Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)
#Results as vector
#as.vector(RNase_fraction_max) #just numbers (aka fractions where max)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
#Code which would only assign a shift of 0 to no shift
#shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))
# Code which would assign a shift of 1 or less to "no shift": *HERE THE NUMBER CAN BE CHANGED!*
shift_result <- ifelse((shift_result >= -1) & (shift_result <= 1), "no shift", ifelse(shift_result > 1, "left shift", "right shift"))
# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"
# Print the new dataframe
print(shift_dataframe)
shift_dataframe["RBM3_HUMAN",] #RBM3 is a sure shifter, siehe graph etc. (aber auch komplex)
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
# Create an empty vector to store the results
results <- vector("logical", nrow(Mitosis_Ctrl_100))
# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
# Get the row data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
row_data_RNase <- Mitosis_RNase_100[i, ]
# Find the peaks in the row data for Ctrl
peaks_Ctrl <- c()
for (j in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
peaks_Ctrl <- c(peaks_Ctrl, j)
}
}
# Find the peaks in the row data for RNase
peaks_RNase <- c()
for (j in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
peaks_RNase <- c(peaks_RNase, j)
}
}
# Compare the peaks between Ctrl and RNase
if (identical(peaks_Ctrl, peaks_RNase)) {
results[i] <- TRUE
} else {
results[i] <- FALSE
}
}
# Create a data frame with the results
identical_fractions <- data.frame(no_shift = results, row.names = row.names(Mitosis_Ctrl_100))
# Print the identical_fractions dataframe
print(identical_fractions)
identical_fractions["SQOR_HUMAN",] #-> FALSE, thus this protein is rightly identified as a shifter
sum(identical_fractions$no_shift == FALSE) #-> 1570 proteins are identified as shifters
# Create an empty vector to store the results
results <- vector("integer", nrow(Mitosis_Ctrl_100))
# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
# Get the row data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
row_data_RNase <- Mitosis_RNase_100[i, ]
# Find the peaks in the row data for Ctrl
peaks_Ctrl <- c()
for (j in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
peaks_Ctrl <- c(peaks_Ctrl, j)
}
}
# Find the peaks in the row data for RNase
peaks_RNase <- c()
for (j in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
peaks_RNase <- c(peaks_RNase, j)
}
}
# Calculate the difference in peak counts
diff_peaks <- length(peaks_RNase) - length(peaks_Ctrl)
# Store the difference in the results vector
results[i] <- diff_peaks
}
# Create a data frame with the results
identical_fractions2 <- data.frame(local_shift = results, row.names = row.names(Mitosis_Ctrl_100))
# Print the identical_fractions dataframe
print(identical_fractions2)
# Count the number of entries not equal to zero in the no_shift column
sum(identical_fractions2$local_shift != 0)
# Create an empty dataframe to store the results
dodgy_proteins <- data.frame(Result = logical(nrow(shift_dataframe)), row.names = row.names(shift_dataframe))
# Iterate over the rows of shift_dataframe
for (row_name in row.names(shift_dataframe)) {
# Check if the row meets the criteria in shift_dataframe
if ((shift_dataframe[row_name, ] %in% c("right shift", "left shift")) & !identical_fractions[row_name, ]) {
# Assign TRUE to the corresponding row in dodgy_proteins
dodgy_proteins[row_name, ] <- TRUE #These proteins give different results in each method!!!
} else {
# Assign FALSE to the corresponding row in dodgy_proteins
dodgy_proteins[row_name, ] <- FALSE
}
}
# Print the dodgy_proteins dataframe
print(dodgy_proteins)
sum(dodgy_proteins$Result)
sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
#Count how many have been identified using the local fraction comparison method:
sum(!identical_fractions) #Checks all FALSE (aka shifters) results in the dataframe
# Calculate the curve quotients using vectorized operations
curve_quotients <- (Mitosis_Ctrl_100+1) / (Mitosis_RNase_100+1)
# Set the row names of curve_quotients
row.names(curve_quotients) <- row.names(Mitosis_Ctrl_100)
# Print the curve_quotients dataframe
print(curve_quotients)
# Create the shifting_quotients dataframe
shifting_quotients <- data.frame("Curve_shifters" = apply(curve_quotients, 1, function(row) {
if (any(row < (4/(4*1.3)) | row > 1.3)) { #Code so angepasst das direkt die Prozentzahlen eingetragen werden können. Alternatives Vorgehen: mit "signifikanter Abweichung" arbeiten. Aber wie definiert?)
"shifter"
} else {
"not shifter"
}
}))
# Print the shifting_quotients dataframe
print(shifting_quotients)
shifting_quotients["RBM3_HUMAN",] #RBM3 is a sure shifter, but a bit complex
sum(shifting_quotients$"Curve_shifters" == "shifter")
# Create a function to perform z-test for each value
perform_z_test <- function(value) {
z_score <- (value - 1) / sd_value  # Calculate the z-score
if (abs(z_score) > #1.96) {  # Assuming 95% confidence interval. If the absolute value of the z-score is greater than 1.96, it indicates that the value significantly differs from the expectation value.
1.645) {  # Assuming 90% confidence interval. The bigger the confidence interval, the more proteins are identified as shifters.
return("shifter")
} else {
return("no shifter")
}
}
# Calculate the standard deviation across the entire dataframe
sd_value <- sd(as.matrix(curve_quotients)) #shifter abhängig auch von der sd, hier über den gesamten Datensatz eine sd von 0.361562, je kleiner, desto näher nimmt man an sind die Werte aneinander, je größer, desto weiter entfernt.
# Apply the z-test function to each value in the dataframe
quotients_using_z <- apply(curve_quotients, 1, function(row) {
result <- sapply(row, perform_z_test)
if ("shifter" %in% result) {
return("shifter")
} else {
return("no shifter")
}
})
quotients_using_z <- data.frame(quotients_using_z)
colnames(quotients_using_z) <- "Result"
# Print the count of "shifter" values
table(quotients_using_z$Result)["shifter"]
# Calculate the minimum and maximum values for each row in curve_quotients
quotients_minmax <- data.frame("Min" = apply(curve_quotients, 1, min), "Max" = apply(curve_quotients, 1, max), row.names = row.names(curve_quotients))
# Print the quotients_minmax dataframe
print(quotients_minmax)
# Function to calculate difference in y-values between global maxima #wo kommt die funktion her?
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
# Select the specific row from both dataframes #which one?
row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
row_data_RNase <- Mitosis_RNase_mean[row_name, ]
# Find the global maximum from the selected row in df1
row_global_max_Ctrl <- max(row_data_Ctrl)
# Find the global maximum from the selected row in df2
row_global_max_RNase <- max(row_data_RNase)
# Calculate the difference in y-values between the global maxima
y_diff <- row_global_max_Ctrl - row_global_max_RNase
# Return the difference in y-values
return(y_diff)
}
# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)
# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)
# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDiff = results)
# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference
#as.vector(results_yshift) #results as vector - maybe better to work with afterwards, if needed
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
#visualizing the result of kmeans
fviz_cluster(km, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)
# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data1, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot1)
#kmeans with same data but 3 cluster
km3 <- kmeans(maximum_fraction, centers = 3, nstart = 25)
#fviz_cluster(km3, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data2 <- data.frame(maximum_fraction, cluster = as.factor(km3$cluster))
show(clustered_data2)
# Create a scatter plot using ggplot
dotplot2 <- ggplot(clustered_data2, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot2)
#here we don´t need to generate a new dataframe since we already have one we can work with
show(quotients_minmax)
#Calculate optimal number of cluster
fviz_nbclust(quotients_minmax, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
km_q <- kmeans(quotients_minmax, centers = 2, nstart = 25, algorithm = "MacQueen")
#visualizing the result of kmeans
km_q
#fviz_cluster(km_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data3 <- data.frame(quotients_minmax, cluster = as.factor(km_q$cluster))
show(clustered_data3)
# Create a scatter plot using ggplot
dotplot3 <- ggplot(clustered_data3, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot3)
km3_q <- kmeans(quotients_minmax, centers = 3, nstart = 25)
#fviz_cluster(km3_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data4 <- data.frame(quotients_minmax, cluster = as.factor(km3_q$cluster))
show(clustered_data4)
# Create a scatter plot using ggplot
dotplot4 <- ggplot(clustered_data4, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot4)
#need to generate new dataframe
row_global_max_Ctrl2 <- apply(Mitosis_Ctrl_mean, 1, max)
row_global_max_RNase2 <- apply(Mitosis_RNase_mean, 1, max)
results_yshift2 <- data.frame(row_global_max_Ctrl2, row_global_max_RNase2)
show(results_yshift2)
fviz_nbclust(results_yshift2, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km_y <- kmeans(results_yshift2, centers = 2, nstart = 25)
#fviz_cluster(km_y, data = results_yshift2)
# Create a data frame with clustered data and cluster labels
clustered_data5 <- data.frame(results_yshift2, cluster = as.factor(km_y$cluster))
show(clustered_data5)
# Create a scatter plot using ggplot
dotplot5 <- ggplot(clustered_data5, aes(x = row_global_max_Ctrl2, y = row_global_max_RNase2, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "row_data_Ctrl",
y = "row_data_RNase",
color = "Cluster")
plot(dotplot5)
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km3_y <- kmeans(results_yshift2, centers = 3, nstart = 25)
#fviz_cluster(km_y, data = results_yshift2)
# Create a data frame with clustered data and cluster labels
clustered_data6 <- data.frame(results_yshift2, cluster = as.factor(km3_y$cluster))
show(clustered_data6)
# Create a scatter plot using ggplot
dotplot6 <- ggplot(clustered_data6, aes(x = row_global_max_Ctrl2, y = row_global_max_RNase2, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "GlobalMax_Ctrl",
y = "GlobalMax_RNase",
color = "Cluster")
plot(dotplot6)
# Extract the cluster assignments from the kmeans_result object
cluster_assignments <- km3_y$cluster
# Filter the dataframe based on the cluster assignment
cluster2_values <- df_results_yshift[cluster_assignments == 2, ]
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram")
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Print the cluster assignments
print(clusters)
# Create a dotplot using ggplot
dotplot <- ggplot(sorted_data, aes(x = reorder(Cluster, desc(Cluster)), y = Value, color = Cluster)) +
geom_point(size = 3) +
labs(title = "Hierarchical Clustering - Dotplot", x = "Cluster", y = "Value") +
theme_minimal()
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram")
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Print the cluster assignments
print(clusters)
# Create a dataframe with cluster assignments
data_with_clusters <- cbind(distance_matrix, Cluster = clusters)
# Sort the dataframe by cluster assignments
sorted_data <- data_with_clusters[order(data_with_clusters$Cluster), ]
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram")
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Print the cluster assignments
print(clusters)
# Create a dataframe with cluster assignments
data_with_clusters <- data.frame(Value = distance_matrix$Value, Cluster = clusters)
head(distance_matrix)
# Compute the distance matrix
distance_matrix <- dist(maximum_fraction)
# Perform hierarchical clustering
hclust_result <- hclust(distance_matrix)
# Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram")
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Plot the dendrogram with customized options
plot(hclust_result, main = "Hierarchical Clustering Dendrogram",
xlab = "Observations", ylab = "Distance",
labels = FALSE, hang = -1, cex = 0.8)
# Add labels to the leaves of the dendrogram
#labels <- rownames(maximum_fraction)
#text(x = seq_along(labels), y = par("usr")[3] - 0.1, labels = labels,
#srt = 90, adj = c(1, 0.5), xpd = TRUE, cex = 0.6)
# Cut the dendrogram into clusters
num_clusters <- 3  # Specify the desired number of clusters
clusters <- cutree(hclust_result, k = num_clusters)
# Add cluster labels to the plot
rect.hclust(hclust_result, k = num_clusters, border = 2:4)
# Print the cluster assignments
print(clusters)
# Create a dataframe with cluster assignments
data_with_clusters <- data.frame(Value = distance_matrix[, 1], Cluster = clusters)
type(hclust_result)
show(hclust_result)
