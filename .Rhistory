print(RNase_fraction_max)
#Results as vector
#as.vector(RNase_fraction_max) #just numbers (aka fractions where max)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
#Code which would only assign a shift of 0 to no shift
#shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))
# Code which would assign a shift of 1 or less to "no shift": *HERE THE NUMBER CAN BE CHANGED!*
shift_result <- ifelse((shift_result >= -1) & (shift_result <= 1), "no shift", ifelse(shift_result > 1, "left shift", "right shift"))
# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"
# Print the new dataframe
print(shift_dataframe)
shift_dataframe["RBM3_HUMAN",] #RBM3 is a sure shifter, siehe graph etc. (aber auch komplex)
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
# Create an empty vector to store the results
results <- vector("logical", nrow(Mitosis_Ctrl_100))
# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
# Get the row data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
row_data_RNase <- Mitosis_RNase_100[i, ]
# Find the peaks in the row data for Ctrl
peaks_Ctrl <- c()
for (j in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
peaks_Ctrl <- c(peaks_Ctrl, j)
}
}
# Find the peaks in the row data for RNase
peaks_RNase <- c()
for (j in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
peaks_RNase <- c(peaks_RNase, j)
}
}
# Compare the peaks between Ctrl and RNase
if (identical(peaks_Ctrl, peaks_RNase)) {
results[i] <- TRUE
} else {
results[i] <- FALSE
}
}
# Create a data frame with the results
identical_fractions <- data.frame(no_shift = results, row.names = row.names(Mitosis_Ctrl_100))
# Print the identical_fractions dataframe
print(identical_fractions)
identical_fractions["SQOR_HUMAN",] #-> FALSE, thus this protein is rightly identified as a shifter
sum(identical_fractions$no_shift == FALSE) #-> 1570 proteins are identified as shifters
# Create an empty vector to store the results
results <- vector("integer", nrow(Mitosis_Ctrl_100))
# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
# Get the row data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
row_data_RNase <- Mitosis_RNase_100[i, ]
# Find the peaks in the row data for Ctrl
peaks_Ctrl <- c()
for (j in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
peaks_Ctrl <- c(peaks_Ctrl, j)
}
}
# Find the peaks in the row data for RNase
peaks_RNase <- c()
for (j in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
peaks_RNase <- c(peaks_RNase, j)
}
}
# Calculate the difference in peak counts
diff_peaks <- length(peaks_RNase) - length(peaks_Ctrl)
# Store the difference in the results vector
results[i] <- diff_peaks
}
# Create a data frame with the results
identical_fractions2 <- data.frame(local_shift = results, row.names = row.names(Mitosis_Ctrl_100))
# Print the identical_fractions dataframe
print(identical_fractions2)
# Count the number of entries not equal to zero in the no_shift column
sum(identical_fractions2$local_shift != 0)
# Create an empty dataframe to store the results
dodgy_proteins <- data.frame(Result = logical(nrow(shift_dataframe)), row.names = row.names(shift_dataframe))
# Iterate over the rows of shift_dataframe
for (row_name in row.names(shift_dataframe)) {
# Check if the row meets the criteria in shift_dataframe
if ((shift_dataframe[row_name, ] %in% c("right shift", "left shift")) & !identical_fractions[row_name, ]) {
# Assign TRUE to the corresponding row in dodgy_proteins
dodgy_proteins[row_name, ] <- TRUE #These proteins give different results in each method!!!
} else {
# Assign FALSE to the corresponding row in dodgy_proteins
dodgy_proteins[row_name, ] <- FALSE
}
}
# Print the dodgy_proteins dataframe
print(dodgy_proteins)
sum(dodgy_proteins$Result)
sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
#Count how many have been identified using the local fraction comparison method:
sum(!identical_fractions) #Checks all FALSE (aka shifters) results in the dataframe
# Calculate the curve quotients using vectorized operations
curve_quotients <- (Mitosis_Ctrl_100+1) / (Mitosis_RNase_100+1)
# Set the row names of curve_quotients
row.names(curve_quotients) <- row.names(Mitosis_Ctrl_100)
# Print the curve_quotients dataframe
print(curve_quotients)
# Create the shifting_quotients dataframe
shifting_quotients <- data.frame("Curve_shifters" = apply(curve_quotients, 1, function(row) {
if (any(row < (4/(4*1.3)) | row > 1.3)) { #Code so angepasst das direkt die Prozentzahlen eingetragen werden können. Alternatives Vorgehen: mit "signifikanter Abweichung" arbeiten. Aber wie definiert?)
"shifter"
} else {
"not shifter"
}
}))
# Print the shifting_quotients dataframe
print(shifting_quotients)
shifting_quotients["RBM3_HUMAN",] #RBM3 is a sure shifter, but a bit complex
sum(shifting_quotients$"Curve_shifters" == "shifter")
# Create a function to perform z-test for each value
perform_z_test <- function(value) {
z_score <- (value - 1) / sd_value  # Calculate the z-score
if (abs(z_score) > #1.96) {  # Assuming 95% confidence interval. If the absolute value of the z-score is greater than 1.96, it indicates that the value significantly differs from the expectation value.
1.645) {  # Assuming 90% confidence interval. The bigger the confidence interval, the more proteins are identified as shifters.
return("shifter")
} else {
return("no shifter")
}
}
# Calculate the standard deviation across the entire dataframe
sd_value <- sd(as.matrix(curve_quotients)) #shifter abhängig auch von der sd, hier über den gesamten Datensatz eine sd von 0.361562, je kleiner, desto näher nimmt man an sind die Werte aneinander, je größer, desto weiter entfernt.
# Apply the z-test function to each value in the dataframe
quotients_using_z <- apply(curve_quotients, 1, function(row) {
result <- sapply(row, perform_z_test)
if ("shifter" %in% result) {
return("shifter")
} else {
return("no shifter")
}
})
quotients_using_z <- data.frame(quotients_using_z)
colnames(quotients_using_z) <- "Result"
# Print the count of "shifter" values
table(quotients_using_z$Result)["shifter"]
# Calculate the minimum and maximum values for each row in curve_quotients
quotients_minmax <- data.frame("Min" = apply(curve_quotients, 1, min), "Max" = apply(curve_quotients, 1, max), row.names = row.names(curve_quotients))
# Print the quotients_minmax dataframe
print(quotients_minmax)
# Function to calculate difference in y-values between global maxima #wo kommt die funktion her?
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100) {
# Select the specific row from both dataframes #which one?
row_data_Ctrl <- Mitosis_Ctrl_mean[row_name, ]
row_data_RNase <- Mitosis_RNase_mean[row_name, ]
# Find the global maximum from the selected row in df1
row_global_max_Ctrl <- max(row_data_Ctrl)
# Find the global maximum from the selected row in df2
row_global_max_RNase <- max(row_data_RNase)
# Calculate the difference in y-values between the global maxima
y_diff <- row_global_max_Ctrl - row_global_max_RNase
# Return the difference in y-values
return(y_diff)
}
# Get the row names of df1
row_names <- rownames(Mitosis_Ctrl_mean)
# Apply the function to each row name
results <- sapply(row_names, calculate_maxima_diff)
# Create a dataframe with only the differences in y-values
results_yshift <- data.frame(YDiff = results)
# Print the results
print(results_yshift) #results as Dataframe - columns showing protein name and the difference
#as.vector(results_yshift) #results as vector - maybe better to work with afterwards, if needed
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
#visualizing the result of kmeans
fviz_cluster(km, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)
# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data1, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot1)
#kmeans with same data but 3 cluster
km3 <- kmeans(maximum_fraction, centers = 3, nstart = 25)
#fviz_cluster(km3, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data2 <- data.frame(maximum_fraction, cluster = as.factor(km3$cluster))
show(clustered_data2)
# Create a scatter plot using ggplot
dotplot2 <- ggplot(clustered_data2, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot2)
#here we don´t need to generate a new dataframe since we already have one we can work with
show(quotients_minmax)
#Calculate optimal number of cluster
fviz_nbclust(quotients_minmax, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
km_q <- kmeans(quotients_minmax, centers = 2, nstart = 25, algorithm = "MacQueen")
#visualizing the result of kmeans
km_q
#fviz_cluster(km_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data3 <- data.frame(quotients_minmax, cluster = as.factor(km_q$cluster))
show(clustered_data3)
# Create a scatter plot using ggplot
dotplot3 <- ggplot(clustered_data3, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot3)
km3_q <- kmeans(quotients_minmax, centers = 3, nstart = 25)
#fviz_cluster(km3_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data4 <- data.frame(quotients_minmax, cluster = as.factor(km3_q$cluster))
show(clustered_data4)
# Create a scatter plot using ggplot
dotplot4 <- ggplot(clustered_data4, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot4)
#need to generate new dataframe
row_global_max_Ctrl2 <- apply(Mitosis_Ctrl_mean, 1, max)
row_global_max_RNase2 <- apply(Mitosis_RNase_mean, 1, max)
results_yshift2 <- data.frame(row_global_max_Ctrl2, row_global_max_RNase2)
show(results_yshift2)
fviz_nbclust(results_yshift2, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km_y <- kmeans(results_yshift2, centers = 2, nstart = 25)
#fviz_cluster(km_y, data = results_yshift2)
# Create a data frame with clustered data and cluster labels
clustered_data5 <- data.frame(results_yshift2, cluster = as.factor(km_y$cluster))
show(clustered_data5)
# Create a scatter plot using ggplot
dotplot5 <- ggplot(clustered_data5, aes(x = row_global_max_Ctrl2, y = row_global_max_RNase2, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "row_data_Ctrl",
y = "row_data_RNase",
color = "Cluster")
plot(dotplot5)
#then a k-means clustering with the optimal amount of cluster and interpretation
#visualizing the result of kmeans
km3_y <- kmeans(results_yshift2, centers = 3, nstart = 25)
#fviz_cluster(km_y, data = results_yshift2)
# Create a data frame with clustered data and cluster labels
clustered_data6 <- data.frame(results_yshift2, cluster = as.factor(km3_y$cluster))
show(clustered_data6)
# Create a scatter plot using ggplot
dotplot6 <- ggplot(clustered_data6, aes(x = row_global_max_Ctrl2, y = row_global_max_RNase2, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for y-shift",
x = "GlobalMax_Ctrl",
y = "GlobalMax_RNase",
color = "Cluster")
plot(dotplot6)
# Extract the cluster assignments from the kmeans_result object
cluster_assignments <- km3_y$cluster
# Filter the dataframe based on the cluster assignment
cluster2_values <- df_results_yshift[cluster_assignments == 2, ]
# Print the values in Cluster 2
print(cluster2_values)
# Count the number of values in Cluster 2
num_cluster2_values <- nrow(cluster2_values)
# Print the count
print(num_cluster2_values)
# Step 1: Extract the row you want to find peaks in
row_index <- 4269     # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein
# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,40), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
#die einzelnen Dataframes skalieren und neuen dataframes zuweisen und im Code danach anpassen
sc_max_shift <- scale(max_shift, center = FALSE, scale = FALSE)
sc_identical_fractions2 <- scale(identical_fractions2, center = FALSE, scale = FALSE)
sc_results_yshift <- scale(results_yshift, center = FALSE, scale = FALSE)
quotients_max <- data.frame(quotients_minmax$Max)
sc_quotients_minmax <- scale(quotients_max, center = FALSE, scale = FALSE)
#sc_max_shift <- as.data.frame(sapply(max_shift, function(i){(i/apply(max_shift,1,sum))*100}))
#sc_max_shift <- t(apply(max_shift, 1, min_max_scaling))
#sc_identical_fractions2 <- t(apply(identical_fractions2, 1, min_max_scaling))
#sc_results_yshift <- t(apply(results_yshift, 1, min_max_scaling))
#sc_quotients_minmax <- t(apply(quotients_minmax, 1, min_max_scaling))
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = sc_max_shift,
local_shift = sc_identical_fractions2,
YDiff = sc_results_yshift,
curve_shift = sc_quotients_minmax,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
#die einzelnen Dataframes skalieren und neuen dataframes zuweisen und im Code danach anpassen
sc_max_shift <- scale(max_shift, center = FALSE, scale = FALSE)
sc_max_shift <- as.data.frame(sapply(max_shift, function(i){(i/apply(max_shift,1,sum))*100}))
head(sc_max_shift)
# Scale each column to values between 1 and 100
sc_max_shift <- data.frame(apply(max_shift, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col)
}))
# Print the scaled dataframe
print(sc_max_shift)
sc_max_shift <- data.frame(apply(max_shift, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col)
sc_identical_fractions2 <- data.frame(apply(identical_fractions2, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col2 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col2)
sc_results_yshift <- data.frame(apply(results_yshift, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col3 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col3)
quotients_max <- data.frame(quotients_minmax$Max)
sc_quotients_max <- data.frame(apply(quotients_max, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col4 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col4)
sc_max_shift <- data.frame(apply(max_shift, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col)
print(sc_max_shift)
print(sc_max_shift)
sc_max_shift <- data.frame(apply(max_shift, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col)
print(sc_max_shift)
sc_identical_fractions2 <- data.frame(apply(identical_fractions2, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col2 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col2)
print(sc_identical_fractions2)
sc_results_yshift <- data.frame(apply(results_yshift, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col3 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col3)
print(sc_results_yshift)
quotients_max <- data.frame(quotients_minmax$Max)
sc_quotients_max <- data.frame(apply(quotients_max, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col4 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col4)
print(sc_quotients_max)
sc_max_shift <- data.frame(apply(max_shift, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col) }))
print(sc_max_shift)
sc_identical_fractions2 <- data.frame(apply(identical_fractions2, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col2 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col2) }))
print(sc_identical_fractions2)
sc_results_yshift <- data.frame(apply(results_yshift, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col3 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col3) }))
print(sc_results_yshift)
quotients_max <- data.frame(quotients_minmax$Max)
sc_quotients_max <- data.frame(apply(quotients_max, 2, function(x) {
min_val <- min(x)
max_val <- max(x)
scaled_col4 <- 1 + 99 * (x - min_val) / (max_val - min_val)
return(scaled_col4) }))
print(sc_quotients_max)
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = sc_max_shift,
local_shift = sc_identical_fractions2,
YDiff = sc_results_yshift,
curve_shift = sc_quotients_minmax,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
