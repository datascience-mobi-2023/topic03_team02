row_data <- Mitosis_Ctrl_mean[row_index, ]
=======
# Step 1: Extract the row you want to fit the Gaussian to
row_data <- Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("CASP7_HUMAN")),]
# Step 2: Define the Gaussian function
gaussian <- function(x, mean, sd, amplitude) {
amplitude * dnorm(x, mean, sd)
}
# Step 3: Define the negative log-likelihood (NLL) function
nll <- function(params, x, y) {
mean <- params[1]
sd <- params[2]
amplitude <- params[3]
y_pred <- gaussian(x, mean, sd, amplitude)
-sum(log(y_pred + 1e-10))  # Adding a small value to avoid log(0)
}
# Step 4: Fit the Gaussian using optimization
nonzero_data <- row_data[row_data != 0]
nonzero_indices <- which(row_data != 0)
initial_params <- c(mean = mean(nonzero_data),
sd = sd(nonzero_data),
amplitude = max(nonzero_data))
fitted_params <- optim(par = initial_params,
fn = nll,
x = nonzero_indices,
y = nonzero_data,
method = "L-BFGS-B",
lower = c(-Inf, 0, 0),  # Lower bounds for parameters
upper = c(Inf, Inf, Inf))  # Upper bounds for parameters
# Step 1: Create an empty vector to store the results
#one_peak_shifts <- vector("character", length = length(rows_with_one_peak))
#names(one_peak_shifts) <- rownames(Mitosis_Ctrl_100)[rows_with_one_peak]
#Doesn't matter if we take the row indexes from the control or RNase dataset, theoretically they should be identical. Testing my theory:
#nrow(Mitosis_Ctrl_100[rows_with_one_peak,])
#nrow(Mitosis_RNase_100[rows_with_one_peak,]) #--> works, is identical :)
# Get the row data from Mitosis_Ctrl_100 and Mitosis_RNase_100
row_data_ctrl <- Mitosis_Ctrl_100[rows_with_one_peak,]
row_data_rnase <- Mitosis_Ctrl_100[rows_with_one_peak,] #HERE IT SHOULD SAY RNASE, BUT THEN THE CODE DOESNT WORK AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHh
# Find the column index with the maximum value in each row
max_col_ctrl <- max.col(row_data_ctrl)
max_col_rnase <- max.col(row_data_rnase)
# Create an empty dataframe to store the results
result_df <- data.frame(Result = character(length(rows_with_one_peak)), stringsAsFactors = FALSE)
rownames(result_df) <- seq_along(rows_with_one_peak)
# Compare the elements of the vectors
comparison <- mapply(function(x, y) {
diff <- x - y
if (diff < 0) {
return("right shift")
} else if (diff > 0) {
return("left shift")
} else {
return("no shift")
}
}, max_col_ctrl, max_col_rnase)
# Create the result dataframe
result_df <- data.frame(Result = comparison, row.names = seq_along(rows_with_one_peak))
# Print the result dataframe
print(result_df)
knitr::opts_chunk$set(echo = TRUE)
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")
head(RDeeP_HeLa_Mitosis)
dim(RDeeP_HeLa_Mitosis)
head(rownames(RDeeP_HeLa_Mitosis))
head(colnames(RDeeP_HeLa_Mitosis))
which(rowSums(RDeeP_HeLa_Mitosis)==0)
print(RDeeP_HeLa_Mitosis["KLD10_HUMAN",])
RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),] #Habe hier das letzte Komma hinzugefügt und das = in ein <- geändert.
#Tabelle ohne die Nullzeile wieder in der Variable gespeichert
#We might have to repeat this later, for when we have separated Control and RNase, as the same argumentation applies if already only one of them only has zeros.
#which(rowSums(RDeeP_HeLa_Mitosis_Ctrl)==0)
#which(rowSums(RDeeP_HeLa_Mitosis_RNase)==0) #Careful, that we have to delete the the zero rows of RNase also in the Control Dataframe
dim(RDeeP_HeLa_Mitosis)
# Find rows without any zeros
nonzero_rows <- RDeeP_HeLa_Mitosis[rowSums(RDeeP_HeLa_Mitosis == 0) == 0, ]
#The condition rowSums(RDeep_Hela_Mitosis == 0) == 0 checks which rows have a sum of zeros equal to zero, indicating that those rows do *not* contain any zeros.Then we selects these rows without any zeros from our table and store it in a new table.
# Print the rows without any zeros: print(nonzero_rows)
nrow(nonzero_rows) #320 rows do not have zeros
#Possibly deleting these nonzero rows and storing it in the original matrix:
#RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[rowSums(RDeeP_HeLa_Mitosis == 0) > 0, ]
nrow(RDeeP_HeLa_Mitosis)
ncol(RDeeP_HeLa_Mitosis)
sum(apply(RDeeP_HeLa_Mitosis, 1, is.na)) # Summe aller Spalten, die NA Werte haben
sum(apply(RDeeP_HeLa_Mitosis, 2, is.na)) # Summe aller Zeilen, die NA Werte haben
sum(apply(RDeeP_HeLa_Mitosis, 1, is.numeric))
sum(apply(RDeeP_HeLa_Mitosis, 2, is.numeric))
sum(apply(RDeeP_HeLa_Mitosis, 1, is.numeric)) == nrow(RDeeP_HeLa_Mitosis)
#Complete DataSet
#View(RDeeP_HeLa_Mitosis)
# Extract the first three values from the table
protein1_Ctrl_frac1 <- RDeeP_HeLa_Mitosis[1, 1:3] #Zeile 1, Spalten eins bis drei
# Perform the t-test
print(t.test(protein1_Ctrl_frac1))
#beide schritte kann man theoretisch auch noch in einem vereinigen.
# Extract the first three values from the table
protein8_Ctrl_frac1 <- RDeeP_HeLa_Mitosis[8, 1:3]
# Perform the t-test
print(t.test(protein8_Ctrl_frac1))
#easiest way is to separately define the columns we want to put into the new data frame
RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])
#For RNase it is easier, because we now can just take all the row which were not taken in the first table.
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]
head(RDeeP_HeLa_Mitosis_RNase)
# Calculate the number of sets in the Control Dataset
num_sets <- ncol(RDeeP_HeLa_Mitosis_Ctrl) %/% 3
print(num_sets) #25 - number of fractions
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))
print(p_values_Ctrl)
# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
# Extract the values for the current set of three columns
column_values <- RDeeP_HeLa_Mitosis_Ctrl[, i:(i + 2)]
# Calculate the p-values for the set of three columns using t-tests
p_values <- apply(column_values, 1, function(x) {
if (length(unique(x)) > 1) {
t_result <- t.test(x)
t_result$p.value
} else {
0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
}
})
# Assign the p-values to the corresponding column in the new dataframe
p_values_Ctrl[, (i %/% 3 + 1)] <- p_values
}
# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_Ctrl) <- rownames(RDeeP_HeLa_Mitosis_Ctrl)
# Print the new dataframe
print(p_values_Ctrl)
# Replace NA values with zero in p_values_Ctrl dataframe
# p_values_Ctrl[is.na(p_values_Ctrl)] <- 0
# Create a new dataframe to store the maximum values
max_values_Ctrl <- data.frame(MaxValue = apply(p_values_Ctrl[, -1], 1, max))
# Adding the protein names to the new dataframe:
rownames(max_values_Ctrl) <- rownames(p_values_Ctrl)
# Print the new dataframe
print(max_values_Ctrl)
# Calculate the number of sets in the RNase dataset
num_sets <- ncol(RDeeP_HeLa_Mitosis_RNase) %/% 3
# Create an empty dataframe to store the p-values
p_values_RNase <- data.frame(matrix(ncol = num_sets, nrow = nrow(RDeeP_HeLa_Mitosis_RNase)))
# Iterate over every set of three columns
for (i in seq(1, ncol(RDeeP_HeLa_Mitosis_RNase), by = 3)) {
# Extract the values for the current set of three columns
column_values <- RDeeP_HeLa_Mitosis_RNase[, i:(i + 2)]
# Calculate the p-values for the set of three columns using t-tests
p_values <- apply(column_values, 1, function(x) {
if (length(unique(x)) > 1) {
t_result <- t.test(x)
t_result$p.value
} else {
0  # Assign 0 if the data is constant (OR NA, then we have to replace na with zero later on)
}
})
# Assign the p-values to the corresponding column in the new dataframe
p_values_RNase[, (i %/% 3 + 1)] <- p_values
}
# Optional: Rename the columns
colnames(p_values_RNase) <- paste("P-Values_Frac", 1:25,sep="")
rownames(p_values_RNase) <- rownames(RDeeP_HeLa_Mitosis_RNase)
# Print the new dataframe
print(p_values_RNase)
# Finding the maximum
# Create a new dataframe to store the maximum values
max_values_RNase <- data.frame(MaxValue = apply(p_values_RNase[, -1], 1, max))
# Adding the protein names to the new dataframe:
rownames(max_values_RNase) <- rownames(p_values_RNase)
# Print the new dataframe
print(max_values_RNase)
#Testing how many RNase values we have above 5%/10%:
sum(max_values_RNase > 0.05)
sum(max_values_RNase > 0.1)
#For control
sum(max_values_Ctrl > 0.05)
sum(max_values_Ctrl > 0.1)
# --> RNase has a lot more fluctiation in comparison to Control!
#Alternative ways to calculate the above
#length(which(max_values_RNase > 0.1))
#length(max_values_RNase[max_values_RNase$MaxValue > 0.1, ])
RDeeP_HeLa_Mitosis_p <- data.frame(RDeeP_HeLa_Mitosis, max_values_Ctrl, max_values_RNase)
# Identify all rows where the value in _one_ of the last two columns exceeds 5% or 10%
bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 | RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
bad_proteins10 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.1 | RDeeP_HeLa_Mitosis_p[, 152] > 0.1)
#When using the logical OR (|) operator, if either condition is true, the result will be true.
#Rows in which both Control and RNase p-values exceed 5%:
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151] > 0.05 & RDeeP_HeLa_Mitosis_p[, 152] > 0.05)
#length(bad_proteins5)
#Alternative 5%/10% BUT THIS RESULTS IN ANTOHER VALUE, WHY? I DO NOT KNOW.
#bad_proteins5 <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.05)
bad_proteins10wierd <- which(RDeeP_HeLa_Mitosis_p[, 151:152] > 0.1)
length(bad_proteins5)
length(bad_proteins10)
length(bad_proteins10wierd)
RDeeP_HeLa_Mitosis_clean <- RDeeP_HeLa_Mitosis_p[!(RDeeP_HeLa_Mitosis_p[, 151] > 0.1 | RDeeP_HeLa_Mitosis_p[, 152] > 0.1), ] #the ! Operator negate the condition.It excludes rows where the condition is TRUE, thus effectively filtering out rows that exceed 10%.
# Remove the last two columns
RDeeP_HeLa_Mitosis_clean <- RDeeP_HeLa_Mitosis_clean[, 1:(ncol(RDeeP_HeLa_Mitosis_clean) - 2)]
#Print the new dataframe
print(RDeeP_HeLa_Mitosis_clean)
#Now we have to again separate our clean dataframe into Control and RNase
Mitosis_Ctrl_clean = cbind(RDeeP_HeLa_Mitosis_clean[,1:3],RDeeP_HeLa_Mitosis_clean[,7:9],RDeeP_HeLa_Mitosis_clean[,13:15],RDeeP_HeLa_Mitosis_clean[,19:21],RDeeP_HeLa_Mitosis_clean[,25:27],RDeeP_HeLa_Mitosis_clean[,31:33],RDeeP_HeLa_Mitosis_clean[,37:39],RDeeP_HeLa_Mitosis_clean[,43:45],RDeeP_HeLa_Mitosis_clean[,49:51],RDeeP_HeLa_Mitosis_clean[,55:57],RDeeP_HeLa_Mitosis_clean[,61:63],RDeeP_HeLa_Mitosis_clean[,67:69],RDeeP_HeLa_Mitosis_clean[,73:75],RDeeP_HeLa_Mitosis_clean[,79:81],RDeeP_HeLa_Mitosis_clean[,85:87],RDeeP_HeLa_Mitosis_clean[,91:93],RDeeP_HeLa_Mitosis_clean[,97:99],RDeeP_HeLa_Mitosis_clean[,103:105],RDeeP_HeLa_Mitosis_clean[,109:111],RDeeP_HeLa_Mitosis_clean[,115:117],RDeeP_HeLa_Mitosis_clean[,121:123],RDeeP_HeLa_Mitosis_clean[,127:129],RDeeP_HeLa_Mitosis_clean[,133:135],RDeeP_HeLa_Mitosis_clean[,139:141],RDeeP_HeLa_Mitosis_clean[,145:147])
#For RNase
Mitosis_RNase_clean=RDeeP_HeLa_Mitosis_clean[,-which(names(RDeeP_HeLa_Mitosis_clean) %in% colnames(Mitosis_Ctrl_clean))]
# Calculate the pairwise correlations between the first three columns
cor_matrix_frac1 <- cor(RDeeP_HeLa_Mitosis_Ctrl[, 1:3], method = "pearson")
# Visualize the correlation matrix using a heatmap
heatmap(cor_matrix_frac1,
col = colorRampPalette(c("blue", "white", "red"))(100),
main = "Correlation Heatmap")
#Printing the correlation matrix as data frame
print(as.data.frame(cor_matrix_frac1))
#First finding the mean of all three replicates for every fraction separately in our Mitosis_Ctrl_clean data:
Mitosis_Ctrl_mean = as.data.frame(
sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
apply(Mitosis_Ctrl_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
#inner loop which calculates the mean for the three replicates, for each row anew. and CAUTION: if we delete some rows, we might have to adjust the name of the dataframe.
}))
#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")
head(Mitosis_Ctrl_mean)
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))
head(Mitosis_Ctrl_100)
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
sapply(seq(0,72,3), function(i) {
apply(Mitosis_RNase_clean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
}))
colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
#Now scaling
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))
head(Mitosis_RNase_100)
# Min-max scaling function
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column).
#For RNase
Mitosis_RNase_MM <- t(apply(Mitosis_RNase_mean, 1, min_max_scaling))
# Print the scaled data
head(as.data.frame(Mitosis_Ctrl_MM))
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values)
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
row_data <- Mitosis_Ctrl_100[row_index, ]
>>>>>>> Stashed changes
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has multiple peaks
if (length(peaks) > 1) {
rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
}
}
# Step 5: Print the row indices with multiple peaks
<<<<<<< Updated upstream
length(rows_with_multiple_peaks)
head(rows_with_multiple_peaks)
# Step 1: Create an empty vector to store the row indices with one peak
rows_with_one_peak <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {   #why here with MitosisCtrl100 and above with MitosisCtrlMean?? Should it not be the same for comparison?
row_data <- Mitosis_Ctrl_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has only one peak
if (length(peaks) == 1) {
rows_with_one_peak <- c(rows_with_one_peak, row_index)
}
}
# Step 5: Print the row indices with only one peak
length(rows_with_one_peak)  # Number of rows with one peak
rows_with_one_peak  # Row indices with one peak
head(rows_with_one_peak)
# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) == nrow(Mitosis_Ctrl_100)
length(rows_with_multiple_peaks) + length(rows_with_one_peak) #7074 rows
nrow(Mitosis_Ctrl_100) #7158 rows
# Step 1: Create an empty vector to store the row indices with no peak
rows_with_no_peak <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) { #Ich habe das gleiche auch mit dem nicht "clean" dataframe durchgeführt, da waren es 100 Proteine, hier sind es jetzt 82. Also 18 davon hatten wir schon im Data cleanup gelöscht.
row_data <- Mitosis_Ctrl_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has no peak
if (length(peaks) == 0) {
rows_with_no_peak <- c(rows_with_no_peak, row_index)
}
}
# Step 5: Print the row indices with no peak
length(rows_with_no_peak)  # Number of rows with no peak #84
#what are rows with no peaks? Theoretically we already cleaned up the dataframe, should it not be free of 0 rows? #what does it mean (for our data) that the protein accumulates in the first/last fraction
# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) + length(rows_with_no_peak) == nrow(Mitosis_Ctrl_100)
# Test maximum value is in the last fraction (column), this means the protein accumulated at the bottom
has_max_in_last_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
max_index <- which.max(row)
max_index == ncol(Mitosis_Ctrl_100)
})
# Test if maximum value is in the first fraction, protein accumulated and the top
has_max_in_first_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
max_index <- which.max(row)
max_index == 1
})
# Check if has_max_in_last_col and has_max_in_first_col are complementary
are_complementary <- all(has_max_in_last_col != has_max_in_first_col)
are_complementary
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2
# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_index, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Find the row name
row_name <- row.names(Mitosis_Ctrl_100)[row_index]
# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5B_HUMAN"
# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_name, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Print the column name and value
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2
# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_index, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Find the row name
row_name <- row.names(Mitosis_RNase_100)[row_index]
# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5E_HUMAN"
# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_name, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Print the column name and value
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# ERROR because we had RNAse rows with only zeros. I fixed that, for this code to run simply run the working code again.
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
knitr::opts_chunk$set(echo = TRUE)
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")
=======
length(rows_with_multiple_peaks) #this is already a vector
rows_with_multiple_peaks
#rows_with_multiple_peaks_df <- data.frame(Row_Name = rownames(Mitosis_Ctrl_100), value = rows_with_multiple_peaks)
#rows_with_multiple_peaks_df
#rownames(Mitosis_Ctrl_100 %in% rows_with_multiple_peaks)
# Iterate over each row in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {
# Extract the row
row <- Mitosis_Ctrl_100[row_index, ]
# Find the global maximum in the row
global_max <- max(row)
# Check if the row has only one peak
has_one_peak <- sum(row == global_max) == 1 && all(diff(row) < 0)
# Print the result for the current row
print(paste("Row", row_index, "has one peak:", has_one_peak))
}
q()
>>>>>>> Stashed changes
knitr::opts_chunk$set(echo = TRUE)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# ERROR because we had RNAse rows with only zeros. I fixed that, for this code to run simply run the working code again.
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
knitr::opts_chunk$set(echo = TRUE)
#Now we have to again separate our clean dataframe into Control and RNase
Mitosis_Ctrl_clean = cbind(RDeeP_HeLa_Mitosis_clean[,1:3],RDeeP_HeLa_Mitosis_clean[,7:9],RDeeP_HeLa_Mitosis_clean[,13:15],RDeeP_HeLa_Mitosis_clean[,19:21],RDeeP_HeLa_Mitosis_clean[,25:27],RDeeP_HeLa_Mitosis_clean[,31:33],RDeeP_HeLa_Mitosis_clean[,37:39],RDeeP_HeLa_Mitosis_clean[,43:45],RDeeP_HeLa_Mitosis_clean[,49:51],RDeeP_HeLa_Mitosis_clean[,55:57],RDeeP_HeLa_Mitosis_clean[,61:63],RDeeP_HeLa_Mitosis_clean[,67:69],RDeeP_HeLa_Mitosis_clean[,73:75],RDeeP_HeLa_Mitosis_clean[,79:81],RDeeP_HeLa_Mitosis_clean[,85:87],RDeeP_HeLa_Mitosis_clean[,91:93],RDeeP_HeLa_Mitosis_clean[,97:99],RDeeP_HeLa_Mitosis_clean[,103:105],RDeeP_HeLa_Mitosis_clean[,109:111],RDeeP_HeLa_Mitosis_clean[,115:117],RDeeP_HeLa_Mitosis_clean[,121:123],RDeeP_HeLa_Mitosis_clean[,127:129],RDeeP_HeLa_Mitosis_clean[,133:135],RDeeP_HeLa_Mitosis_clean[,139:141],RDeeP_HeLa_Mitosis_clean[,145:147])
#For RNase
Mitosis_RNase_clean=RDeeP_HeLa_Mitosis_clean[,-which(names(RDeeP_HeLa_Mitosis_clean) %in% colnames(Mitosis_Ctrl_clean))]
#additional cleanup: deleting all rows in RNase and Ctrl which are zero, removing these rows from the entire clean dataframe
which(rowSums(Mitosis_Ctrl_clean)==0)
which(rowSums(Mitosis_RNase_clean)==0)
# Removing BT2A3_HUMAN SEPP1_HUMAN from each dataframe and saving in in the same variable again:
Mitosis_Ctrl_clean <- Mitosis_Ctrl_clean[!(rownames(Mitosis_Ctrl_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
Mitosis_RNase_clean <- Mitosis_RNase_clean[!(rownames(Mitosis_RNase_clean) %in% c("BT2A3_HUMAN", "SEPP1_HUMAN")), ]
# ERROR because we had RNAse rows with only zeros. I fixed that, for this code to run simply run the working code again.
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# ERROR because we had RNAse rows with only zeros. I fixed that, for this code to run simply run the working code again.
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
