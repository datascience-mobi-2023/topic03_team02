colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
#Now scaling
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))
head(Mitosis_RNase_100)
#I think it's time to clean up the environment to maintain an overview
rm(nonzero_rows, column_values,max_values_Ctrl,max_values_RNase,p_values_Ctrl,p_values_RNase,RDeeP_HeLa_Mitosis_p,bad_proteins10,bad_proteins10wierd,num_sets,p_values,protein1_Ctrl_frac1,protein8_Ctrl_frac1,bad_proteins5,i,num_sets,RDeeP_HeLa_Mitosis_Ctrl,RDeeP_HeLa_Mitosis_RNase)
# Step 1: Extract the row you want to find peaks in
row_index <- 6  # Adjust the row index as needed
row_name <- row.names(Mitosis_Ctrl_100)[row_index] #name of plot adapts depending on protein viewed #also works if Mitosis_RNase_100, bc both dataframes would plot the same protein
# Step 2: Extrakt the data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[row_index, ]
row_data_RNase <- Mitosis_RNase_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_index, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_index, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Step 1: Select a specific row by name
row_name <- "2A5E_HUMAN" # "ABCA1_HUMAN" (precipitated protein, but still shifter) 'ABT1_HUMAN' (right shifter) #'ABCF1_HUMAN' (left shifter) #UTP11_HUMAN (percipitated non shifting protein?) #ehemals problematisch: SQOR_HUMAN
# Step 2: Find the peaks for Ctrl in the row data
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]
# Step 3: Find the peaks in the row data
peaks_Ctrl <- c()
for (i in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[i] > row_data_Ctrl[i-1] && row_data_Ctrl[i] > row_data_Ctrl[i+1]) {
peaks_Ctrl <- c(peaks_Ctrl, i)
}
}
peaks_RNase <- c()
for (i in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[i] > row_data_RNase[i-1] && row_data_RNase[i] > row_data_RNase[i+1]) {
peaks_RNase <- c(peaks_RNase, i)
}
}
# Step 4: Visualize the peaks on a plot
plot(1:25, Mitosis_Ctrl_100[row_name, ], type = "l", col="blue", xlab = "Fractions", ylab = "Relative Protein amount",ylim=c(0,60), main = row_name)
points(peaks_Ctrl, row_data_Ctrl[peaks_Ctrl], col = "blue", pch = 16)
lines(1:25, Mitosis_RNase_100[row_name, ], type="l",col="red")
points(peaks_RNase, row_data_RNase[peaks_RNase], col = "red", pch = 16)
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
#as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
RNase_fraction_max <- data.frame(Fraction = column_indices)
#hier kommt bei mir Fehler raus, da anscheinend unsere Daten unterschiedlich lang sind
#Bei mir passt alles? Ist das noch aktuell? Wenn nein kommentare gern löschen - Verena
# Print the results
# Shows protein name, fraction where global maxima was found and the maximum value
print(RNase_fraction_max_value)
print(RNase_fraction_max)
#Results as vector
#as.vector(RNase_fraction_max) #just numbers (aka fractions where max)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
#Code which would only assign a shift of 0 to no shift
#shift_result <- ifelse(shift_result == 0, "no shift", ifelse(shift_result > 0, "left shift", "right shift"))
# Code which would assign a shift of 1 or less to "no shift": *HERE THE NUMBER CAN BE CHANGED!*
shift_result <- ifelse((shift_result >= -1) & (shift_result <= 1), "no shift", ifelse(shift_result > 1, "left shift", "right shift"))
# Create a new dataframe with the shift result and row names
shift_dataframe <- data.frame(Shift = shift_result, row.names = row.names(Ctrl_fraction_max))
colnames(shift_dataframe)[1] <- "Shift"
# Print the new dataframe
print(shift_dataframe)
shift_dataframe["RBM3_HUMAN",] #RBM3 is a sure shifter, siehe graph etc. (aber auch komplex)
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
sum(shift_dataframe$Shift == "right shift")
sum(shift_dataframe$Shift == "no shift")
sum(shift_dataframe$Shift == "left shift") + sum(shift_dataframe$Shift == "right shift")
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# select proteins which have 0:
max_shift_0 <- max_shift[max_shift$Fraction == 0, , drop = FALSE]
calculate_maxima_diff <- function(row_name, Mitosis_Ctrl_100, Mitosis_RNase_100, max_shift_0) {
if (row_name %in% rownames(max_shift_0)) {
row_data_Ctrl <- Mitosis_Ctrl_100[row_name, ]
row_data_RNase <- Mitosis_RNase_100[row_name, ]
row_global_max_Ctrl <- max(row_data_Ctrl)
row_global_max_RNase <- max(row_data_RNase)
lower_bound <- row_global_max_Ctrl * 0.8
upper_bound <- row_global_max_Ctrl * 1.2
y_rbp <- if (row_global_max_RNase >= lower_bound && row_global_max_RNase <= upper_bound) {
"Non RBP"
} else {
"RBP"
}
return(y_rbp)
} else {
return(NULL)  # Return NULL for rows not found in max_shift_0
}
}
row_names <- rownames(max_shift_0)
results <- sapply(row_names, calculate_maxima_diff, Mitosis_Ctrl_100, Mitosis_RNase_100, max_shift_0)
y_max_subset <- data.frame(ProteinType = results)
# Print the final dataframe
y_max_subset
sum(y_max_subset$ProteinType == 'RBP') #503 additional partial shifters identified!!
# Create an empty vector to store the results
results <- vector("logical", nrow(Mitosis_Ctrl_100))
# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
# Get the row data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
row_data_RNase <- Mitosis_RNase_100[i, ]
# Find the peaks in the row data for Ctrl
peaks_Ctrl <- c()
for (j in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
peaks_Ctrl <- c(peaks_Ctrl, j)
}
}
# Find the peaks in the row data for RNase
peaks_RNase <- c()
for (j in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
peaks_RNase <- c(peaks_RNase, j)
}
}
# Compare the peaks between Ctrl and RNase
if (identical(peaks_Ctrl, peaks_RNase)) {
results[i] <- TRUE
} else {
results[i] <- FALSE
}
}
# Create a data frame with the results
identical_fractions <- data.frame(no_shift = results, row.names = row.names(Mitosis_Ctrl_100))
# Print the identical_fractions dataframe
print(identical_fractions)
identical_fractions["SQOR_HUMAN",] #-> FALSE, thus this protein is rightly identified as a shifter
sum(identical_fractions$no_shift == FALSE) #-> 1570 proteins are identified as shifters
# Create an empty vector to store the results
results <- vector("integer", nrow(Mitosis_Ctrl_100))
# Iterate over each row
for (i in 1:nrow(Mitosis_Ctrl_100)) {
# Get the row data for Ctrl and RNase
row_data_Ctrl <- Mitosis_Ctrl_100[i, ]
row_data_RNase <- Mitosis_RNase_100[i, ]
# Find the peaks in the row data for Ctrl
peaks_Ctrl <- c()
for (j in 2:(length(row_data_Ctrl) - 1)) {
if (row_data_Ctrl[j] > row_data_Ctrl[j-1] && row_data_Ctrl[j] > row_data_Ctrl[j+1]) {
peaks_Ctrl <- c(peaks_Ctrl, j)
}
}
# Find the peaks in the row data for RNase
peaks_RNase <- c()
for (j in 2:(length(row_data_RNase) - 1)) {
if (row_data_RNase[j] > row_data_RNase[j-1] && row_data_RNase[j] > row_data_RNase[j+1]) {
peaks_RNase <- c(peaks_RNase, j)
}
}
# Calculate the difference in peak counts
diff_peaks <- length(peaks_RNase) - length(peaks_Ctrl)
# Store the difference in the results vector
results[i] <- diff_peaks
}
# Create a data frame with the results
identical_fractions2 <- data.frame(local_shift = results, row.names = row.names(Mitosis_Ctrl_100))
# Print the identical_fractions dataframe
print(identical_fractions2)
# Count the number of entries not equal to zero in the no_shift column
sum(identical_fractions2$local_shift != 0)
# Calculate the curve quotients using vectorized operations
curve_quotients <- (Mitosis_Ctrl_100+1) / (Mitosis_RNase_100+1)
# Set the row names of curve_quotients
row.names(curve_quotients) <- row.names(Mitosis_Ctrl_100)
# Print the curve_quotients dataframe
print(curve_quotients)
# Create the shifting_quotients dataframe
shifting_quotients <- data.frame("Curve_shifters" = apply(curve_quotients, 1, function(row) {
if (any(row < (4/(4*1.7)) | row > 1.7)) { #Code so angepasst das direkt die Prozentzahlen eingetragen werden können. Alternatives Vorgehen: mit "signifikanter Abweichung" arbeiten. Aber wie definiert?)
"shifter"
} else {
"not shifter"
}
}))
# Print the shifting_quotients dataframe
print(shifting_quotients)
shifting_quotients["RBM3_HUMAN",] #RBM3 is a sure shifter, but a bit complex
sum(shifting_quotients$"Curve_shifters" == "shifter")
# Create a function to perform z-test for each value
perform_z_test <- function(value) {
z_score <- (value - 1) / sd_value  # Calculate the z-score
if (abs(z_score) > #1.96) {  # Assuming 95% confidence interval. If the absolute value of the z-score is greater than 1.96, it indicates that the value significantly differs from the expectation value.
1.645) {  # Assuming 90% confidence interval. The bigger the confidence interval, the more proteins are identified as shifters.
return("shifter")
} else {
return("no shifter")
}
}
# Calculate the standard deviation across the entire dataframe
sd_value <- sd(as.matrix(curve_quotients)) #shifter abhängig auch von der sd, hier über den gesamten Datensatz eine sd von 0.361562, je kleiner, desto näher nimmt man an sind die Werte aneinander, je größer, desto weiter entfernt.
# Apply the z-test function to each value in the dataframe
quotients_using_z <- apply(curve_quotients, 1, function(row) {
result <- sapply(row, perform_z_test)
if ("shifter" %in% result) {
return("shifter")
} else {
return("no shifter")
}
})
quotients_using_z <- data.frame(quotients_using_z)
colnames(quotients_using_z) <- "Result"
# Print the count of "shifter" values
table(quotients_using_z$Result)["shifter"]
# Calculate the minimum and maximum values for each row in curve_quotients
quotients_minmax <- data.frame("Min" = apply(curve_quotients, 1, min), "Max" = apply(curve_quotients, 1, max), row.names = row.names(curve_quotients))
# Print the quotients_minmax dataframe
print(quotients_minmax)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
#visualizing the result of kmeans
fviz_cluster(km, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)
# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data1, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot1)
#kmeans with same data but 3 cluster
km3 <- kmeans(maximum_fraction, centers = 3, nstart = 25)
#fviz_cluster(km3, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data2 <- data.frame(maximum_fraction, cluster = as.factor(km3$cluster))
show(clustered_data2)
# Create a scatter plot using ggplot
dotplot2 <- ggplot(clustered_data2, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot2)
#here we don´t need to generate a new dataframe since we already have one we can work with
show(quotients_minmax)
#Calculate optimal number of cluster
fviz_nbclust(quotients_minmax, kmeans, method='silhouette') #optimal number of cluster = 2
#then a k-means clustering with the optimal amount of cluster and interpretation
km_q <- kmeans(quotients_minmax, centers = 2, nstart = 25, algorithm = "MacQueen")
#visualizing the result of kmeans
km_q
#fviz_cluster(km_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data3 <- data.frame(quotients_minmax, cluster = as.factor(km_q$cluster))
show(clustered_data3)
# Create a scatter plot using ggplot
dotplot3 <- ggplot(clustered_data3, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot3)
km3_q <- kmeans(quotients_minmax, centers = 3, nstart = 25)
#fviz_cluster(km3_q, data = quotients_minmax)
# Create a data frame with clustered data and cluster labels
clustered_data4 <- data.frame(quotients_minmax, cluster = as.factor(km3_q$cluster))
show(clustered_data4)
# Create a scatter plot using ggplot
dotplot4 <- ggplot(clustered_data4, aes(x = Min, y = Max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for quotients",
x = "Min",
y = "Max",
color = "Cluster")
plot(dotplot4)
max_shift <- Ctrl_fraction_max - RNase_fraction_max
# Create shift_comparison dataframe
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
# Print the shift_comparison dataframe
print(shift_comparison)
# Initialize variables to store the best linear relationship found
best_correlation <- 0
best_fit <- NULL
best_col1_name <- ""
best_col2_name <- ""
# Loop through all possible pairs of columns in the dataframe
for (i in 1:(ncol(shift_comparison) - 1)) {
for (j in (i + 1):ncol(shift_comparison)) {
# Extract the two columns
col1 <- shift_comparison[, i]
col2 <- shift_comparison[, j]
# Calculate the Pearson correlation coefficient
correlation <- cor(col1, col2, use = "pairwise.complete.obs")
# Check if the correlation is stronger than the previous best
if (abs(correlation) > abs(best_correlation)) {
best_correlation <- correlation
best_col1_name <- names(shift_comparison)[i]
best_col2_name <- names(shift_comparison)[j]
}
}
}
# Print the columns with the best linear relationship found
cat("Columns with the highest correlation were:", best_col1_name, "and", best_col2_name, "\n")
# Perform linear regression on the columns with the best linear relationship
model <- lm(shift_comparison[[best_col2_name]] ~ shift_comparison[[best_col1_name]])
# Print the regression summary
summary(model)
summary(model)$r.squared #ist bei 0.2482234, sehrrr gering...
#habe das gleiche mit dem Min wert beim Curve shift durchgeführt, da ist der wert genauso auch bei 0.2482234
# Create a data frame with the two columns
data <- data.frame(x = shift_comparison[[best_col1_name]], y = shift_comparison[[best_col2_name]])
# Create a scatter plot with regression line
ggplot(data, aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = "Linear Regression", x = best_col1_name, y = best_col2_name)
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
YDiff = results_yshift,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
shift_comparison <- data.frame(max_shift = max_shift,
local_shift = identical_fractions2,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
#first adadpted dataframe will have the columns independently scaled to 100
# Apply separate scaling to each column
shift_comparison <- as.data.frame(apply(shift_comparison, 2, function(x) {
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
scaled <- (x - min_val) / (max_val - min_val)
scaled <- ifelse(is.na(x), NA, scaled)  # Preserve NA values
scaled <- scaled * 100  # Scale to the range of 0 to 100
scaled
}))
# Print the original and scaled dataframes
print(shift_comparison)
#also der R-Wert beträgt noch immer 0.2658505
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframes
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == TRUE, 0, 1))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
print(shift_comparison)
head(new_df2)
# if that isnt enough the second dataframe will set all RBPs that we identyfied as 1 and all non-RBP as 0. For first two that would mean those with a value are set 1. For other two we take respective threshold and set those 1 that met criteria to be RBP and 0 those who do not met the threshold
# Create a new dataframes
new_df <- as.data.frame(ifelse(max_shift == 0, 0, 1))
new_df2 <- as.data.frame(ifelse(identical_fractions == TRUE, 0, 1))
shift_comparison <- data.frame(max_shift = new_df,
local_shift = new_df2,
curve_shift = quotients_minmax$Max,
row.names = row.names(max_shift))
colnames(shift_comparison)[1] <- "max_shift"
colnames(shift_comparison)[2] <- "local_shift"
print(shift_comparison)
knitr::opts_chunk$set(echo = TRUE)
residuals <- rstandard(model)
# Create a QQ plot
qqplot(qnorm(ppoints(length(residuals))), residuals,
xlab = "Theoretical Quantiles",
ylab = "Standardized Residuals",
main = "QQ Plot of Linear Model")
abline(a = 0, b = 1, col = "red", lwd = 2)
knitr::opts_chunk$set(echo = TRUE)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
library(cluster)
library(ggplot2)
library(factoextra)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
#visualizing the result of kmeans
fviz_cluster(km, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)
# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data1, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot1)
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
#visualizing the result of kmeans
fviz_cluster(km, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)
# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data1, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot1)
knitr::opts_chunk$set(echo = TRUE)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
library(cluster)
library(ggplot2)
library(factoextra)
#generate a dataframe that holds the nummeric data of the shift. Dataframe has to have 2 dimension: RNase fraction and control fraction
maximum_fraction <- data.frame(Ctrl_fraction_max, RNase_fraction_max)
colnames(maximum_fraction) <- c("Ctrl_fraction_max", "RNase_fraction_max")
show(maximum_fraction)
plot(maximum_fraction, main = "comparison of maxima")
#Calculate optimal number of cluster
fviz_nbclust(maximum_fraction, kmeans, method='silhouette') #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='wss')        #optimal number of cluster = 2
#fviz_nbclust(maximum_fraction, kmeans, method='gap_stat')   #optimal number of cluster = 6
#then a k-means clustering with the optimal amount of cluster and interpretation
km <- kmeans(maximum_fraction, centers = 2, nstart = 25)
#visualizing the result of kmeans
fviz_cluster(km, data = maximum_fraction)
# Create a data frame with clustered data and cluster labels
clustered_data1 <- data.frame(maximum_fraction, cluster = as.factor(km$cluster))
show(clustered_data1)
# Create a scatter plot using ggplot
dotplot1 <- ggplot(clustered_data1, aes(x = Ctrl_fraction_max, y = RNase_fraction_max, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering for maxima",
x = "Ctrl_fraction_max",
y = "RNase_fraction_max",
color = "Cluster")
plot(dotplot1)
