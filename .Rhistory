print(paste("Value:", value))
# ERROR because we had RNAse rows with only zeros. I fixed that, for this code to run simply run the working code again.
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
knitr::opts_chunk$set(echo = TRUE)
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")
head(RDeeP_HeLa_Mitosis)
#Deleting the complete zero rows:
RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),]
# Extract the first three values from the column
subset_values <- RDeeP_HeLa_Mitosis[1, 1:3]
# Perform the t-test
t_test_result <- t.test(subset_values)
# Print the t-test result
print(t_test_result)
RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])
#For RNase it is easier, because we now can just take all the row which were not taken in the first table.
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]
head(RDeeP_HeLa_Mitosis_RNase)
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))
# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
# Extract the values for the current row (protein)
row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
# Create an empty vector to store the p-values for the current row (protein)
p_values_row <- c()
# Iterate over every three columns in the current row (protein)
for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
# Extract the values for the current set of three columns
column_values <- row_values[j:(j + 2)]
# Calculate the p-value for the set of three columns using t-test
t_result <- t.test(column_values)
p_value <- t_result$p.value
# Append the p-value to the vector for the current row (protein)
p_values_row <- c(p_values_row, p_value)
}
# Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
p_values_Ctrl[i, ] <- p_values_row
}
# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))
# Print the new dataframe
print(p_values_Ctrl)
#First finding the mean of all three replicates for every fraction separately:
Mitosis_Ctrl_mean = as.data.frame(
sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
apply(RDeeP_HeLa_Mitosis_Ctrl[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
#inner loop which calculates the mean for the three replicates, for each row anew.
}))
#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")
print(Mitosis_Ctrl_mean)
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))
head(Mitosis_Ctrl_100)
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
sapply(seq(0,72,3), function(i) {
apply(RDeeP_HeLa_Mitosis_RNase[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
}))
colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
#Now scaling
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))
head(Mitosis_RNase_100)
#Then maybe applying the z transformation on each row was a whole, Control and RNase separate? Still needs a lot of refining...
#Mitosis_Ctrl_norm <- apply(t(Mitosis_Ctrl_mean),1, function(x)(x - mean(x)) / sd(x))
#transpose is necessary as "apply" is always iterates the command or each column
head(Mitosis_Ctrl_mean)
# Min-max scaling function
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column).
# Print the scaled data
View(Mitosis_Ctrl_MM)
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="SIN3B_HUMAN", ylim=c(0,180000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN",ylim=c(0,1500000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="SIN3B_HUMAN Normalized", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("TARA_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="TARA_HUMAN Normailzed", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("TARA_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_MM[which(rownames(Mitosis_Ctrl_MM)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN MinMax",ylim=c(0,1))
lines(1:25, Mitosis_RNase_MM[which(rownames(Mitosis_RNase_MM)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_mean)) {
row_data <- Mitosis_Ctrl_mean[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has multiple peaks
if (length(peaks) > 1) {
rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
}
}
# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks)
head(rows_with_multiple_peaks)
# Step 1: Create an empty vector to store the row indices with one peak
rows_with_one_peak <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {   #why here with MitosisCtrl100 and above with MitosisCtrlMean?? Should it not be the same for comparison?
row_data <- Mitosis_Ctrl_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has only one peak
if (length(peaks) == 1) {
rows_with_one_peak <- c(rows_with_one_peak, row_index)
}
}
# Step 5: Print the row indices with only one peak
length(rows_with_one_peak)  # Number of rows with one peak
rows_with_one_peak  # Row indices with one peak
head(rows_with_one_peak)
# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) == nrow(Mitosis_Ctrl_100)
length(rows_with_multiple_peaks) + length(rows_with_one_peak) #7074 rows
nrow(Mitosis_Ctrl_100) #7158 rows
# Step 1: Create an empty vector to store the row indices with no peak
rows_with_no_peak <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) { #Ich habe das gleiche auch mit dem nicht "clean" dataframe durchgeführt, da waren es 100 Proteine, hier sind es jetzt 82. Also 18 davon hatten wir schon im Data cleanup gelöscht.
row_data <- Mitosis_Ctrl_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has no peak
if (length(peaks) == 0) {
rows_with_no_peak <- c(rows_with_no_peak, row_index)
}
}
# Step 5: Print the row indices with no peak
length(rows_with_no_peak)  # Number of rows with no peak #84
#what are rows with no peaks? Theoretically we already cleaned up the dataframe, should it not be free of 0 rows? #what does it mean (for our data) that the protein accumulates in the first/last fraction
# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) + length(rows_with_no_peak) == nrow(Mitosis_Ctrl_100)
# Test maximum value is in the last fraction (column), this means the protein accumulated at the bottom
has_max_in_last_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
max_index <- which.max(row)
max_index == ncol(Mitosis_Ctrl_100)
})
# Test if maximum value is in the first fraction, protein accumulated and the top
has_max_in_first_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
max_index <- which.max(row)
max_index == 1
})
# Check if has_max_in_last_col and has_max_in_first_col are complementary
are_complementary <- all(has_max_in_last_col != has_max_in_first_col)
are_complementary
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2
# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_index, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Find the row name
row_name <- row.names(Mitosis_Ctrl_100)[row_index]
# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5B_HUMAN"
# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_name, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Print the column name and value
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2
# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_index, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Find the row name
row_name <- row.names(Mitosis_RNase_100)[row_index]
# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5E_HUMAN"
# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_name, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Print the column name and value
print(paste("Column Name:", column_name))
print(paste("Value:", value))
knitr::opts_chunk$set(echo = TRUE)
RDeeP_HeLa_Mitosis = read.csv("https://www.dropbox.com/s/ttj1z98mxefq0aj/RDeeP_HeLa_Mitosis.csv?dl=1", header=TRUE, row.names=1, sep = ";")
head(RDeeP_HeLa_Mitosis)
#Deleting the complete zero rows:
RDeeP_HeLa_Mitosis <- RDeeP_HeLa_Mitosis[-which(rowSums(RDeeP_HeLa_Mitosis)==0),]
# Extract the first three values from the column
subset_values <- RDeeP_HeLa_Mitosis[1, 1:3]
# Perform the t-test
t_test_result <- t.test(subset_values)
# Print the t-test result
print(t_test_result)
RDeeP_HeLa_Mitosis_Ctrl = cbind(RDeeP_HeLa_Mitosis[,1:3],RDeeP_HeLa_Mitosis[,7:9],RDeeP_HeLa_Mitosis[,13:15],RDeeP_HeLa_Mitosis[,19:21],RDeeP_HeLa_Mitosis[,25:27],RDeeP_HeLa_Mitosis[,31:33],RDeeP_HeLa_Mitosis[,37:39],RDeeP_HeLa_Mitosis[,43:45],RDeeP_HeLa_Mitosis[,49:51],RDeeP_HeLa_Mitosis[,55:57],RDeeP_HeLa_Mitosis[,61:63],RDeeP_HeLa_Mitosis[,67:69],RDeeP_HeLa_Mitosis[,73:75],RDeeP_HeLa_Mitosis[,79:81],RDeeP_HeLa_Mitosis[,85:87],RDeeP_HeLa_Mitosis[,91:93],RDeeP_HeLa_Mitosis[,97:99],RDeeP_HeLa_Mitosis[,103:105],RDeeP_HeLa_Mitosis[,109:111],RDeeP_HeLa_Mitosis[,115:117],RDeeP_HeLa_Mitosis[,121:123],RDeeP_HeLa_Mitosis[,127:129],RDeeP_HeLa_Mitosis[,133:135],RDeeP_HeLa_Mitosis[,139:141],RDeeP_HeLa_Mitosis[,145:147])
#For RNase it is easier, because we now can just take all the row which were not taken in the first table.
RDeeP_HeLa_Mitosis_RNase=RDeeP_HeLa_Mitosis[,-which(names(RDeeP_HeLa_Mitosis) %in% colnames(RDeeP_HeLa_Mitosis_Ctrl))]
head(RDeeP_HeLa_Mitosis_RNase)
# Create an empty dataframe to store the p-values
p_values_Ctrl <- data.frame(matrix(ncol = ncol(RDeeP_HeLa_Mitosis_Ctrl)/3, nrow = nrow(RDeeP_HeLa_Mitosis_Ctrl)))
# Iterate over every row (protein) in the original table
for (i in 1:nrow(RDeeP_HeLa_Mitosis_Ctrl)) {
# Extract the values for the current row (protein)
row_values <- RDeeP_HeLa_Mitosis_Ctrl[i, ]
# Create an empty vector to store the p-values for the current row (protein)
p_values_row <- c()
# Iterate over every three columns in the current row (protein)
for (j in seq(1, ncol(RDeeP_HeLa_Mitosis_Ctrl), by = 3)) {
# Extract the values for the current set of three columns
column_values <- row_values[j:(j + 2)]
# Calculate the p-value for the set of three columns using t-test
t_result <- t.test(column_values)
p_value <- t_result$p.value
# Append the p-value to the vector for the current row (protein)
p_values_row <- c(p_values_row, p_value)
}
# Assign the p-values for the current row (protein) to the corresponding row in the new dataframe
p_values_Ctrl[i, ] <- p_values_row
}
# Optional: Rename the columns
colnames(p_values_Ctrl) <- paste("P-Values", 1:(ncol(p_values_Ctrl)))
# Print the new dataframe
print(p_values_Ctrl)
#First finding the mean of all three replicates for every fraction separately:
Mitosis_Ctrl_mean = as.data.frame(
sapply(seq(0,72,3), function(i) { #outer loop to repeatedly select the three replicates for each fraction
apply(RDeeP_HeLa_Mitosis_Ctrl[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
#inner loop which calculates the mean for the three replicates, for each row anew.
}))
#To have logical new column names, it is possible to paste the fraction number and add Ctrl_Mean separately to each new column name. The sequence goes from 1 to 25 in steps of one.
colnames(Mitosis_Ctrl_mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")
print(Mitosis_Ctrl_mean)
Mitosis_Ctrl_100 <- as.data.frame(sapply(Mitosis_Ctrl_mean, function(i){(i/apply(Mitosis_Ctrl_mean,1,sum))*100}))
head(Mitosis_Ctrl_100)
#First finding mean:
Mitosis_RNase_mean = as.data.frame(
sapply(seq(0,72,3), function(i) {
apply(RDeeP_HeLa_Mitosis_RNase[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})
}))
colnames(Mitosis_RNase_mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
#Now scaling
Mitosis_RNase_100 <- as.data.frame(sapply(Mitosis_RNase_mean, function(i){(i/apply(Mitosis_RNase_mean,1,sum))*100}))
head(Mitosis_RNase_100)
#Then maybe applying the z transformation on each row was a whole, Control and RNase separate? Still needs a lot of refining...
#Mitosis_Ctrl_norm <- apply(t(Mitosis_Ctrl_mean),1, function(x)(x - mean(x)) / sd(x))
#transpose is necessary as "apply" is always iterates the command or each column
head(Mitosis_Ctrl_mean)
# Min-max scaling function
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Apply min-max scaling
Mitosis_Ctrl_MM <- t(apply(Mitosis_Ctrl_mean, 1, min_max_scaling)) #apply function with MARGIN = 1 specifies that the function should be applied to each row (without t() it would be applied on each column).
# Print the scaled data
View(Mitosis_Ctrl_MM)
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="SIN3B_HUMAN", ylim=c(0,180000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_mean[which(rownames(Mitosis_Ctrl_mean)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN",ylim=c(0,1500000))
lines(1:25, Mitosis_RNase_mean[which(rownames(Mitosis_RNase_mean)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("SIN3B_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="SIN3B_HUMAN Normalized", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("SIN3B_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_100[which(rownames(Mitosis_Ctrl_100)==c("TARA_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Relative Protein Amount",main="TARA_HUMAN Normailzed", ylim=c(0,100))
lines(1:25, Mitosis_RNase_100[which(rownames(Mitosis_RNase_100)==c("TARA_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
plot(1:25, Mitosis_Ctrl_MM[which(rownames(Mitosis_Ctrl_MM)==c("CASP7_HUMAN")),],type="l",lwd=3,col="blue",xlab="Fractions",ylab="Absolute Protein Amount",main="CASP7_HUMAN MinMax",ylim=c(0,1))
lines(1:25, Mitosis_RNase_MM[which(rownames(Mitosis_RNase_MM)==c("CASP7_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("blue","red"),bg="white",lwd=2)
# Step 1: Create an empty vector to store the row indices with multiple peaks
rows_with_multiple_peaks <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_mean)) {
row_data <- Mitosis_Ctrl_mean[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has multiple peaks
if (length(peaks) > 1) {
rows_with_multiple_peaks <- c(rows_with_multiple_peaks, row_index)
}
}
# Step 5: Print the row indices with multiple peaks
length(rows_with_multiple_peaks)
head(rows_with_multiple_peaks)
# Step 1: Create an empty vector to store the row indices with one peak
rows_with_one_peak <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) {   #why here with MitosisCtrl100 and above with MitosisCtrlMean?? Should it not be the same for comparison?
row_data <- Mitosis_Ctrl_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has only one peak
if (length(peaks) == 1) {
rows_with_one_peak <- c(rows_with_one_peak, row_index)
}
}
# Step 5: Print the row indices with only one peak
length(rows_with_one_peak)  # Number of rows with one peak
rows_with_one_peak  # Row indices with one peak
head(rows_with_one_peak)
# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) == nrow(Mitosis_Ctrl_100)
length(rows_with_multiple_peaks) + length(rows_with_one_peak) #7074 rows
nrow(Mitosis_Ctrl_100) #7158 rows
# Step 1: Create an empty vector to store the row indices with no peak
rows_with_no_peak <- c()
# Step 2: Iterate over all rows in the dataframe
for (row_index in 1:nrow(Mitosis_Ctrl_100)) { #Ich habe das gleiche auch mit dem nicht "clean" dataframe durchgeführt, da waren es 100 Proteine, hier sind es jetzt 82. Also 18 davon hatten wir schon im Data cleanup gelöscht.
row_data <- Mitosis_Ctrl_100[row_index, ]
# Step 3: Find the peaks in the row data
peaks <- c()
for (i in 2:(length(row_data) - 1)) {
if (row_data[i] > row_data[i-1] && row_data[i] > row_data[i+1]) {
peaks <- c(peaks, i)
}
}
# Step 4: Check if the row has no peak
if (length(peaks) == 0) {
rows_with_no_peak <- c(rows_with_no_peak, row_index)
}
}
# Step 5: Print the row indices with no peak
length(rows_with_no_peak)  # Number of rows with no peak #84
#what are rows with no peaks? Theoretically we already cleaned up the dataframe, should it not be free of 0 rows? #what does it mean (for our data) that the protein accumulates in the first/last fraction
# COMPARISON
length(rows_with_multiple_peaks) + length(rows_with_one_peak) + length(rows_with_no_peak) == nrow(Mitosis_Ctrl_100)
# Test maximum value is in the last fraction (column), this means the protein accumulated at the bottom
has_max_in_last_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
max_index <- which.max(row)
max_index == ncol(Mitosis_Ctrl_100)
})
# Test if maximum value is in the first fraction, protein accumulated and the top
has_max_in_first_col <- apply(Mitosis_Ctrl_100[rows_with_no_peak, ], 1, function(row) {
max_index <- which.max(row)
max_index == 1
})
# Check if has_max_in_last_col and has_max_in_first_col are complementary
are_complementary <- all(has_max_in_last_col != has_max_in_first_col)
are_complementary
plot(seq_along(row_data), row_data, type = "l", xlab = "Index", ylab = "Value", main = row_name)
points(peaks, row_data[peaks], col = "red", pch = 16)
legend("topright",legend=c("Control mean"),col=c("black"),bg="white",lwd=2)
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2
# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_index, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Find the row name
row_name <- row.names(Mitosis_Ctrl_100)[row_index]
# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5B_HUMAN"
# Extract the row from the dataframe
row <- Mitosis_Ctrl_100[row_name, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_Ctrl_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Print the column name and value
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row index for which to find the column and value of global maximum
#Change Index as necessary
row_index <- 2
# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_index, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Find the row name
row_name <- row.names(Mitosis_RNase_100)[row_index]
# Print the column name and value
print(paste("Protein:", row_name))
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Row name for which to find the column and value of global maximum
#Change as necessary
row_name <- "2A5E_HUMAN"
# Extract the row from the dataframe
row <- Mitosis_RNase_100[row_name, ]
# Find the column index of the global maximum
column_index <- which.max(row)
# Find the column name corresponding to the column index
column_name <- colnames(Mitosis_RNase_100)[column_index]
# Find the value corresponding to the column of the global maximum
value <- row[column_index]
# Print the column name and value
print(paste("Column Name:", column_name))
print(paste("Value:", value))
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_Ctrl_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_Ctrl_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_Ctrl_100)
# Create a dataframe with the results
Ctrl_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
Ctrl_fraction_max <- data.frame(Fraction = column_indices)
# Print the results
#Shows protein name, fraction where global maxima was found and the maximum value
print(Ctrl_fraction_max_value)
print(Ctrl_fraction_max)
#Results as vector
as.vector(Ctrl_fraction_max) #just numbers (aka fractions where max)
# ERROR because we had RNAse rows with only zeros. I fixed that, for this code to run simply run the working code again.
# Find the column index of the global maximum for each row
column_indices <- apply(Mitosis_RNase_100, 1, which.max)
# Find the global maximum for each row
global_maxima <- apply(Mitosis_RNase_100, 1, max)
# Find the row names
row_names <- row.names(Mitosis_RNase_100)
# Create a dataframe with the results
RNase_fraction_max_value <- data.frame(Fraction = column_indices, MaxValue = global_maxima)
# Subtract the values and determine the shift
shift_result <- Ctrl_fraction_max - RNase_fraction_max
# Count the number of left shifts
sum(shift_dataframe$Shift == "left shift")
